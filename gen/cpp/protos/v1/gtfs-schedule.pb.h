// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/v1/gtfs-schedule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fv1_2fgtfs_2dschedule_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fv1_2fgtfs_2dschedule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fv1_2fgtfs_2dschedule_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fv1_2fgtfs_2dschedule_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fv1_2fgtfs_2dschedule_2eproto;
namespace transit_scheduled {
class Agency;
struct AgencyDefaultTypeInternal;
extern AgencyDefaultTypeInternal _Agency_default_instance_;
class Route;
struct RouteDefaultTypeInternal;
extern RouteDefaultTypeInternal _Route_default_instance_;
class Stop;
struct StopDefaultTypeInternal;
extern StopDefaultTypeInternal _Stop_default_instance_;
class StopTime;
struct StopTimeDefaultTypeInternal;
extern StopTimeDefaultTypeInternal _StopTime_default_instance_;
class Trip;
struct TripDefaultTypeInternal;
extern TripDefaultTypeInternal _Trip_default_instance_;
}  // namespace transit_scheduled
PROTOBUF_NAMESPACE_OPEN
template<> ::transit_scheduled::Agency* Arena::CreateMaybeMessage<::transit_scheduled::Agency>(Arena*);
template<> ::transit_scheduled::Route* Arena::CreateMaybeMessage<::transit_scheduled::Route>(Arena*);
template<> ::transit_scheduled::Stop* Arena::CreateMaybeMessage<::transit_scheduled::Stop>(Arena*);
template<> ::transit_scheduled::StopTime* Arena::CreateMaybeMessage<::transit_scheduled::StopTime>(Arena*);
template<> ::transit_scheduled::Trip* Arena::CreateMaybeMessage<::transit_scheduled::Trip>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace transit_scheduled {

enum Stop_LocationType : int {
  Stop_LocationType_LOCATION_TYPE_STOP = 0,
  Stop_LocationType_LOCATION_TYPE_STATION = 1,
  Stop_LocationType_LOCATION_TYPE_ENTRANCE_EXIT = 2,
  Stop_LocationType_LOCATION_TYPE_GENERIC_NODE = 3,
  Stop_LocationType_LOCATION_TYPE_BOARDING_AREA = 4,
  Stop_LocationType_Stop_LocationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Stop_LocationType_Stop_LocationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Stop_LocationType_IsValid(int value);
constexpr Stop_LocationType Stop_LocationType_LocationType_MIN = Stop_LocationType_LOCATION_TYPE_STOP;
constexpr Stop_LocationType Stop_LocationType_LocationType_MAX = Stop_LocationType_LOCATION_TYPE_BOARDING_AREA;
constexpr int Stop_LocationType_LocationType_ARRAYSIZE = Stop_LocationType_LocationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Stop_LocationType_descriptor();
template<typename T>
inline const std::string& Stop_LocationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Stop_LocationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Stop_LocationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Stop_LocationType_descriptor(), enum_t_value);
}
inline bool Stop_LocationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Stop_LocationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Stop_LocationType>(
    Stop_LocationType_descriptor(), name, value);
}
enum Stop_WheelchairBoarding : int {
  Stop_WheelchairBoarding_WHEELCHAIR_BOARDING_NO_INFO = 0,
  Stop_WheelchairBoarding_WHEELCHAIR_BOARDING_POSSIBLE = 1,
  Stop_WheelchairBoarding_WHEELCHAIR_BOARDING_NOT_POSSIBLE = 2,
  Stop_WheelchairBoarding_Stop_WheelchairBoarding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Stop_WheelchairBoarding_Stop_WheelchairBoarding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Stop_WheelchairBoarding_IsValid(int value);
constexpr Stop_WheelchairBoarding Stop_WheelchairBoarding_WheelchairBoarding_MIN = Stop_WheelchairBoarding_WHEELCHAIR_BOARDING_NO_INFO;
constexpr Stop_WheelchairBoarding Stop_WheelchairBoarding_WheelchairBoarding_MAX = Stop_WheelchairBoarding_WHEELCHAIR_BOARDING_NOT_POSSIBLE;
constexpr int Stop_WheelchairBoarding_WheelchairBoarding_ARRAYSIZE = Stop_WheelchairBoarding_WheelchairBoarding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Stop_WheelchairBoarding_descriptor();
template<typename T>
inline const std::string& Stop_WheelchairBoarding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Stop_WheelchairBoarding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Stop_WheelchairBoarding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Stop_WheelchairBoarding_descriptor(), enum_t_value);
}
inline bool Stop_WheelchairBoarding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Stop_WheelchairBoarding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Stop_WheelchairBoarding>(
    Stop_WheelchairBoarding_descriptor(), name, value);
}
enum Route_RouteType : int {
  Route_RouteType_ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL = 0,
  Route_RouteType_ROUTE_TYPE_SUBWAY_METRO = 1,
  Route_RouteType_ROUTE_TYPE_RAIL = 2,
  Route_RouteType_ROUTE_TYPE_BUS = 3,
  Route_RouteType_ROUTE_TYPE_FERRY = 4,
  Route_RouteType_ROUTE_TYPE_CABLE_TRAM = 5,
  Route_RouteType_ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABLE_CAR = 6,
  Route_RouteType_ROUTE_TYPE_FUNICULAR = 7,
  Route_RouteType_ROUTE_TYPE_TROLLEYBUS = 11,
  Route_RouteType_ROUTE_TYPE_MONORAIL = 12,
  Route_RouteType_Route_RouteType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Route_RouteType_Route_RouteType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Route_RouteType_IsValid(int value);
constexpr Route_RouteType Route_RouteType_RouteType_MIN = Route_RouteType_ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL;
constexpr Route_RouteType Route_RouteType_RouteType_MAX = Route_RouteType_ROUTE_TYPE_MONORAIL;
constexpr int Route_RouteType_RouteType_ARRAYSIZE = Route_RouteType_RouteType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Route_RouteType_descriptor();
template<typename T>
inline const std::string& Route_RouteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Route_RouteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Route_RouteType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Route_RouteType_descriptor(), enum_t_value);
}
inline bool Route_RouteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Route_RouteType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Route_RouteType>(
    Route_RouteType_descriptor(), name, value);
}
enum Trip_Direction : int {
  Trip_Direction_DIRECTION_ONE_DIRECTION = 0,
  Trip_Direction_DIRECTION_OPPOSITE = 1,
  Trip_Direction_Trip_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Trip_Direction_Trip_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Trip_Direction_IsValid(int value);
constexpr Trip_Direction Trip_Direction_Direction_MIN = Trip_Direction_DIRECTION_ONE_DIRECTION;
constexpr Trip_Direction Trip_Direction_Direction_MAX = Trip_Direction_DIRECTION_OPPOSITE;
constexpr int Trip_Direction_Direction_ARRAYSIZE = Trip_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Trip_Direction_descriptor();
template<typename T>
inline const std::string& Trip_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Trip_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Trip_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Trip_Direction_descriptor(), enum_t_value);
}
inline bool Trip_Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Trip_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Trip_Direction>(
    Trip_Direction_descriptor(), name, value);
}
enum Trip_WheelchairAccessibility : int {
  Trip_WheelchairAccessibility_WHEELCHAIR_ACCESSIBILITY_NO_INFO = 0,
  Trip_WheelchairAccessibility_WHEELCHAIR_ACCESSIBILITY_ACCESSIBLE = 1,
  Trip_WheelchairAccessibility_WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE = 2,
  Trip_WheelchairAccessibility_Trip_WheelchairAccessibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Trip_WheelchairAccessibility_Trip_WheelchairAccessibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Trip_WheelchairAccessibility_IsValid(int value);
constexpr Trip_WheelchairAccessibility Trip_WheelchairAccessibility_WheelchairAccessibility_MIN = Trip_WheelchairAccessibility_WHEELCHAIR_ACCESSIBILITY_NO_INFO;
constexpr Trip_WheelchairAccessibility Trip_WheelchairAccessibility_WheelchairAccessibility_MAX = Trip_WheelchairAccessibility_WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE;
constexpr int Trip_WheelchairAccessibility_WheelchairAccessibility_ARRAYSIZE = Trip_WheelchairAccessibility_WheelchairAccessibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Trip_WheelchairAccessibility_descriptor();
template<typename T>
inline const std::string& Trip_WheelchairAccessibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Trip_WheelchairAccessibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Trip_WheelchairAccessibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Trip_WheelchairAccessibility_descriptor(), enum_t_value);
}
inline bool Trip_WheelchairAccessibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Trip_WheelchairAccessibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Trip_WheelchairAccessibility>(
    Trip_WheelchairAccessibility_descriptor(), name, value);
}
enum Trip_BikeAllowance : int {
  Trip_BikeAllowance_BIKE_ALLOWANCE_NO_INFO = 0,
  Trip_BikeAllowance_BIKE_ALLOWANCE_ALLOWED = 1,
  Trip_BikeAllowance_BIKE_ALLOWANCE_NOT_ALLOWED = 2,
  Trip_BikeAllowance_Trip_BikeAllowance_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Trip_BikeAllowance_Trip_BikeAllowance_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Trip_BikeAllowance_IsValid(int value);
constexpr Trip_BikeAllowance Trip_BikeAllowance_BikeAllowance_MIN = Trip_BikeAllowance_BIKE_ALLOWANCE_NO_INFO;
constexpr Trip_BikeAllowance Trip_BikeAllowance_BikeAllowance_MAX = Trip_BikeAllowance_BIKE_ALLOWANCE_NOT_ALLOWED;
constexpr int Trip_BikeAllowance_BikeAllowance_ARRAYSIZE = Trip_BikeAllowance_BikeAllowance_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Trip_BikeAllowance_descriptor();
template<typename T>
inline const std::string& Trip_BikeAllowance_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Trip_BikeAllowance>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Trip_BikeAllowance_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Trip_BikeAllowance_descriptor(), enum_t_value);
}
inline bool Trip_BikeAllowance_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Trip_BikeAllowance* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Trip_BikeAllowance>(
    Trip_BikeAllowance_descriptor(), name, value);
}
enum StopTime_PickupType : int {
  StopTime_PickupType_PICKUP_TYPE_REGULARLY_SCHEDULED = 0,
  StopTime_PickupType_PICKUP_TYPE_NONE_AVAILABLE = 1,
  StopTime_PickupType_PICKUP_TYPE_MUST_PHONE_AGENCY = 2,
  StopTime_PickupType_PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER = 3,
  StopTime_PickupType_StopTime_PickupType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StopTime_PickupType_StopTime_PickupType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StopTime_PickupType_IsValid(int value);
constexpr StopTime_PickupType StopTime_PickupType_PickupType_MIN = StopTime_PickupType_PICKUP_TYPE_REGULARLY_SCHEDULED;
constexpr StopTime_PickupType StopTime_PickupType_PickupType_MAX = StopTime_PickupType_PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER;
constexpr int StopTime_PickupType_PickupType_ARRAYSIZE = StopTime_PickupType_PickupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopTime_PickupType_descriptor();
template<typename T>
inline const std::string& StopTime_PickupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopTime_PickupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopTime_PickupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StopTime_PickupType_descriptor(), enum_t_value);
}
inline bool StopTime_PickupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StopTime_PickupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StopTime_PickupType>(
    StopTime_PickupType_descriptor(), name, value);
}
enum StopTime_DropOffType : int {
  StopTime_DropOffType_DROP_OFF_TYPE_REGULARLY_SCHEDULED = 0,
  StopTime_DropOffType_DROP_OFF_TYPE_NONE_AVAILABLE = 1,
  StopTime_DropOffType_DROP_OFF_TYPE_MUST_PHONE_AGENCY = 2,
  StopTime_DropOffType_DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER = 3,
  StopTime_DropOffType_StopTime_DropOffType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StopTime_DropOffType_StopTime_DropOffType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StopTime_DropOffType_IsValid(int value);
constexpr StopTime_DropOffType StopTime_DropOffType_DropOffType_MIN = StopTime_DropOffType_DROP_OFF_TYPE_REGULARLY_SCHEDULED;
constexpr StopTime_DropOffType StopTime_DropOffType_DropOffType_MAX = StopTime_DropOffType_DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER;
constexpr int StopTime_DropOffType_DropOffType_ARRAYSIZE = StopTime_DropOffType_DropOffType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopTime_DropOffType_descriptor();
template<typename T>
inline const std::string& StopTime_DropOffType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopTime_DropOffType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopTime_DropOffType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StopTime_DropOffType_descriptor(), enum_t_value);
}
inline bool StopTime_DropOffType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StopTime_DropOffType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StopTime_DropOffType>(
    StopTime_DropOffType_descriptor(), name, value);
}
enum StopTime_TimePoint : int {
  StopTime_TimePoint_TIME_POINT_APPROXIMATE = 0,
  StopTime_TimePoint_TIME_POINT_EXACT = 1,
  StopTime_TimePoint_StopTime_TimePoint_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StopTime_TimePoint_StopTime_TimePoint_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StopTime_TimePoint_IsValid(int value);
constexpr StopTime_TimePoint StopTime_TimePoint_TimePoint_MIN = StopTime_TimePoint_TIME_POINT_APPROXIMATE;
constexpr StopTime_TimePoint StopTime_TimePoint_TimePoint_MAX = StopTime_TimePoint_TIME_POINT_EXACT;
constexpr int StopTime_TimePoint_TimePoint_ARRAYSIZE = StopTime_TimePoint_TimePoint_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopTime_TimePoint_descriptor();
template<typename T>
inline const std::string& StopTime_TimePoint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopTime_TimePoint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopTime_TimePoint_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StopTime_TimePoint_descriptor(), enum_t_value);
}
inline bool StopTime_TimePoint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StopTime_TimePoint* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StopTime_TimePoint>(
    StopTime_TimePoint_descriptor(), name, value);
}
enum ContinuousPickup : int {
  CONTINUOUS_PICKUP_STOPPING = 0,
  CONTINUOUS_PICKUP_NO_CONTINUOUS_STOPPING = 1,
  CONTINUOUS_PICKUP_MUST_PHONE_AGENCY = 2,
  CONTINUOUS_PICKUP_MUST_COORDINATE_WITH_DRIVER = 3,
  ContinuousPickup_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ContinuousPickup_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ContinuousPickup_IsValid(int value);
constexpr ContinuousPickup ContinuousPickup_MIN = CONTINUOUS_PICKUP_STOPPING;
constexpr ContinuousPickup ContinuousPickup_MAX = CONTINUOUS_PICKUP_MUST_COORDINATE_WITH_DRIVER;
constexpr int ContinuousPickup_ARRAYSIZE = ContinuousPickup_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContinuousPickup_descriptor();
template<typename T>
inline const std::string& ContinuousPickup_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContinuousPickup>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContinuousPickup_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContinuousPickup_descriptor(), enum_t_value);
}
inline bool ContinuousPickup_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContinuousPickup* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContinuousPickup>(
    ContinuousPickup_descriptor(), name, value);
}
enum ContinuousDropOff : int {
  CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING = 0,
  CONTINUOUS_DROP_OFF_NO_CONTINUOUS_STOPPING = 1,
  CONTINUOUS_DROP_OFF_MUST_PHONE_AGENCY = 2,
  CONTINUOUS_DROP_OFF_MUST_COORDINATE_WITH_DRIVER = 3,
  ContinuousDropOff_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ContinuousDropOff_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ContinuousDropOff_IsValid(int value);
constexpr ContinuousDropOff ContinuousDropOff_MIN = CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING;
constexpr ContinuousDropOff ContinuousDropOff_MAX = CONTINUOUS_DROP_OFF_MUST_COORDINATE_WITH_DRIVER;
constexpr int ContinuousDropOff_ARRAYSIZE = ContinuousDropOff_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContinuousDropOff_descriptor();
template<typename T>
inline const std::string& ContinuousDropOff_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContinuousDropOff>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContinuousDropOff_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContinuousDropOff_descriptor(), enum_t_value);
}
inline bool ContinuousDropOff_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContinuousDropOff* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContinuousDropOff>(
    ContinuousDropOff_descriptor(), name, value);
}
// ===================================================================

class Agency final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_scheduled.Agency) */ {
 public:
  inline Agency() : Agency(nullptr) {}
  ~Agency() override;
  explicit PROTOBUF_CONSTEXPR Agency(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Agency(const Agency& from);
  Agency(Agency&& from) noexcept
    : Agency() {
    *this = ::std::move(from);
  }

  inline Agency& operator=(const Agency& from) {
    CopyFrom(from);
    return *this;
  }
  inline Agency& operator=(Agency&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Agency& default_instance() {
    return *internal_default_instance();
  }
  static inline const Agency* internal_default_instance() {
    return reinterpret_cast<const Agency*>(
               &_Agency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Agency& a, Agency& b) {
    a.Swap(&b);
  }
  inline void Swap(Agency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Agency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Agency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Agency>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Agency& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Agency& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Agency* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_scheduled.Agency";
  }
  protected:
  explicit Agency(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgencyIdFieldNumber = 1,
    kAgencyNameFieldNumber = 2,
    kAgencyUrlFieldNumber = 3,
    kAgencyTimezoneFieldNumber = 4,
    kAgencyLangFieldNumber = 5,
    kAgencyPhoneFieldNumber = 6,
    kAgencyFareUrlFieldNumber = 7,
    kAgencyEmailFieldNumber = 8,
  };
  // string agency_id = 1;
  void clear_agency_id();
  const std::string& agency_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_id();
  PROTOBUF_NODISCARD std::string* release_agency_id();
  void set_allocated_agency_id(std::string* agency_id);
  private:
  const std::string& _internal_agency_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_id(const std::string& value);
  std::string* _internal_mutable_agency_id();
  public:

  // string agency_name = 2;
  void clear_agency_name();
  const std::string& agency_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_name();
  PROTOBUF_NODISCARD std::string* release_agency_name();
  void set_allocated_agency_name(std::string* agency_name);
  private:
  const std::string& _internal_agency_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_name(const std::string& value);
  std::string* _internal_mutable_agency_name();
  public:

  // string agency_url = 3;
  void clear_agency_url();
  const std::string& agency_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_url();
  PROTOBUF_NODISCARD std::string* release_agency_url();
  void set_allocated_agency_url(std::string* agency_url);
  private:
  const std::string& _internal_agency_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_url(const std::string& value);
  std::string* _internal_mutable_agency_url();
  public:

  // string agency_timezone = 4;
  void clear_agency_timezone();
  const std::string& agency_timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_timezone();
  PROTOBUF_NODISCARD std::string* release_agency_timezone();
  void set_allocated_agency_timezone(std::string* agency_timezone);
  private:
  const std::string& _internal_agency_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_timezone(const std::string& value);
  std::string* _internal_mutable_agency_timezone();
  public:

  // string agency_lang = 5;
  void clear_agency_lang();
  const std::string& agency_lang() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_lang(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_lang();
  PROTOBUF_NODISCARD std::string* release_agency_lang();
  void set_allocated_agency_lang(std::string* agency_lang);
  private:
  const std::string& _internal_agency_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_lang(const std::string& value);
  std::string* _internal_mutable_agency_lang();
  public:

  // string agency_phone = 6;
  void clear_agency_phone();
  const std::string& agency_phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_phone();
  PROTOBUF_NODISCARD std::string* release_agency_phone();
  void set_allocated_agency_phone(std::string* agency_phone);
  private:
  const std::string& _internal_agency_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_phone(const std::string& value);
  std::string* _internal_mutable_agency_phone();
  public:

  // string agency_fare_url = 7;
  void clear_agency_fare_url();
  const std::string& agency_fare_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_fare_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_fare_url();
  PROTOBUF_NODISCARD std::string* release_agency_fare_url();
  void set_allocated_agency_fare_url(std::string* agency_fare_url);
  private:
  const std::string& _internal_agency_fare_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_fare_url(const std::string& value);
  std::string* _internal_mutable_agency_fare_url();
  public:

  // string agency_email = 8;
  void clear_agency_email();
  const std::string& agency_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_email();
  PROTOBUF_NODISCARD std::string* release_agency_email();
  void set_allocated_agency_email(std::string* agency_email);
  private:
  const std::string& _internal_agency_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_email(const std::string& value);
  std::string* _internal_mutable_agency_email();
  public:

  // @@protoc_insertion_point(class_scope:transit_scheduled.Agency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_timezone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_lang_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_phone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_fare_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fv1_2fgtfs_2dschedule_2eproto;
};
// -------------------------------------------------------------------

class Stop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_scheduled.Stop) */ {
 public:
  inline Stop() : Stop(nullptr) {}
  ~Stop() override;
  explicit PROTOBUF_CONSTEXPR Stop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stop(const Stop& from);
  Stop(Stop&& from) noexcept
    : Stop() {
    *this = ::std::move(from);
  }

  inline Stop& operator=(const Stop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stop& operator=(Stop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stop* internal_default_instance() {
    return reinterpret_cast<const Stop*>(
               &_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Stop& a, Stop& b) {
    a.Swap(&b);
  }
  inline void Swap(Stop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stop& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_scheduled.Stop";
  }
  protected:
  explicit Stop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Stop_LocationType LocationType;
  static constexpr LocationType LOCATION_TYPE_STOP =
    Stop_LocationType_LOCATION_TYPE_STOP;
  static constexpr LocationType LOCATION_TYPE_STATION =
    Stop_LocationType_LOCATION_TYPE_STATION;
  static constexpr LocationType LOCATION_TYPE_ENTRANCE_EXIT =
    Stop_LocationType_LOCATION_TYPE_ENTRANCE_EXIT;
  static constexpr LocationType LOCATION_TYPE_GENERIC_NODE =
    Stop_LocationType_LOCATION_TYPE_GENERIC_NODE;
  static constexpr LocationType LOCATION_TYPE_BOARDING_AREA =
    Stop_LocationType_LOCATION_TYPE_BOARDING_AREA;
  static inline bool LocationType_IsValid(int value) {
    return Stop_LocationType_IsValid(value);
  }
  static constexpr LocationType LocationType_MIN =
    Stop_LocationType_LocationType_MIN;
  static constexpr LocationType LocationType_MAX =
    Stop_LocationType_LocationType_MAX;
  static constexpr int LocationType_ARRAYSIZE =
    Stop_LocationType_LocationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LocationType_descriptor() {
    return Stop_LocationType_descriptor();
  }
  template<typename T>
  static inline const std::string& LocationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LocationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LocationType_Name.");
    return Stop_LocationType_Name(enum_t_value);
  }
  static inline bool LocationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LocationType* value) {
    return Stop_LocationType_Parse(name, value);
  }

  typedef Stop_WheelchairBoarding WheelchairBoarding;
  static constexpr WheelchairBoarding WHEELCHAIR_BOARDING_NO_INFO =
    Stop_WheelchairBoarding_WHEELCHAIR_BOARDING_NO_INFO;
  static constexpr WheelchairBoarding WHEELCHAIR_BOARDING_POSSIBLE =
    Stop_WheelchairBoarding_WHEELCHAIR_BOARDING_POSSIBLE;
  static constexpr WheelchairBoarding WHEELCHAIR_BOARDING_NOT_POSSIBLE =
    Stop_WheelchairBoarding_WHEELCHAIR_BOARDING_NOT_POSSIBLE;
  static inline bool WheelchairBoarding_IsValid(int value) {
    return Stop_WheelchairBoarding_IsValid(value);
  }
  static constexpr WheelchairBoarding WheelchairBoarding_MIN =
    Stop_WheelchairBoarding_WheelchairBoarding_MIN;
  static constexpr WheelchairBoarding WheelchairBoarding_MAX =
    Stop_WheelchairBoarding_WheelchairBoarding_MAX;
  static constexpr int WheelchairBoarding_ARRAYSIZE =
    Stop_WheelchairBoarding_WheelchairBoarding_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WheelchairBoarding_descriptor() {
    return Stop_WheelchairBoarding_descriptor();
  }
  template<typename T>
  static inline const std::string& WheelchairBoarding_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WheelchairBoarding>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WheelchairBoarding_Name.");
    return Stop_WheelchairBoarding_Name(enum_t_value);
  }
  static inline bool WheelchairBoarding_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WheelchairBoarding* value) {
    return Stop_WheelchairBoarding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopIdFieldNumber = 1,
    kStopCodeFieldNumber = 2,
    kStopNameFieldNumber = 3,
    kTtsStopNameFieldNumber = 4,
    kStopDescFieldNumber = 5,
    kZoneIdFieldNumber = 8,
    kStopUrlFieldNumber = 9,
    kParentStationFieldNumber = 11,
    kStopTimezoneFieldNumber = 12,
    kLevelIdFieldNumber = 14,
    kPlatformCodeFieldNumber = 15,
    kStopLatFieldNumber = 6,
    kStopLonFieldNumber = 7,
    kLocationTypeFieldNumber = 10,
    kWheelchairBoardingFieldNumber = 13,
  };
  // string stop_id = 1;
  void clear_stop_id();
  const std::string& stop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* stop_id);
  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(const std::string& value);
  std::string* _internal_mutable_stop_id();
  public:

  // string stop_code = 2;
  void clear_stop_code();
  const std::string& stop_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_code();
  PROTOBUF_NODISCARD std::string* release_stop_code();
  void set_allocated_stop_code(std::string* stop_code);
  private:
  const std::string& _internal_stop_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_code(const std::string& value);
  std::string* _internal_mutable_stop_code();
  public:

  // string stop_name = 3;
  void clear_stop_name();
  const std::string& stop_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_name();
  PROTOBUF_NODISCARD std::string* release_stop_name();
  void set_allocated_stop_name(std::string* stop_name);
  private:
  const std::string& _internal_stop_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_name(const std::string& value);
  std::string* _internal_mutable_stop_name();
  public:

  // string tts_stop_name = 4;
  void clear_tts_stop_name();
  const std::string& tts_stop_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tts_stop_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tts_stop_name();
  PROTOBUF_NODISCARD std::string* release_tts_stop_name();
  void set_allocated_tts_stop_name(std::string* tts_stop_name);
  private:
  const std::string& _internal_tts_stop_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tts_stop_name(const std::string& value);
  std::string* _internal_mutable_tts_stop_name();
  public:

  // string stop_desc = 5;
  void clear_stop_desc();
  const std::string& stop_desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_desc();
  PROTOBUF_NODISCARD std::string* release_stop_desc();
  void set_allocated_stop_desc(std::string* stop_desc);
  private:
  const std::string& _internal_stop_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_desc(const std::string& value);
  std::string* _internal_mutable_stop_desc();
  public:

  // string zone_id = 8;
  void clear_zone_id();
  const std::string& zone_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zone_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zone_id();
  PROTOBUF_NODISCARD std::string* release_zone_id();
  void set_allocated_zone_id(std::string* zone_id);
  private:
  const std::string& _internal_zone_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zone_id(const std::string& value);
  std::string* _internal_mutable_zone_id();
  public:

  // string stop_url = 9;
  void clear_stop_url();
  const std::string& stop_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_url();
  PROTOBUF_NODISCARD std::string* release_stop_url();
  void set_allocated_stop_url(std::string* stop_url);
  private:
  const std::string& _internal_stop_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_url(const std::string& value);
  std::string* _internal_mutable_stop_url();
  public:

  // string parent_station = 11;
  void clear_parent_station();
  const std::string& parent_station() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_station(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_station();
  PROTOBUF_NODISCARD std::string* release_parent_station();
  void set_allocated_parent_station(std::string* parent_station);
  private:
  const std::string& _internal_parent_station() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_station(const std::string& value);
  std::string* _internal_mutable_parent_station();
  public:

  // string stop_timezone = 12;
  void clear_stop_timezone();
  const std::string& stop_timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_timezone();
  PROTOBUF_NODISCARD std::string* release_stop_timezone();
  void set_allocated_stop_timezone(std::string* stop_timezone);
  private:
  const std::string& _internal_stop_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_timezone(const std::string& value);
  std::string* _internal_mutable_stop_timezone();
  public:

  // string level_id = 14;
  void clear_level_id();
  const std::string& level_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level_id();
  PROTOBUF_NODISCARD std::string* release_level_id();
  void set_allocated_level_id(std::string* level_id);
  private:
  const std::string& _internal_level_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level_id(const std::string& value);
  std::string* _internal_mutable_level_id();
  public:

  // string platform_code = 15;
  void clear_platform_code();
  const std::string& platform_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform_code();
  PROTOBUF_NODISCARD std::string* release_platform_code();
  void set_allocated_platform_code(std::string* platform_code);
  private:
  const std::string& _internal_platform_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_code(const std::string& value);
  std::string* _internal_mutable_platform_code();
  public:

  // double stop_lat = 6;
  void clear_stop_lat();
  double stop_lat() const;
  void set_stop_lat(double value);
  private:
  double _internal_stop_lat() const;
  void _internal_set_stop_lat(double value);
  public:

  // double stop_lon = 7;
  void clear_stop_lon();
  double stop_lon() const;
  void set_stop_lon(double value);
  private:
  double _internal_stop_lon() const;
  void _internal_set_stop_lon(double value);
  public:

  // .transit_scheduled.Stop.LocationType location_type = 10;
  void clear_location_type();
  ::transit_scheduled::Stop_LocationType location_type() const;
  void set_location_type(::transit_scheduled::Stop_LocationType value);
  private:
  ::transit_scheduled::Stop_LocationType _internal_location_type() const;
  void _internal_set_location_type(::transit_scheduled::Stop_LocationType value);
  public:

  // .transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;
  void clear_wheelchair_boarding();
  ::transit_scheduled::Stop_WheelchairBoarding wheelchair_boarding() const;
  void set_wheelchair_boarding(::transit_scheduled::Stop_WheelchairBoarding value);
  private:
  ::transit_scheduled::Stop_WheelchairBoarding _internal_wheelchair_boarding() const;
  void _internal_set_wheelchair_boarding(::transit_scheduled::Stop_WheelchairBoarding value);
  public:

  // @@protoc_insertion_point(class_scope:transit_scheduled.Stop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tts_stop_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zone_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_station_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_timezone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_code_;
  double stop_lat_;
  double stop_lon_;
  int location_type_;
  int wheelchair_boarding_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fv1_2fgtfs_2dschedule_2eproto;
};
// -------------------------------------------------------------------

class Route final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_scheduled.Route) */ {
 public:
  inline Route() : Route(nullptr) {}
  ~Route() override;
  explicit PROTOBUF_CONSTEXPR Route(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Route(const Route& from);
  Route(Route&& from) noexcept
    : Route() {
    *this = ::std::move(from);
  }

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline Route& operator=(Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const Route* internal_default_instance() {
    return reinterpret_cast<const Route*>(
               &_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Route& a, Route& b) {
    a.Swap(&b);
  }
  inline void Swap(Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Route* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Route* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Route>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Route& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Route& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Route* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_scheduled.Route";
  }
  protected:
  explicit Route(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Route_RouteType RouteType;
  static constexpr RouteType ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL =
    Route_RouteType_ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL;
  static constexpr RouteType ROUTE_TYPE_SUBWAY_METRO =
    Route_RouteType_ROUTE_TYPE_SUBWAY_METRO;
  static constexpr RouteType ROUTE_TYPE_RAIL =
    Route_RouteType_ROUTE_TYPE_RAIL;
  static constexpr RouteType ROUTE_TYPE_BUS =
    Route_RouteType_ROUTE_TYPE_BUS;
  static constexpr RouteType ROUTE_TYPE_FERRY =
    Route_RouteType_ROUTE_TYPE_FERRY;
  static constexpr RouteType ROUTE_TYPE_CABLE_TRAM =
    Route_RouteType_ROUTE_TYPE_CABLE_TRAM;
  static constexpr RouteType ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABLE_CAR =
    Route_RouteType_ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABLE_CAR;
  static constexpr RouteType ROUTE_TYPE_FUNICULAR =
    Route_RouteType_ROUTE_TYPE_FUNICULAR;
  static constexpr RouteType ROUTE_TYPE_TROLLEYBUS =
    Route_RouteType_ROUTE_TYPE_TROLLEYBUS;
  static constexpr RouteType ROUTE_TYPE_MONORAIL =
    Route_RouteType_ROUTE_TYPE_MONORAIL;
  static inline bool RouteType_IsValid(int value) {
    return Route_RouteType_IsValid(value);
  }
  static constexpr RouteType RouteType_MIN =
    Route_RouteType_RouteType_MIN;
  static constexpr RouteType RouteType_MAX =
    Route_RouteType_RouteType_MAX;
  static constexpr int RouteType_ARRAYSIZE =
    Route_RouteType_RouteType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RouteType_descriptor() {
    return Route_RouteType_descriptor();
  }
  template<typename T>
  static inline const std::string& RouteType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RouteType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RouteType_Name.");
    return Route_RouteType_Name(enum_t_value);
  }
  static inline bool RouteType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RouteType* value) {
    return Route_RouteType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRouteIdFieldNumber = 1,
    kAgencyIdFieldNumber = 2,
    kRouteShortNameFieldNumber = 3,
    kRouteLongNameFieldNumber = 4,
    kRouteDescFieldNumber = 5,
    kRouteUrlFieldNumber = 7,
    kRouteColorFieldNumber = 8,
    kRouteTextColorFieldNumber = 9,
    kNetworkIdFieldNumber = 13,
    kRouteTypeFieldNumber = 6,
    kRouteSortOrderFieldNumber = 10,
    kContinuousPickupFieldNumber = 11,
    kContinuousDropOffFieldNumber = 12,
  };
  // string route_id = 1;
  void clear_route_id();
  const std::string& route_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* route_id);
  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(const std::string& value);
  std::string* _internal_mutable_route_id();
  public:

  // string agency_id = 2;
  void clear_agency_id();
  const std::string& agency_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_id();
  PROTOBUF_NODISCARD std::string* release_agency_id();
  void set_allocated_agency_id(std::string* agency_id);
  private:
  const std::string& _internal_agency_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_id(const std::string& value);
  std::string* _internal_mutable_agency_id();
  public:

  // string route_short_name = 3;
  void clear_route_short_name();
  const std::string& route_short_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_short_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_short_name();
  PROTOBUF_NODISCARD std::string* release_route_short_name();
  void set_allocated_route_short_name(std::string* route_short_name);
  private:
  const std::string& _internal_route_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_short_name(const std::string& value);
  std::string* _internal_mutable_route_short_name();
  public:

  // string route_long_name = 4;
  void clear_route_long_name();
  const std::string& route_long_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_long_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_long_name();
  PROTOBUF_NODISCARD std::string* release_route_long_name();
  void set_allocated_route_long_name(std::string* route_long_name);
  private:
  const std::string& _internal_route_long_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_long_name(const std::string& value);
  std::string* _internal_mutable_route_long_name();
  public:

  // string route_desc = 5;
  void clear_route_desc();
  const std::string& route_desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_desc();
  PROTOBUF_NODISCARD std::string* release_route_desc();
  void set_allocated_route_desc(std::string* route_desc);
  private:
  const std::string& _internal_route_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_desc(const std::string& value);
  std::string* _internal_mutable_route_desc();
  public:

  // string route_url = 7;
  void clear_route_url();
  const std::string& route_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_url();
  PROTOBUF_NODISCARD std::string* release_route_url();
  void set_allocated_route_url(std::string* route_url);
  private:
  const std::string& _internal_route_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_url(const std::string& value);
  std::string* _internal_mutable_route_url();
  public:

  // string route_color = 8;
  void clear_route_color();
  const std::string& route_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_color();
  PROTOBUF_NODISCARD std::string* release_route_color();
  void set_allocated_route_color(std::string* route_color);
  private:
  const std::string& _internal_route_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_color(const std::string& value);
  std::string* _internal_mutable_route_color();
  public:

  // string route_text_color = 9;
  void clear_route_text_color();
  const std::string& route_text_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_text_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_text_color();
  PROTOBUF_NODISCARD std::string* release_route_text_color();
  void set_allocated_route_text_color(std::string* route_text_color);
  private:
  const std::string& _internal_route_text_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_text_color(const std::string& value);
  std::string* _internal_mutable_route_text_color();
  public:

  // string network_id = 13;
  void clear_network_id();
  const std::string& network_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network_id();
  PROTOBUF_NODISCARD std::string* release_network_id();
  void set_allocated_network_id(std::string* network_id);
  private:
  const std::string& _internal_network_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_id(const std::string& value);
  std::string* _internal_mutable_network_id();
  public:

  // .transit_scheduled.Route.RouteType route_type = 6;
  void clear_route_type();
  ::transit_scheduled::Route_RouteType route_type() const;
  void set_route_type(::transit_scheduled::Route_RouteType value);
  private:
  ::transit_scheduled::Route_RouteType _internal_route_type() const;
  void _internal_set_route_type(::transit_scheduled::Route_RouteType value);
  public:

  // uint32 route_sort_order = 10;
  void clear_route_sort_order();
  uint32_t route_sort_order() const;
  void set_route_sort_order(uint32_t value);
  private:
  uint32_t _internal_route_sort_order() const;
  void _internal_set_route_sort_order(uint32_t value);
  public:

  // .transit_scheduled.ContinuousPickup continuous_pickup = 11;
  void clear_continuous_pickup();
  ::transit_scheduled::ContinuousPickup continuous_pickup() const;
  void set_continuous_pickup(::transit_scheduled::ContinuousPickup value);
  private:
  ::transit_scheduled::ContinuousPickup _internal_continuous_pickup() const;
  void _internal_set_continuous_pickup(::transit_scheduled::ContinuousPickup value);
  public:

  // .transit_scheduled.ContinuousDropOff continuous_drop_off = 12;
  void clear_continuous_drop_off();
  ::transit_scheduled::ContinuousDropOff continuous_drop_off() const;
  void set_continuous_drop_off(::transit_scheduled::ContinuousDropOff value);
  private:
  ::transit_scheduled::ContinuousDropOff _internal_continuous_drop_off() const;
  void _internal_set_continuous_drop_off(::transit_scheduled::ContinuousDropOff value);
  public:

  // @@protoc_insertion_point(class_scope:transit_scheduled.Route)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_short_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_long_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_text_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_id_;
  int route_type_;
  uint32_t route_sort_order_;
  int continuous_pickup_;
  int continuous_drop_off_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fv1_2fgtfs_2dschedule_2eproto;
};
// -------------------------------------------------------------------

class Trip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_scheduled.Trip) */ {
 public:
  inline Trip() : Trip(nullptr) {}
  ~Trip() override;
  explicit PROTOBUF_CONSTEXPR Trip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trip(const Trip& from);
  Trip(Trip&& from) noexcept
    : Trip() {
    *this = ::std::move(from);
  }

  inline Trip& operator=(const Trip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trip& operator=(Trip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trip& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trip* internal_default_instance() {
    return reinterpret_cast<const Trip*>(
               &_Trip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Trip& a, Trip& b) {
    a.Swap(&b);
  }
  inline void Swap(Trip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Trip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Trip& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_scheduled.Trip";
  }
  protected:
  explicit Trip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Trip_Direction Direction;
  static constexpr Direction DIRECTION_ONE_DIRECTION =
    Trip_Direction_DIRECTION_ONE_DIRECTION;
  static constexpr Direction DIRECTION_OPPOSITE =
    Trip_Direction_DIRECTION_OPPOSITE;
  static inline bool Direction_IsValid(int value) {
    return Trip_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    Trip_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    Trip_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    Trip_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return Trip_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return Trip_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Direction* value) {
    return Trip_Direction_Parse(name, value);
  }

  typedef Trip_WheelchairAccessibility WheelchairAccessibility;
  static constexpr WheelchairAccessibility WHEELCHAIR_ACCESSIBILITY_NO_INFO =
    Trip_WheelchairAccessibility_WHEELCHAIR_ACCESSIBILITY_NO_INFO;
  static constexpr WheelchairAccessibility WHEELCHAIR_ACCESSIBILITY_ACCESSIBLE =
    Trip_WheelchairAccessibility_WHEELCHAIR_ACCESSIBILITY_ACCESSIBLE;
  static constexpr WheelchairAccessibility WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE =
    Trip_WheelchairAccessibility_WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE;
  static inline bool WheelchairAccessibility_IsValid(int value) {
    return Trip_WheelchairAccessibility_IsValid(value);
  }
  static constexpr WheelchairAccessibility WheelchairAccessibility_MIN =
    Trip_WheelchairAccessibility_WheelchairAccessibility_MIN;
  static constexpr WheelchairAccessibility WheelchairAccessibility_MAX =
    Trip_WheelchairAccessibility_WheelchairAccessibility_MAX;
  static constexpr int WheelchairAccessibility_ARRAYSIZE =
    Trip_WheelchairAccessibility_WheelchairAccessibility_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WheelchairAccessibility_descriptor() {
    return Trip_WheelchairAccessibility_descriptor();
  }
  template<typename T>
  static inline const std::string& WheelchairAccessibility_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WheelchairAccessibility>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WheelchairAccessibility_Name.");
    return Trip_WheelchairAccessibility_Name(enum_t_value);
  }
  static inline bool WheelchairAccessibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WheelchairAccessibility* value) {
    return Trip_WheelchairAccessibility_Parse(name, value);
  }

  typedef Trip_BikeAllowance BikeAllowance;
  static constexpr BikeAllowance BIKE_ALLOWANCE_NO_INFO =
    Trip_BikeAllowance_BIKE_ALLOWANCE_NO_INFO;
  static constexpr BikeAllowance BIKE_ALLOWANCE_ALLOWED =
    Trip_BikeAllowance_BIKE_ALLOWANCE_ALLOWED;
  static constexpr BikeAllowance BIKE_ALLOWANCE_NOT_ALLOWED =
    Trip_BikeAllowance_BIKE_ALLOWANCE_NOT_ALLOWED;
  static inline bool BikeAllowance_IsValid(int value) {
    return Trip_BikeAllowance_IsValid(value);
  }
  static constexpr BikeAllowance BikeAllowance_MIN =
    Trip_BikeAllowance_BikeAllowance_MIN;
  static constexpr BikeAllowance BikeAllowance_MAX =
    Trip_BikeAllowance_BikeAllowance_MAX;
  static constexpr int BikeAllowance_ARRAYSIZE =
    Trip_BikeAllowance_BikeAllowance_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BikeAllowance_descriptor() {
    return Trip_BikeAllowance_descriptor();
  }
  template<typename T>
  static inline const std::string& BikeAllowance_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BikeAllowance>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BikeAllowance_Name.");
    return Trip_BikeAllowance_Name(enum_t_value);
  }
  static inline bool BikeAllowance_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BikeAllowance* value) {
    return Trip_BikeAllowance_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRouteIdFieldNumber = 1,
    kServiceIdFieldNumber = 2,
    kTripIdFieldNumber = 3,
    kTripHeadsignFieldNumber = 4,
    kTripShortNameFieldNumber = 5,
    kBlockIdFieldNumber = 7,
    kShapeIdFieldNumber = 8,
    kDirectionIdFieldNumber = 6,
    kWheelchairAccessibleFieldNumber = 9,
    kBikesAllowedFieldNumber = 10,
  };
  // string route_id = 1;
  void clear_route_id();
  const std::string& route_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* route_id);
  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(const std::string& value);
  std::string* _internal_mutable_route_id();
  public:

  // string service_id = 2;
  void clear_service_id();
  const std::string& service_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_id();
  PROTOBUF_NODISCARD std::string* release_service_id();
  void set_allocated_service_id(std::string* service_id);
  private:
  const std::string& _internal_service_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_id(const std::string& value);
  std::string* _internal_mutable_service_id();
  public:

  // string trip_id = 3;
  void clear_trip_id();
  const std::string& trip_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trip_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trip_id();
  PROTOBUF_NODISCARD std::string* release_trip_id();
  void set_allocated_trip_id(std::string* trip_id);
  private:
  const std::string& _internal_trip_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_id(const std::string& value);
  std::string* _internal_mutable_trip_id();
  public:

  // string trip_headsign = 4;
  void clear_trip_headsign();
  const std::string& trip_headsign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trip_headsign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trip_headsign();
  PROTOBUF_NODISCARD std::string* release_trip_headsign();
  void set_allocated_trip_headsign(std::string* trip_headsign);
  private:
  const std::string& _internal_trip_headsign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_headsign(const std::string& value);
  std::string* _internal_mutable_trip_headsign();
  public:

  // string trip_short_name = 5;
  void clear_trip_short_name();
  const std::string& trip_short_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trip_short_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trip_short_name();
  PROTOBUF_NODISCARD std::string* release_trip_short_name();
  void set_allocated_trip_short_name(std::string* trip_short_name);
  private:
  const std::string& _internal_trip_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_short_name(const std::string& value);
  std::string* _internal_mutable_trip_short_name();
  public:

  // string block_id = 7;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_NODISCARD std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // string shape_id = 8;
  void clear_shape_id();
  const std::string& shape_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape_id();
  PROTOBUF_NODISCARD std::string* release_shape_id();
  void set_allocated_shape_id(std::string* shape_id);
  private:
  const std::string& _internal_shape_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape_id(const std::string& value);
  std::string* _internal_mutable_shape_id();
  public:

  // .transit_scheduled.Trip.Direction direction_id = 6;
  void clear_direction_id();
  ::transit_scheduled::Trip_Direction direction_id() const;
  void set_direction_id(::transit_scheduled::Trip_Direction value);
  private:
  ::transit_scheduled::Trip_Direction _internal_direction_id() const;
  void _internal_set_direction_id(::transit_scheduled::Trip_Direction value);
  public:

  // .transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;
  void clear_wheelchair_accessible();
  ::transit_scheduled::Trip_WheelchairAccessibility wheelchair_accessible() const;
  void set_wheelchair_accessible(::transit_scheduled::Trip_WheelchairAccessibility value);
  private:
  ::transit_scheduled::Trip_WheelchairAccessibility _internal_wheelchair_accessible() const;
  void _internal_set_wheelchair_accessible(::transit_scheduled::Trip_WheelchairAccessibility value);
  public:

  // .transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;
  void clear_bikes_allowed();
  ::transit_scheduled::Trip_BikeAllowance bikes_allowed() const;
  void set_bikes_allowed(::transit_scheduled::Trip_BikeAllowance value);
  private:
  ::transit_scheduled::Trip_BikeAllowance _internal_bikes_allowed() const;
  void _internal_set_bikes_allowed(::transit_scheduled::Trip_BikeAllowance value);
  public:

  // @@protoc_insertion_point(class_scope:transit_scheduled.Trip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trip_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trip_headsign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trip_short_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_id_;
  int direction_id_;
  int wheelchair_accessible_;
  int bikes_allowed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fv1_2fgtfs_2dschedule_2eproto;
};
// -------------------------------------------------------------------

class StopTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_scheduled.StopTime) */ {
 public:
  inline StopTime() : StopTime(nullptr) {}
  ~StopTime() override;
  explicit PROTOBUF_CONSTEXPR StopTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopTime(const StopTime& from);
  StopTime(StopTime&& from) noexcept
    : StopTime() {
    *this = ::std::move(from);
  }

  inline StopTime& operator=(const StopTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopTime& operator=(StopTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopTime* internal_default_instance() {
    return reinterpret_cast<const StopTime*>(
               &_StopTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StopTime& a, StopTime& b) {
    a.Swap(&b);
  }
  inline void Swap(StopTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopTime& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_scheduled.StopTime";
  }
  protected:
  explicit StopTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StopTime_PickupType PickupType;
  static constexpr PickupType PICKUP_TYPE_REGULARLY_SCHEDULED =
    StopTime_PickupType_PICKUP_TYPE_REGULARLY_SCHEDULED;
  static constexpr PickupType PICKUP_TYPE_NONE_AVAILABLE =
    StopTime_PickupType_PICKUP_TYPE_NONE_AVAILABLE;
  static constexpr PickupType PICKUP_TYPE_MUST_PHONE_AGENCY =
    StopTime_PickupType_PICKUP_TYPE_MUST_PHONE_AGENCY;
  static constexpr PickupType PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER =
    StopTime_PickupType_PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER;
  static inline bool PickupType_IsValid(int value) {
    return StopTime_PickupType_IsValid(value);
  }
  static constexpr PickupType PickupType_MIN =
    StopTime_PickupType_PickupType_MIN;
  static constexpr PickupType PickupType_MAX =
    StopTime_PickupType_PickupType_MAX;
  static constexpr int PickupType_ARRAYSIZE =
    StopTime_PickupType_PickupType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PickupType_descriptor() {
    return StopTime_PickupType_descriptor();
  }
  template<typename T>
  static inline const std::string& PickupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PickupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PickupType_Name.");
    return StopTime_PickupType_Name(enum_t_value);
  }
  static inline bool PickupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PickupType* value) {
    return StopTime_PickupType_Parse(name, value);
  }

  typedef StopTime_DropOffType DropOffType;
  static constexpr DropOffType DROP_OFF_TYPE_REGULARLY_SCHEDULED =
    StopTime_DropOffType_DROP_OFF_TYPE_REGULARLY_SCHEDULED;
  static constexpr DropOffType DROP_OFF_TYPE_NONE_AVAILABLE =
    StopTime_DropOffType_DROP_OFF_TYPE_NONE_AVAILABLE;
  static constexpr DropOffType DROP_OFF_TYPE_MUST_PHONE_AGENCY =
    StopTime_DropOffType_DROP_OFF_TYPE_MUST_PHONE_AGENCY;
  static constexpr DropOffType DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER =
    StopTime_DropOffType_DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER;
  static inline bool DropOffType_IsValid(int value) {
    return StopTime_DropOffType_IsValid(value);
  }
  static constexpr DropOffType DropOffType_MIN =
    StopTime_DropOffType_DropOffType_MIN;
  static constexpr DropOffType DropOffType_MAX =
    StopTime_DropOffType_DropOffType_MAX;
  static constexpr int DropOffType_ARRAYSIZE =
    StopTime_DropOffType_DropOffType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DropOffType_descriptor() {
    return StopTime_DropOffType_descriptor();
  }
  template<typename T>
  static inline const std::string& DropOffType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DropOffType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DropOffType_Name.");
    return StopTime_DropOffType_Name(enum_t_value);
  }
  static inline bool DropOffType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DropOffType* value) {
    return StopTime_DropOffType_Parse(name, value);
  }

  typedef StopTime_TimePoint TimePoint;
  static constexpr TimePoint TIME_POINT_APPROXIMATE =
    StopTime_TimePoint_TIME_POINT_APPROXIMATE;
  static constexpr TimePoint TIME_POINT_EXACT =
    StopTime_TimePoint_TIME_POINT_EXACT;
  static inline bool TimePoint_IsValid(int value) {
    return StopTime_TimePoint_IsValid(value);
  }
  static constexpr TimePoint TimePoint_MIN =
    StopTime_TimePoint_TimePoint_MIN;
  static constexpr TimePoint TimePoint_MAX =
    StopTime_TimePoint_TimePoint_MAX;
  static constexpr int TimePoint_ARRAYSIZE =
    StopTime_TimePoint_TimePoint_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TimePoint_descriptor() {
    return StopTime_TimePoint_descriptor();
  }
  template<typename T>
  static inline const std::string& TimePoint_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TimePoint>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TimePoint_Name.");
    return StopTime_TimePoint_Name(enum_t_value);
  }
  static inline bool TimePoint_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TimePoint* value) {
    return StopTime_TimePoint_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTripIdFieldNumber = 1,
    kArrivalTimeFieldNumber = 2,
    kDepartureTimeFieldNumber = 3,
    kStopIdFieldNumber = 4,
    kStopHeadsignFieldNumber = 6,
    kStopSequenceFieldNumber = 5,
    kPickupTypeFieldNumber = 7,
    kDropOffTypeFieldNumber = 8,
    kContinuousPickupFieldNumber = 9,
    kContinuousDropOffFieldNumber = 10,
    kShapeDistTraveledFieldNumber = 11,
    kTimepointFieldNumber = 12,
  };
  // string trip_id = 1;
  void clear_trip_id();
  const std::string& trip_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trip_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trip_id();
  PROTOBUF_NODISCARD std::string* release_trip_id();
  void set_allocated_trip_id(std::string* trip_id);
  private:
  const std::string& _internal_trip_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_id(const std::string& value);
  std::string* _internal_mutable_trip_id();
  public:

  // string arrival_time = 2;
  void clear_arrival_time();
  const std::string& arrival_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arrival_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arrival_time();
  PROTOBUF_NODISCARD std::string* release_arrival_time();
  void set_allocated_arrival_time(std::string* arrival_time);
  private:
  const std::string& _internal_arrival_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arrival_time(const std::string& value);
  std::string* _internal_mutable_arrival_time();
  public:

  // string departure_time = 3;
  void clear_departure_time();
  const std::string& departure_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_departure_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_departure_time();
  PROTOBUF_NODISCARD std::string* release_departure_time();
  void set_allocated_departure_time(std::string* departure_time);
  private:
  const std::string& _internal_departure_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_departure_time(const std::string& value);
  std::string* _internal_mutable_departure_time();
  public:

  // string stop_id = 4;
  void clear_stop_id();
  const std::string& stop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* stop_id);
  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(const std::string& value);
  std::string* _internal_mutable_stop_id();
  public:

  // string stop_headsign = 6;
  void clear_stop_headsign();
  const std::string& stop_headsign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_headsign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_headsign();
  PROTOBUF_NODISCARD std::string* release_stop_headsign();
  void set_allocated_stop_headsign(std::string* stop_headsign);
  private:
  const std::string& _internal_stop_headsign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_headsign(const std::string& value);
  std::string* _internal_mutable_stop_headsign();
  public:

  // uint32 stop_sequence = 5;
  void clear_stop_sequence();
  uint32_t stop_sequence() const;
  void set_stop_sequence(uint32_t value);
  private:
  uint32_t _internal_stop_sequence() const;
  void _internal_set_stop_sequence(uint32_t value);
  public:

  // .transit_scheduled.StopTime.PickupType pickup_type = 7;
  void clear_pickup_type();
  ::transit_scheduled::StopTime_PickupType pickup_type() const;
  void set_pickup_type(::transit_scheduled::StopTime_PickupType value);
  private:
  ::transit_scheduled::StopTime_PickupType _internal_pickup_type() const;
  void _internal_set_pickup_type(::transit_scheduled::StopTime_PickupType value);
  public:

  // .transit_scheduled.StopTime.DropOffType drop_off_type = 8;
  void clear_drop_off_type();
  ::transit_scheduled::StopTime_DropOffType drop_off_type() const;
  void set_drop_off_type(::transit_scheduled::StopTime_DropOffType value);
  private:
  ::transit_scheduled::StopTime_DropOffType _internal_drop_off_type() const;
  void _internal_set_drop_off_type(::transit_scheduled::StopTime_DropOffType value);
  public:

  // .transit_scheduled.ContinuousPickup continuous_pickup = 9;
  void clear_continuous_pickup();
  ::transit_scheduled::ContinuousPickup continuous_pickup() const;
  void set_continuous_pickup(::transit_scheduled::ContinuousPickup value);
  private:
  ::transit_scheduled::ContinuousPickup _internal_continuous_pickup() const;
  void _internal_set_continuous_pickup(::transit_scheduled::ContinuousPickup value);
  public:

  // .transit_scheduled.ContinuousDropOff continuous_drop_off = 10;
  void clear_continuous_drop_off();
  ::transit_scheduled::ContinuousDropOff continuous_drop_off() const;
  void set_continuous_drop_off(::transit_scheduled::ContinuousDropOff value);
  private:
  ::transit_scheduled::ContinuousDropOff _internal_continuous_drop_off() const;
  void _internal_set_continuous_drop_off(::transit_scheduled::ContinuousDropOff value);
  public:

  // float shape_dist_traveled = 11;
  void clear_shape_dist_traveled();
  float shape_dist_traveled() const;
  void set_shape_dist_traveled(float value);
  private:
  float _internal_shape_dist_traveled() const;
  void _internal_set_shape_dist_traveled(float value);
  public:

  // uint32 timepoint = 12;
  void clear_timepoint();
  uint32_t timepoint() const;
  void set_timepoint(uint32_t value);
  private:
  uint32_t _internal_timepoint() const;
  void _internal_set_timepoint(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:transit_scheduled.StopTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trip_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arrival_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr departure_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_headsign_;
  uint32_t stop_sequence_;
  int pickup_type_;
  int drop_off_type_;
  int continuous_pickup_;
  int continuous_drop_off_;
  float shape_dist_traveled_;
  uint32_t timepoint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fv1_2fgtfs_2dschedule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Agency

// string agency_id = 1;
inline void Agency::clear_agency_id() {
  agency_id_.ClearToEmpty();
}
inline const std::string& Agency::agency_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Agency.agency_id)
  return _internal_agency_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Agency::set_agency_id(ArgT0&& arg0, ArgT... args) {
 
 agency_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Agency.agency_id)
}
inline std::string* Agency::mutable_agency_id() {
  std::string* _s = _internal_mutable_agency_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Agency.agency_id)
  return _s;
}
inline const std::string& Agency::_internal_agency_id() const {
  return agency_id_.Get();
}
inline void Agency::_internal_set_agency_id(const std::string& value) {
  
  agency_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Agency::_internal_mutable_agency_id() {
  
  return agency_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Agency::release_agency_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Agency.agency_id)
  return agency_id_.Release();
}
inline void Agency::set_allocated_agency_id(std::string* agency_id) {
  if (agency_id != nullptr) {
    
  } else {
    
  }
  agency_id_.SetAllocated(agency_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agency_id_.IsDefault()) {
    agency_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Agency.agency_id)
}

// string agency_name = 2;
inline void Agency::clear_agency_name() {
  agency_name_.ClearToEmpty();
}
inline const std::string& Agency::agency_name() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Agency.agency_name)
  return _internal_agency_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Agency::set_agency_name(ArgT0&& arg0, ArgT... args) {
 
 agency_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Agency.agency_name)
}
inline std::string* Agency::mutable_agency_name() {
  std::string* _s = _internal_mutable_agency_name();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Agency.agency_name)
  return _s;
}
inline const std::string& Agency::_internal_agency_name() const {
  return agency_name_.Get();
}
inline void Agency::_internal_set_agency_name(const std::string& value) {
  
  agency_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Agency::_internal_mutable_agency_name() {
  
  return agency_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Agency::release_agency_name() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Agency.agency_name)
  return agency_name_.Release();
}
inline void Agency::set_allocated_agency_name(std::string* agency_name) {
  if (agency_name != nullptr) {
    
  } else {
    
  }
  agency_name_.SetAllocated(agency_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agency_name_.IsDefault()) {
    agency_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Agency.agency_name)
}

// string agency_url = 3;
inline void Agency::clear_agency_url() {
  agency_url_.ClearToEmpty();
}
inline const std::string& Agency::agency_url() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Agency.agency_url)
  return _internal_agency_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Agency::set_agency_url(ArgT0&& arg0, ArgT... args) {
 
 agency_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Agency.agency_url)
}
inline std::string* Agency::mutable_agency_url() {
  std::string* _s = _internal_mutable_agency_url();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Agency.agency_url)
  return _s;
}
inline const std::string& Agency::_internal_agency_url() const {
  return agency_url_.Get();
}
inline void Agency::_internal_set_agency_url(const std::string& value) {
  
  agency_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Agency::_internal_mutable_agency_url() {
  
  return agency_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Agency::release_agency_url() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Agency.agency_url)
  return agency_url_.Release();
}
inline void Agency::set_allocated_agency_url(std::string* agency_url) {
  if (agency_url != nullptr) {
    
  } else {
    
  }
  agency_url_.SetAllocated(agency_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agency_url_.IsDefault()) {
    agency_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Agency.agency_url)
}

// string agency_timezone = 4;
inline void Agency::clear_agency_timezone() {
  agency_timezone_.ClearToEmpty();
}
inline const std::string& Agency::agency_timezone() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Agency.agency_timezone)
  return _internal_agency_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Agency::set_agency_timezone(ArgT0&& arg0, ArgT... args) {
 
 agency_timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Agency.agency_timezone)
}
inline std::string* Agency::mutable_agency_timezone() {
  std::string* _s = _internal_mutable_agency_timezone();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Agency.agency_timezone)
  return _s;
}
inline const std::string& Agency::_internal_agency_timezone() const {
  return agency_timezone_.Get();
}
inline void Agency::_internal_set_agency_timezone(const std::string& value) {
  
  agency_timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* Agency::_internal_mutable_agency_timezone() {
  
  return agency_timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* Agency::release_agency_timezone() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Agency.agency_timezone)
  return agency_timezone_.Release();
}
inline void Agency::set_allocated_agency_timezone(std::string* agency_timezone) {
  if (agency_timezone != nullptr) {
    
  } else {
    
  }
  agency_timezone_.SetAllocated(agency_timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agency_timezone_.IsDefault()) {
    agency_timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Agency.agency_timezone)
}

// string agency_lang = 5;
inline void Agency::clear_agency_lang() {
  agency_lang_.ClearToEmpty();
}
inline const std::string& Agency::agency_lang() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Agency.agency_lang)
  return _internal_agency_lang();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Agency::set_agency_lang(ArgT0&& arg0, ArgT... args) {
 
 agency_lang_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Agency.agency_lang)
}
inline std::string* Agency::mutable_agency_lang() {
  std::string* _s = _internal_mutable_agency_lang();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Agency.agency_lang)
  return _s;
}
inline const std::string& Agency::_internal_agency_lang() const {
  return agency_lang_.Get();
}
inline void Agency::_internal_set_agency_lang(const std::string& value) {
  
  agency_lang_.Set(value, GetArenaForAllocation());
}
inline std::string* Agency::_internal_mutable_agency_lang() {
  
  return agency_lang_.Mutable(GetArenaForAllocation());
}
inline std::string* Agency::release_agency_lang() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Agency.agency_lang)
  return agency_lang_.Release();
}
inline void Agency::set_allocated_agency_lang(std::string* agency_lang) {
  if (agency_lang != nullptr) {
    
  } else {
    
  }
  agency_lang_.SetAllocated(agency_lang, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agency_lang_.IsDefault()) {
    agency_lang_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Agency.agency_lang)
}

// string agency_phone = 6;
inline void Agency::clear_agency_phone() {
  agency_phone_.ClearToEmpty();
}
inline const std::string& Agency::agency_phone() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Agency.agency_phone)
  return _internal_agency_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Agency::set_agency_phone(ArgT0&& arg0, ArgT... args) {
 
 agency_phone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Agency.agency_phone)
}
inline std::string* Agency::mutable_agency_phone() {
  std::string* _s = _internal_mutable_agency_phone();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Agency.agency_phone)
  return _s;
}
inline const std::string& Agency::_internal_agency_phone() const {
  return agency_phone_.Get();
}
inline void Agency::_internal_set_agency_phone(const std::string& value) {
  
  agency_phone_.Set(value, GetArenaForAllocation());
}
inline std::string* Agency::_internal_mutable_agency_phone() {
  
  return agency_phone_.Mutable(GetArenaForAllocation());
}
inline std::string* Agency::release_agency_phone() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Agency.agency_phone)
  return agency_phone_.Release();
}
inline void Agency::set_allocated_agency_phone(std::string* agency_phone) {
  if (agency_phone != nullptr) {
    
  } else {
    
  }
  agency_phone_.SetAllocated(agency_phone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agency_phone_.IsDefault()) {
    agency_phone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Agency.agency_phone)
}

// string agency_fare_url = 7;
inline void Agency::clear_agency_fare_url() {
  agency_fare_url_.ClearToEmpty();
}
inline const std::string& Agency::agency_fare_url() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Agency.agency_fare_url)
  return _internal_agency_fare_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Agency::set_agency_fare_url(ArgT0&& arg0, ArgT... args) {
 
 agency_fare_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Agency.agency_fare_url)
}
inline std::string* Agency::mutable_agency_fare_url() {
  std::string* _s = _internal_mutable_agency_fare_url();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Agency.agency_fare_url)
  return _s;
}
inline const std::string& Agency::_internal_agency_fare_url() const {
  return agency_fare_url_.Get();
}
inline void Agency::_internal_set_agency_fare_url(const std::string& value) {
  
  agency_fare_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Agency::_internal_mutable_agency_fare_url() {
  
  return agency_fare_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Agency::release_agency_fare_url() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Agency.agency_fare_url)
  return agency_fare_url_.Release();
}
inline void Agency::set_allocated_agency_fare_url(std::string* agency_fare_url) {
  if (agency_fare_url != nullptr) {
    
  } else {
    
  }
  agency_fare_url_.SetAllocated(agency_fare_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agency_fare_url_.IsDefault()) {
    agency_fare_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Agency.agency_fare_url)
}

// string agency_email = 8;
inline void Agency::clear_agency_email() {
  agency_email_.ClearToEmpty();
}
inline const std::string& Agency::agency_email() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Agency.agency_email)
  return _internal_agency_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Agency::set_agency_email(ArgT0&& arg0, ArgT... args) {
 
 agency_email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Agency.agency_email)
}
inline std::string* Agency::mutable_agency_email() {
  std::string* _s = _internal_mutable_agency_email();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Agency.agency_email)
  return _s;
}
inline const std::string& Agency::_internal_agency_email() const {
  return agency_email_.Get();
}
inline void Agency::_internal_set_agency_email(const std::string& value) {
  
  agency_email_.Set(value, GetArenaForAllocation());
}
inline std::string* Agency::_internal_mutable_agency_email() {
  
  return agency_email_.Mutable(GetArenaForAllocation());
}
inline std::string* Agency::release_agency_email() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Agency.agency_email)
  return agency_email_.Release();
}
inline void Agency::set_allocated_agency_email(std::string* agency_email) {
  if (agency_email != nullptr) {
    
  } else {
    
  }
  agency_email_.SetAllocated(agency_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agency_email_.IsDefault()) {
    agency_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Agency.agency_email)
}

// -------------------------------------------------------------------

// Stop

// string stop_id = 1;
inline void Stop::clear_stop_id() {
  stop_id_.ClearToEmpty();
}
inline const std::string& Stop::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.stop_id)
  return _internal_stop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_stop_id(ArgT0&& arg0, ArgT... args) {
 
 stop_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.stop_id)
}
inline std::string* Stop::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.stop_id)
  return _s;
}
inline const std::string& Stop::_internal_stop_id() const {
  return stop_id_.Get();
}
inline void Stop::_internal_set_stop_id(const std::string& value) {
  
  stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_stop_id() {
  
  return stop_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.stop_id)
  return stop_id_.Release();
}
inline void Stop::set_allocated_stop_id(std::string* stop_id) {
  if (stop_id != nullptr) {
    
  } else {
    
  }
  stop_id_.SetAllocated(stop_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stop_id_.IsDefault()) {
    stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.stop_id)
}

// string stop_code = 2;
inline void Stop::clear_stop_code() {
  stop_code_.ClearToEmpty();
}
inline const std::string& Stop::stop_code() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.stop_code)
  return _internal_stop_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_stop_code(ArgT0&& arg0, ArgT... args) {
 
 stop_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.stop_code)
}
inline std::string* Stop::mutable_stop_code() {
  std::string* _s = _internal_mutable_stop_code();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.stop_code)
  return _s;
}
inline const std::string& Stop::_internal_stop_code() const {
  return stop_code_.Get();
}
inline void Stop::_internal_set_stop_code(const std::string& value) {
  
  stop_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_stop_code() {
  
  return stop_code_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_stop_code() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.stop_code)
  return stop_code_.Release();
}
inline void Stop::set_allocated_stop_code(std::string* stop_code) {
  if (stop_code != nullptr) {
    
  } else {
    
  }
  stop_code_.SetAllocated(stop_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stop_code_.IsDefault()) {
    stop_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.stop_code)
}

// string stop_name = 3;
inline void Stop::clear_stop_name() {
  stop_name_.ClearToEmpty();
}
inline const std::string& Stop::stop_name() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.stop_name)
  return _internal_stop_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_stop_name(ArgT0&& arg0, ArgT... args) {
 
 stop_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.stop_name)
}
inline std::string* Stop::mutable_stop_name() {
  std::string* _s = _internal_mutable_stop_name();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.stop_name)
  return _s;
}
inline const std::string& Stop::_internal_stop_name() const {
  return stop_name_.Get();
}
inline void Stop::_internal_set_stop_name(const std::string& value) {
  
  stop_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_stop_name() {
  
  return stop_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_stop_name() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.stop_name)
  return stop_name_.Release();
}
inline void Stop::set_allocated_stop_name(std::string* stop_name) {
  if (stop_name != nullptr) {
    
  } else {
    
  }
  stop_name_.SetAllocated(stop_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stop_name_.IsDefault()) {
    stop_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.stop_name)
}

// string tts_stop_name = 4;
inline void Stop::clear_tts_stop_name() {
  tts_stop_name_.ClearToEmpty();
}
inline const std::string& Stop::tts_stop_name() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.tts_stop_name)
  return _internal_tts_stop_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_tts_stop_name(ArgT0&& arg0, ArgT... args) {
 
 tts_stop_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.tts_stop_name)
}
inline std::string* Stop::mutable_tts_stop_name() {
  std::string* _s = _internal_mutable_tts_stop_name();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.tts_stop_name)
  return _s;
}
inline const std::string& Stop::_internal_tts_stop_name() const {
  return tts_stop_name_.Get();
}
inline void Stop::_internal_set_tts_stop_name(const std::string& value) {
  
  tts_stop_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_tts_stop_name() {
  
  return tts_stop_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_tts_stop_name() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.tts_stop_name)
  return tts_stop_name_.Release();
}
inline void Stop::set_allocated_tts_stop_name(std::string* tts_stop_name) {
  if (tts_stop_name != nullptr) {
    
  } else {
    
  }
  tts_stop_name_.SetAllocated(tts_stop_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tts_stop_name_.IsDefault()) {
    tts_stop_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.tts_stop_name)
}

// string stop_desc = 5;
inline void Stop::clear_stop_desc() {
  stop_desc_.ClearToEmpty();
}
inline const std::string& Stop::stop_desc() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.stop_desc)
  return _internal_stop_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_stop_desc(ArgT0&& arg0, ArgT... args) {
 
 stop_desc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.stop_desc)
}
inline std::string* Stop::mutable_stop_desc() {
  std::string* _s = _internal_mutable_stop_desc();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.stop_desc)
  return _s;
}
inline const std::string& Stop::_internal_stop_desc() const {
  return stop_desc_.Get();
}
inline void Stop::_internal_set_stop_desc(const std::string& value) {
  
  stop_desc_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_stop_desc() {
  
  return stop_desc_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_stop_desc() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.stop_desc)
  return stop_desc_.Release();
}
inline void Stop::set_allocated_stop_desc(std::string* stop_desc) {
  if (stop_desc != nullptr) {
    
  } else {
    
  }
  stop_desc_.SetAllocated(stop_desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stop_desc_.IsDefault()) {
    stop_desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.stop_desc)
}

// double stop_lat = 6;
inline void Stop::clear_stop_lat() {
  stop_lat_ = 0;
}
inline double Stop::_internal_stop_lat() const {
  return stop_lat_;
}
inline double Stop::stop_lat() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.stop_lat)
  return _internal_stop_lat();
}
inline void Stop::_internal_set_stop_lat(double value) {
  
  stop_lat_ = value;
}
inline void Stop::set_stop_lat(double value) {
  _internal_set_stop_lat(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.stop_lat)
}

// double stop_lon = 7;
inline void Stop::clear_stop_lon() {
  stop_lon_ = 0;
}
inline double Stop::_internal_stop_lon() const {
  return stop_lon_;
}
inline double Stop::stop_lon() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.stop_lon)
  return _internal_stop_lon();
}
inline void Stop::_internal_set_stop_lon(double value) {
  
  stop_lon_ = value;
}
inline void Stop::set_stop_lon(double value) {
  _internal_set_stop_lon(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.stop_lon)
}

// string zone_id = 8;
inline void Stop::clear_zone_id() {
  zone_id_.ClearToEmpty();
}
inline const std::string& Stop::zone_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.zone_id)
  return _internal_zone_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_zone_id(ArgT0&& arg0, ArgT... args) {
 
 zone_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.zone_id)
}
inline std::string* Stop::mutable_zone_id() {
  std::string* _s = _internal_mutable_zone_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.zone_id)
  return _s;
}
inline const std::string& Stop::_internal_zone_id() const {
  return zone_id_.Get();
}
inline void Stop::_internal_set_zone_id(const std::string& value) {
  
  zone_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_zone_id() {
  
  return zone_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_zone_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.zone_id)
  return zone_id_.Release();
}
inline void Stop::set_allocated_zone_id(std::string* zone_id) {
  if (zone_id != nullptr) {
    
  } else {
    
  }
  zone_id_.SetAllocated(zone_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (zone_id_.IsDefault()) {
    zone_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.zone_id)
}

// string stop_url = 9;
inline void Stop::clear_stop_url() {
  stop_url_.ClearToEmpty();
}
inline const std::string& Stop::stop_url() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.stop_url)
  return _internal_stop_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_stop_url(ArgT0&& arg0, ArgT... args) {
 
 stop_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.stop_url)
}
inline std::string* Stop::mutable_stop_url() {
  std::string* _s = _internal_mutable_stop_url();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.stop_url)
  return _s;
}
inline const std::string& Stop::_internal_stop_url() const {
  return stop_url_.Get();
}
inline void Stop::_internal_set_stop_url(const std::string& value) {
  
  stop_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_stop_url() {
  
  return stop_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_stop_url() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.stop_url)
  return stop_url_.Release();
}
inline void Stop::set_allocated_stop_url(std::string* stop_url) {
  if (stop_url != nullptr) {
    
  } else {
    
  }
  stop_url_.SetAllocated(stop_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stop_url_.IsDefault()) {
    stop_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.stop_url)
}

// .transit_scheduled.Stop.LocationType location_type = 10;
inline void Stop::clear_location_type() {
  location_type_ = 0;
}
inline ::transit_scheduled::Stop_LocationType Stop::_internal_location_type() const {
  return static_cast< ::transit_scheduled::Stop_LocationType >(location_type_);
}
inline ::transit_scheduled::Stop_LocationType Stop::location_type() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.location_type)
  return _internal_location_type();
}
inline void Stop::_internal_set_location_type(::transit_scheduled::Stop_LocationType value) {
  
  location_type_ = value;
}
inline void Stop::set_location_type(::transit_scheduled::Stop_LocationType value) {
  _internal_set_location_type(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.location_type)
}

// string parent_station = 11;
inline void Stop::clear_parent_station() {
  parent_station_.ClearToEmpty();
}
inline const std::string& Stop::parent_station() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.parent_station)
  return _internal_parent_station();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_parent_station(ArgT0&& arg0, ArgT... args) {
 
 parent_station_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.parent_station)
}
inline std::string* Stop::mutable_parent_station() {
  std::string* _s = _internal_mutable_parent_station();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.parent_station)
  return _s;
}
inline const std::string& Stop::_internal_parent_station() const {
  return parent_station_.Get();
}
inline void Stop::_internal_set_parent_station(const std::string& value) {
  
  parent_station_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_parent_station() {
  
  return parent_station_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_parent_station() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.parent_station)
  return parent_station_.Release();
}
inline void Stop::set_allocated_parent_station(std::string* parent_station) {
  if (parent_station != nullptr) {
    
  } else {
    
  }
  parent_station_.SetAllocated(parent_station, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_station_.IsDefault()) {
    parent_station_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.parent_station)
}

// string stop_timezone = 12;
inline void Stop::clear_stop_timezone() {
  stop_timezone_.ClearToEmpty();
}
inline const std::string& Stop::stop_timezone() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.stop_timezone)
  return _internal_stop_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_stop_timezone(ArgT0&& arg0, ArgT... args) {
 
 stop_timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.stop_timezone)
}
inline std::string* Stop::mutable_stop_timezone() {
  std::string* _s = _internal_mutable_stop_timezone();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.stop_timezone)
  return _s;
}
inline const std::string& Stop::_internal_stop_timezone() const {
  return stop_timezone_.Get();
}
inline void Stop::_internal_set_stop_timezone(const std::string& value) {
  
  stop_timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_stop_timezone() {
  
  return stop_timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_stop_timezone() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.stop_timezone)
  return stop_timezone_.Release();
}
inline void Stop::set_allocated_stop_timezone(std::string* stop_timezone) {
  if (stop_timezone != nullptr) {
    
  } else {
    
  }
  stop_timezone_.SetAllocated(stop_timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stop_timezone_.IsDefault()) {
    stop_timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.stop_timezone)
}

// .transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;
inline void Stop::clear_wheelchair_boarding() {
  wheelchair_boarding_ = 0;
}
inline ::transit_scheduled::Stop_WheelchairBoarding Stop::_internal_wheelchair_boarding() const {
  return static_cast< ::transit_scheduled::Stop_WheelchairBoarding >(wheelchair_boarding_);
}
inline ::transit_scheduled::Stop_WheelchairBoarding Stop::wheelchair_boarding() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.wheelchair_boarding)
  return _internal_wheelchair_boarding();
}
inline void Stop::_internal_set_wheelchair_boarding(::transit_scheduled::Stop_WheelchairBoarding value) {
  
  wheelchair_boarding_ = value;
}
inline void Stop::set_wheelchair_boarding(::transit_scheduled::Stop_WheelchairBoarding value) {
  _internal_set_wheelchair_boarding(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.wheelchair_boarding)
}

// string level_id = 14;
inline void Stop::clear_level_id() {
  level_id_.ClearToEmpty();
}
inline const std::string& Stop::level_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.level_id)
  return _internal_level_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_level_id(ArgT0&& arg0, ArgT... args) {
 
 level_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.level_id)
}
inline std::string* Stop::mutable_level_id() {
  std::string* _s = _internal_mutable_level_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.level_id)
  return _s;
}
inline const std::string& Stop::_internal_level_id() const {
  return level_id_.Get();
}
inline void Stop::_internal_set_level_id(const std::string& value) {
  
  level_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_level_id() {
  
  return level_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_level_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.level_id)
  return level_id_.Release();
}
inline void Stop::set_allocated_level_id(std::string* level_id) {
  if (level_id != nullptr) {
    
  } else {
    
  }
  level_id_.SetAllocated(level_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (level_id_.IsDefault()) {
    level_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.level_id)
}

// string platform_code = 15;
inline void Stop::clear_platform_code() {
  platform_code_.ClearToEmpty();
}
inline const std::string& Stop::platform_code() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Stop.platform_code)
  return _internal_platform_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stop::set_platform_code(ArgT0&& arg0, ArgT... args) {
 
 platform_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Stop.platform_code)
}
inline std::string* Stop::mutable_platform_code() {
  std::string* _s = _internal_mutable_platform_code();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Stop.platform_code)
  return _s;
}
inline const std::string& Stop::_internal_platform_code() const {
  return platform_code_.Get();
}
inline void Stop::_internal_set_platform_code(const std::string& value) {
  
  platform_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Stop::_internal_mutable_platform_code() {
  
  return platform_code_.Mutable(GetArenaForAllocation());
}
inline std::string* Stop::release_platform_code() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Stop.platform_code)
  return platform_code_.Release();
}
inline void Stop::set_allocated_platform_code(std::string* platform_code) {
  if (platform_code != nullptr) {
    
  } else {
    
  }
  platform_code_.SetAllocated(platform_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_code_.IsDefault()) {
    platform_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Stop.platform_code)
}

// -------------------------------------------------------------------

// Route

// string route_id = 1;
inline void Route::clear_route_id() {
  route_id_.ClearToEmpty();
}
inline const std::string& Route::route_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.route_id)
  return _internal_route_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_route_id(ArgT0&& arg0, ArgT... args) {
 
 route_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.route_id)
}
inline std::string* Route::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Route.route_id)
  return _s;
}
inline const std::string& Route::_internal_route_id() const {
  return route_id_.Get();
}
inline void Route::_internal_set_route_id(const std::string& value) {
  
  route_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_route_id() {
  
  return route_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Route::release_route_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Route.route_id)
  return route_id_.Release();
}
inline void Route::set_allocated_route_id(std::string* route_id) {
  if (route_id != nullptr) {
    
  } else {
    
  }
  route_id_.SetAllocated(route_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_id_.IsDefault()) {
    route_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Route.route_id)
}

// string agency_id = 2;
inline void Route::clear_agency_id() {
  agency_id_.ClearToEmpty();
}
inline const std::string& Route::agency_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.agency_id)
  return _internal_agency_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_agency_id(ArgT0&& arg0, ArgT... args) {
 
 agency_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.agency_id)
}
inline std::string* Route::mutable_agency_id() {
  std::string* _s = _internal_mutable_agency_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Route.agency_id)
  return _s;
}
inline const std::string& Route::_internal_agency_id() const {
  return agency_id_.Get();
}
inline void Route::_internal_set_agency_id(const std::string& value) {
  
  agency_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_agency_id() {
  
  return agency_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Route::release_agency_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Route.agency_id)
  return agency_id_.Release();
}
inline void Route::set_allocated_agency_id(std::string* agency_id) {
  if (agency_id != nullptr) {
    
  } else {
    
  }
  agency_id_.SetAllocated(agency_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agency_id_.IsDefault()) {
    agency_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Route.agency_id)
}

// string route_short_name = 3;
inline void Route::clear_route_short_name() {
  route_short_name_.ClearToEmpty();
}
inline const std::string& Route::route_short_name() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.route_short_name)
  return _internal_route_short_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_route_short_name(ArgT0&& arg0, ArgT... args) {
 
 route_short_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.route_short_name)
}
inline std::string* Route::mutable_route_short_name() {
  std::string* _s = _internal_mutable_route_short_name();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Route.route_short_name)
  return _s;
}
inline const std::string& Route::_internal_route_short_name() const {
  return route_short_name_.Get();
}
inline void Route::_internal_set_route_short_name(const std::string& value) {
  
  route_short_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_route_short_name() {
  
  return route_short_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Route::release_route_short_name() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Route.route_short_name)
  return route_short_name_.Release();
}
inline void Route::set_allocated_route_short_name(std::string* route_short_name) {
  if (route_short_name != nullptr) {
    
  } else {
    
  }
  route_short_name_.SetAllocated(route_short_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_short_name_.IsDefault()) {
    route_short_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Route.route_short_name)
}

// string route_long_name = 4;
inline void Route::clear_route_long_name() {
  route_long_name_.ClearToEmpty();
}
inline const std::string& Route::route_long_name() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.route_long_name)
  return _internal_route_long_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_route_long_name(ArgT0&& arg0, ArgT... args) {
 
 route_long_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.route_long_name)
}
inline std::string* Route::mutable_route_long_name() {
  std::string* _s = _internal_mutable_route_long_name();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Route.route_long_name)
  return _s;
}
inline const std::string& Route::_internal_route_long_name() const {
  return route_long_name_.Get();
}
inline void Route::_internal_set_route_long_name(const std::string& value) {
  
  route_long_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_route_long_name() {
  
  return route_long_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Route::release_route_long_name() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Route.route_long_name)
  return route_long_name_.Release();
}
inline void Route::set_allocated_route_long_name(std::string* route_long_name) {
  if (route_long_name != nullptr) {
    
  } else {
    
  }
  route_long_name_.SetAllocated(route_long_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_long_name_.IsDefault()) {
    route_long_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Route.route_long_name)
}

// string route_desc = 5;
inline void Route::clear_route_desc() {
  route_desc_.ClearToEmpty();
}
inline const std::string& Route::route_desc() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.route_desc)
  return _internal_route_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_route_desc(ArgT0&& arg0, ArgT... args) {
 
 route_desc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.route_desc)
}
inline std::string* Route::mutable_route_desc() {
  std::string* _s = _internal_mutable_route_desc();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Route.route_desc)
  return _s;
}
inline const std::string& Route::_internal_route_desc() const {
  return route_desc_.Get();
}
inline void Route::_internal_set_route_desc(const std::string& value) {
  
  route_desc_.Set(value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_route_desc() {
  
  return route_desc_.Mutable(GetArenaForAllocation());
}
inline std::string* Route::release_route_desc() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Route.route_desc)
  return route_desc_.Release();
}
inline void Route::set_allocated_route_desc(std::string* route_desc) {
  if (route_desc != nullptr) {
    
  } else {
    
  }
  route_desc_.SetAllocated(route_desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_desc_.IsDefault()) {
    route_desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Route.route_desc)
}

// .transit_scheduled.Route.RouteType route_type = 6;
inline void Route::clear_route_type() {
  route_type_ = 0;
}
inline ::transit_scheduled::Route_RouteType Route::_internal_route_type() const {
  return static_cast< ::transit_scheduled::Route_RouteType >(route_type_);
}
inline ::transit_scheduled::Route_RouteType Route::route_type() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.route_type)
  return _internal_route_type();
}
inline void Route::_internal_set_route_type(::transit_scheduled::Route_RouteType value) {
  
  route_type_ = value;
}
inline void Route::set_route_type(::transit_scheduled::Route_RouteType value) {
  _internal_set_route_type(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.route_type)
}

// string route_url = 7;
inline void Route::clear_route_url() {
  route_url_.ClearToEmpty();
}
inline const std::string& Route::route_url() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.route_url)
  return _internal_route_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_route_url(ArgT0&& arg0, ArgT... args) {
 
 route_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.route_url)
}
inline std::string* Route::mutable_route_url() {
  std::string* _s = _internal_mutable_route_url();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Route.route_url)
  return _s;
}
inline const std::string& Route::_internal_route_url() const {
  return route_url_.Get();
}
inline void Route::_internal_set_route_url(const std::string& value) {
  
  route_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_route_url() {
  
  return route_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Route::release_route_url() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Route.route_url)
  return route_url_.Release();
}
inline void Route::set_allocated_route_url(std::string* route_url) {
  if (route_url != nullptr) {
    
  } else {
    
  }
  route_url_.SetAllocated(route_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_url_.IsDefault()) {
    route_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Route.route_url)
}

// string route_color = 8;
inline void Route::clear_route_color() {
  route_color_.ClearToEmpty();
}
inline const std::string& Route::route_color() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.route_color)
  return _internal_route_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_route_color(ArgT0&& arg0, ArgT... args) {
 
 route_color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.route_color)
}
inline std::string* Route::mutable_route_color() {
  std::string* _s = _internal_mutable_route_color();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Route.route_color)
  return _s;
}
inline const std::string& Route::_internal_route_color() const {
  return route_color_.Get();
}
inline void Route::_internal_set_route_color(const std::string& value) {
  
  route_color_.Set(value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_route_color() {
  
  return route_color_.Mutable(GetArenaForAllocation());
}
inline std::string* Route::release_route_color() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Route.route_color)
  return route_color_.Release();
}
inline void Route::set_allocated_route_color(std::string* route_color) {
  if (route_color != nullptr) {
    
  } else {
    
  }
  route_color_.SetAllocated(route_color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_color_.IsDefault()) {
    route_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Route.route_color)
}

// string route_text_color = 9;
inline void Route::clear_route_text_color() {
  route_text_color_.ClearToEmpty();
}
inline const std::string& Route::route_text_color() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.route_text_color)
  return _internal_route_text_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_route_text_color(ArgT0&& arg0, ArgT... args) {
 
 route_text_color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.route_text_color)
}
inline std::string* Route::mutable_route_text_color() {
  std::string* _s = _internal_mutable_route_text_color();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Route.route_text_color)
  return _s;
}
inline const std::string& Route::_internal_route_text_color() const {
  return route_text_color_.Get();
}
inline void Route::_internal_set_route_text_color(const std::string& value) {
  
  route_text_color_.Set(value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_route_text_color() {
  
  return route_text_color_.Mutable(GetArenaForAllocation());
}
inline std::string* Route::release_route_text_color() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Route.route_text_color)
  return route_text_color_.Release();
}
inline void Route::set_allocated_route_text_color(std::string* route_text_color) {
  if (route_text_color != nullptr) {
    
  } else {
    
  }
  route_text_color_.SetAllocated(route_text_color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_text_color_.IsDefault()) {
    route_text_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Route.route_text_color)
}

// uint32 route_sort_order = 10;
inline void Route::clear_route_sort_order() {
  route_sort_order_ = 0u;
}
inline uint32_t Route::_internal_route_sort_order() const {
  return route_sort_order_;
}
inline uint32_t Route::route_sort_order() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.route_sort_order)
  return _internal_route_sort_order();
}
inline void Route::_internal_set_route_sort_order(uint32_t value) {
  
  route_sort_order_ = value;
}
inline void Route::set_route_sort_order(uint32_t value) {
  _internal_set_route_sort_order(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.route_sort_order)
}

// .transit_scheduled.ContinuousPickup continuous_pickup = 11;
inline void Route::clear_continuous_pickup() {
  continuous_pickup_ = 0;
}
inline ::transit_scheduled::ContinuousPickup Route::_internal_continuous_pickup() const {
  return static_cast< ::transit_scheduled::ContinuousPickup >(continuous_pickup_);
}
inline ::transit_scheduled::ContinuousPickup Route::continuous_pickup() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.continuous_pickup)
  return _internal_continuous_pickup();
}
inline void Route::_internal_set_continuous_pickup(::transit_scheduled::ContinuousPickup value) {
  
  continuous_pickup_ = value;
}
inline void Route::set_continuous_pickup(::transit_scheduled::ContinuousPickup value) {
  _internal_set_continuous_pickup(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.continuous_pickup)
}

// .transit_scheduled.ContinuousDropOff continuous_drop_off = 12;
inline void Route::clear_continuous_drop_off() {
  continuous_drop_off_ = 0;
}
inline ::transit_scheduled::ContinuousDropOff Route::_internal_continuous_drop_off() const {
  return static_cast< ::transit_scheduled::ContinuousDropOff >(continuous_drop_off_);
}
inline ::transit_scheduled::ContinuousDropOff Route::continuous_drop_off() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.continuous_drop_off)
  return _internal_continuous_drop_off();
}
inline void Route::_internal_set_continuous_drop_off(::transit_scheduled::ContinuousDropOff value) {
  
  continuous_drop_off_ = value;
}
inline void Route::set_continuous_drop_off(::transit_scheduled::ContinuousDropOff value) {
  _internal_set_continuous_drop_off(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.continuous_drop_off)
}

// string network_id = 13;
inline void Route::clear_network_id() {
  network_id_.ClearToEmpty();
}
inline const std::string& Route::network_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Route.network_id)
  return _internal_network_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_network_id(ArgT0&& arg0, ArgT... args) {
 
 network_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Route.network_id)
}
inline std::string* Route::mutable_network_id() {
  std::string* _s = _internal_mutable_network_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Route.network_id)
  return _s;
}
inline const std::string& Route::_internal_network_id() const {
  return network_id_.Get();
}
inline void Route::_internal_set_network_id(const std::string& value) {
  
  network_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_network_id() {
  
  return network_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Route::release_network_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Route.network_id)
  return network_id_.Release();
}
inline void Route::set_allocated_network_id(std::string* network_id) {
  if (network_id != nullptr) {
    
  } else {
    
  }
  network_id_.SetAllocated(network_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_id_.IsDefault()) {
    network_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Route.network_id)
}

// -------------------------------------------------------------------

// Trip

// string route_id = 1;
inline void Trip::clear_route_id() {
  route_id_.ClearToEmpty();
}
inline const std::string& Trip::route_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.route_id)
  return _internal_route_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trip::set_route_id(ArgT0&& arg0, ArgT... args) {
 
 route_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.route_id)
}
inline std::string* Trip::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Trip.route_id)
  return _s;
}
inline const std::string& Trip::_internal_route_id() const {
  return route_id_.Get();
}
inline void Trip::_internal_set_route_id(const std::string& value) {
  
  route_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Trip::_internal_mutable_route_id() {
  
  return route_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Trip::release_route_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Trip.route_id)
  return route_id_.Release();
}
inline void Trip::set_allocated_route_id(std::string* route_id) {
  if (route_id != nullptr) {
    
  } else {
    
  }
  route_id_.SetAllocated(route_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_id_.IsDefault()) {
    route_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Trip.route_id)
}

// string service_id = 2;
inline void Trip::clear_service_id() {
  service_id_.ClearToEmpty();
}
inline const std::string& Trip::service_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.service_id)
  return _internal_service_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trip::set_service_id(ArgT0&& arg0, ArgT... args) {
 
 service_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.service_id)
}
inline std::string* Trip::mutable_service_id() {
  std::string* _s = _internal_mutable_service_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Trip.service_id)
  return _s;
}
inline const std::string& Trip::_internal_service_id() const {
  return service_id_.Get();
}
inline void Trip::_internal_set_service_id(const std::string& value) {
  
  service_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Trip::_internal_mutable_service_id() {
  
  return service_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Trip::release_service_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Trip.service_id)
  return service_id_.Release();
}
inline void Trip::set_allocated_service_id(std::string* service_id) {
  if (service_id != nullptr) {
    
  } else {
    
  }
  service_id_.SetAllocated(service_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_id_.IsDefault()) {
    service_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Trip.service_id)
}

// string trip_id = 3;
inline void Trip::clear_trip_id() {
  trip_id_.ClearToEmpty();
}
inline const std::string& Trip::trip_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.trip_id)
  return _internal_trip_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trip::set_trip_id(ArgT0&& arg0, ArgT... args) {
 
 trip_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.trip_id)
}
inline std::string* Trip::mutable_trip_id() {
  std::string* _s = _internal_mutable_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Trip.trip_id)
  return _s;
}
inline const std::string& Trip::_internal_trip_id() const {
  return trip_id_.Get();
}
inline void Trip::_internal_set_trip_id(const std::string& value) {
  
  trip_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Trip::_internal_mutable_trip_id() {
  
  return trip_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Trip::release_trip_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Trip.trip_id)
  return trip_id_.Release();
}
inline void Trip::set_allocated_trip_id(std::string* trip_id) {
  if (trip_id != nullptr) {
    
  } else {
    
  }
  trip_id_.SetAllocated(trip_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trip_id_.IsDefault()) {
    trip_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Trip.trip_id)
}

// string trip_headsign = 4;
inline void Trip::clear_trip_headsign() {
  trip_headsign_.ClearToEmpty();
}
inline const std::string& Trip::trip_headsign() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.trip_headsign)
  return _internal_trip_headsign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trip::set_trip_headsign(ArgT0&& arg0, ArgT... args) {
 
 trip_headsign_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.trip_headsign)
}
inline std::string* Trip::mutable_trip_headsign() {
  std::string* _s = _internal_mutable_trip_headsign();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Trip.trip_headsign)
  return _s;
}
inline const std::string& Trip::_internal_trip_headsign() const {
  return trip_headsign_.Get();
}
inline void Trip::_internal_set_trip_headsign(const std::string& value) {
  
  trip_headsign_.Set(value, GetArenaForAllocation());
}
inline std::string* Trip::_internal_mutable_trip_headsign() {
  
  return trip_headsign_.Mutable(GetArenaForAllocation());
}
inline std::string* Trip::release_trip_headsign() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Trip.trip_headsign)
  return trip_headsign_.Release();
}
inline void Trip::set_allocated_trip_headsign(std::string* trip_headsign) {
  if (trip_headsign != nullptr) {
    
  } else {
    
  }
  trip_headsign_.SetAllocated(trip_headsign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trip_headsign_.IsDefault()) {
    trip_headsign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Trip.trip_headsign)
}

// string trip_short_name = 5;
inline void Trip::clear_trip_short_name() {
  trip_short_name_.ClearToEmpty();
}
inline const std::string& Trip::trip_short_name() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.trip_short_name)
  return _internal_trip_short_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trip::set_trip_short_name(ArgT0&& arg0, ArgT... args) {
 
 trip_short_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.trip_short_name)
}
inline std::string* Trip::mutable_trip_short_name() {
  std::string* _s = _internal_mutable_trip_short_name();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Trip.trip_short_name)
  return _s;
}
inline const std::string& Trip::_internal_trip_short_name() const {
  return trip_short_name_.Get();
}
inline void Trip::_internal_set_trip_short_name(const std::string& value) {
  
  trip_short_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Trip::_internal_mutable_trip_short_name() {
  
  return trip_short_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Trip::release_trip_short_name() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Trip.trip_short_name)
  return trip_short_name_.Release();
}
inline void Trip::set_allocated_trip_short_name(std::string* trip_short_name) {
  if (trip_short_name != nullptr) {
    
  } else {
    
  }
  trip_short_name_.SetAllocated(trip_short_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trip_short_name_.IsDefault()) {
    trip_short_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Trip.trip_short_name)
}

// .transit_scheduled.Trip.Direction direction_id = 6;
inline void Trip::clear_direction_id() {
  direction_id_ = 0;
}
inline ::transit_scheduled::Trip_Direction Trip::_internal_direction_id() const {
  return static_cast< ::transit_scheduled::Trip_Direction >(direction_id_);
}
inline ::transit_scheduled::Trip_Direction Trip::direction_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.direction_id)
  return _internal_direction_id();
}
inline void Trip::_internal_set_direction_id(::transit_scheduled::Trip_Direction value) {
  
  direction_id_ = value;
}
inline void Trip::set_direction_id(::transit_scheduled::Trip_Direction value) {
  _internal_set_direction_id(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.direction_id)
}

// string block_id = 7;
inline void Trip::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& Trip::block_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trip::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.block_id)
}
inline std::string* Trip::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Trip.block_id)
  return _s;
}
inline const std::string& Trip::_internal_block_id() const {
  return block_id_.Get();
}
inline void Trip::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Trip::_internal_mutable_block_id() {
  
  return block_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Trip::release_block_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Trip.block_id)
  return block_id_.Release();
}
inline void Trip::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(block_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (block_id_.IsDefault()) {
    block_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Trip.block_id)
}

// string shape_id = 8;
inline void Trip::clear_shape_id() {
  shape_id_.ClearToEmpty();
}
inline const std::string& Trip::shape_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.shape_id)
  return _internal_shape_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trip::set_shape_id(ArgT0&& arg0, ArgT... args) {
 
 shape_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.shape_id)
}
inline std::string* Trip::mutable_shape_id() {
  std::string* _s = _internal_mutable_shape_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.Trip.shape_id)
  return _s;
}
inline const std::string& Trip::_internal_shape_id() const {
  return shape_id_.Get();
}
inline void Trip::_internal_set_shape_id(const std::string& value) {
  
  shape_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Trip::_internal_mutable_shape_id() {
  
  return shape_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Trip::release_shape_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.Trip.shape_id)
  return shape_id_.Release();
}
inline void Trip::set_allocated_shape_id(std::string* shape_id) {
  if (shape_id != nullptr) {
    
  } else {
    
  }
  shape_id_.SetAllocated(shape_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shape_id_.IsDefault()) {
    shape_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.Trip.shape_id)
}

// .transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;
inline void Trip::clear_wheelchair_accessible() {
  wheelchair_accessible_ = 0;
}
inline ::transit_scheduled::Trip_WheelchairAccessibility Trip::_internal_wheelchair_accessible() const {
  return static_cast< ::transit_scheduled::Trip_WheelchairAccessibility >(wheelchair_accessible_);
}
inline ::transit_scheduled::Trip_WheelchairAccessibility Trip::wheelchair_accessible() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.wheelchair_accessible)
  return _internal_wheelchair_accessible();
}
inline void Trip::_internal_set_wheelchair_accessible(::transit_scheduled::Trip_WheelchairAccessibility value) {
  
  wheelchair_accessible_ = value;
}
inline void Trip::set_wheelchair_accessible(::transit_scheduled::Trip_WheelchairAccessibility value) {
  _internal_set_wheelchair_accessible(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.wheelchair_accessible)
}

// .transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;
inline void Trip::clear_bikes_allowed() {
  bikes_allowed_ = 0;
}
inline ::transit_scheduled::Trip_BikeAllowance Trip::_internal_bikes_allowed() const {
  return static_cast< ::transit_scheduled::Trip_BikeAllowance >(bikes_allowed_);
}
inline ::transit_scheduled::Trip_BikeAllowance Trip::bikes_allowed() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.Trip.bikes_allowed)
  return _internal_bikes_allowed();
}
inline void Trip::_internal_set_bikes_allowed(::transit_scheduled::Trip_BikeAllowance value) {
  
  bikes_allowed_ = value;
}
inline void Trip::set_bikes_allowed(::transit_scheduled::Trip_BikeAllowance value) {
  _internal_set_bikes_allowed(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.Trip.bikes_allowed)
}

// -------------------------------------------------------------------

// StopTime

// string trip_id = 1;
inline void StopTime::clear_trip_id() {
  trip_id_.ClearToEmpty();
}
inline const std::string& StopTime::trip_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.trip_id)
  return _internal_trip_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopTime::set_trip_id(ArgT0&& arg0, ArgT... args) {
 
 trip_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.trip_id)
}
inline std::string* StopTime::mutable_trip_id() {
  std::string* _s = _internal_mutable_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.StopTime.trip_id)
  return _s;
}
inline const std::string& StopTime::_internal_trip_id() const {
  return trip_id_.Get();
}
inline void StopTime::_internal_set_trip_id(const std::string& value) {
  
  trip_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopTime::_internal_mutable_trip_id() {
  
  return trip_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopTime::release_trip_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.StopTime.trip_id)
  return trip_id_.Release();
}
inline void StopTime::set_allocated_trip_id(std::string* trip_id) {
  if (trip_id != nullptr) {
    
  } else {
    
  }
  trip_id_.SetAllocated(trip_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trip_id_.IsDefault()) {
    trip_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.StopTime.trip_id)
}

// string arrival_time = 2;
inline void StopTime::clear_arrival_time() {
  arrival_time_.ClearToEmpty();
}
inline const std::string& StopTime::arrival_time() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.arrival_time)
  return _internal_arrival_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopTime::set_arrival_time(ArgT0&& arg0, ArgT... args) {
 
 arrival_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.arrival_time)
}
inline std::string* StopTime::mutable_arrival_time() {
  std::string* _s = _internal_mutable_arrival_time();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.StopTime.arrival_time)
  return _s;
}
inline const std::string& StopTime::_internal_arrival_time() const {
  return arrival_time_.Get();
}
inline void StopTime::_internal_set_arrival_time(const std::string& value) {
  
  arrival_time_.Set(value, GetArenaForAllocation());
}
inline std::string* StopTime::_internal_mutable_arrival_time() {
  
  return arrival_time_.Mutable(GetArenaForAllocation());
}
inline std::string* StopTime::release_arrival_time() {
  // @@protoc_insertion_point(field_release:transit_scheduled.StopTime.arrival_time)
  return arrival_time_.Release();
}
inline void StopTime::set_allocated_arrival_time(std::string* arrival_time) {
  if (arrival_time != nullptr) {
    
  } else {
    
  }
  arrival_time_.SetAllocated(arrival_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (arrival_time_.IsDefault()) {
    arrival_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.StopTime.arrival_time)
}

// string departure_time = 3;
inline void StopTime::clear_departure_time() {
  departure_time_.ClearToEmpty();
}
inline const std::string& StopTime::departure_time() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.departure_time)
  return _internal_departure_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopTime::set_departure_time(ArgT0&& arg0, ArgT... args) {
 
 departure_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.departure_time)
}
inline std::string* StopTime::mutable_departure_time() {
  std::string* _s = _internal_mutable_departure_time();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.StopTime.departure_time)
  return _s;
}
inline const std::string& StopTime::_internal_departure_time() const {
  return departure_time_.Get();
}
inline void StopTime::_internal_set_departure_time(const std::string& value) {
  
  departure_time_.Set(value, GetArenaForAllocation());
}
inline std::string* StopTime::_internal_mutable_departure_time() {
  
  return departure_time_.Mutable(GetArenaForAllocation());
}
inline std::string* StopTime::release_departure_time() {
  // @@protoc_insertion_point(field_release:transit_scheduled.StopTime.departure_time)
  return departure_time_.Release();
}
inline void StopTime::set_allocated_departure_time(std::string* departure_time) {
  if (departure_time != nullptr) {
    
  } else {
    
  }
  departure_time_.SetAllocated(departure_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (departure_time_.IsDefault()) {
    departure_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.StopTime.departure_time)
}

// string stop_id = 4;
inline void StopTime::clear_stop_id() {
  stop_id_.ClearToEmpty();
}
inline const std::string& StopTime::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.stop_id)
  return _internal_stop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopTime::set_stop_id(ArgT0&& arg0, ArgT... args) {
 
 stop_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.stop_id)
}
inline std::string* StopTime::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.StopTime.stop_id)
  return _s;
}
inline const std::string& StopTime::_internal_stop_id() const {
  return stop_id_.Get();
}
inline void StopTime::_internal_set_stop_id(const std::string& value) {
  
  stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopTime::_internal_mutable_stop_id() {
  
  return stop_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopTime::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_scheduled.StopTime.stop_id)
  return stop_id_.Release();
}
inline void StopTime::set_allocated_stop_id(std::string* stop_id) {
  if (stop_id != nullptr) {
    
  } else {
    
  }
  stop_id_.SetAllocated(stop_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stop_id_.IsDefault()) {
    stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.StopTime.stop_id)
}

// uint32 stop_sequence = 5;
inline void StopTime::clear_stop_sequence() {
  stop_sequence_ = 0u;
}
inline uint32_t StopTime::_internal_stop_sequence() const {
  return stop_sequence_;
}
inline uint32_t StopTime::stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.stop_sequence)
  return _internal_stop_sequence();
}
inline void StopTime::_internal_set_stop_sequence(uint32_t value) {
  
  stop_sequence_ = value;
}
inline void StopTime::set_stop_sequence(uint32_t value) {
  _internal_set_stop_sequence(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.stop_sequence)
}

// string stop_headsign = 6;
inline void StopTime::clear_stop_headsign() {
  stop_headsign_.ClearToEmpty();
}
inline const std::string& StopTime::stop_headsign() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.stop_headsign)
  return _internal_stop_headsign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopTime::set_stop_headsign(ArgT0&& arg0, ArgT... args) {
 
 stop_headsign_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.stop_headsign)
}
inline std::string* StopTime::mutable_stop_headsign() {
  std::string* _s = _internal_mutable_stop_headsign();
  // @@protoc_insertion_point(field_mutable:transit_scheduled.StopTime.stop_headsign)
  return _s;
}
inline const std::string& StopTime::_internal_stop_headsign() const {
  return stop_headsign_.Get();
}
inline void StopTime::_internal_set_stop_headsign(const std::string& value) {
  
  stop_headsign_.Set(value, GetArenaForAllocation());
}
inline std::string* StopTime::_internal_mutable_stop_headsign() {
  
  return stop_headsign_.Mutable(GetArenaForAllocation());
}
inline std::string* StopTime::release_stop_headsign() {
  // @@protoc_insertion_point(field_release:transit_scheduled.StopTime.stop_headsign)
  return stop_headsign_.Release();
}
inline void StopTime::set_allocated_stop_headsign(std::string* stop_headsign) {
  if (stop_headsign != nullptr) {
    
  } else {
    
  }
  stop_headsign_.SetAllocated(stop_headsign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stop_headsign_.IsDefault()) {
    stop_headsign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_scheduled.StopTime.stop_headsign)
}

// .transit_scheduled.StopTime.PickupType pickup_type = 7;
inline void StopTime::clear_pickup_type() {
  pickup_type_ = 0;
}
inline ::transit_scheduled::StopTime_PickupType StopTime::_internal_pickup_type() const {
  return static_cast< ::transit_scheduled::StopTime_PickupType >(pickup_type_);
}
inline ::transit_scheduled::StopTime_PickupType StopTime::pickup_type() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.pickup_type)
  return _internal_pickup_type();
}
inline void StopTime::_internal_set_pickup_type(::transit_scheduled::StopTime_PickupType value) {
  
  pickup_type_ = value;
}
inline void StopTime::set_pickup_type(::transit_scheduled::StopTime_PickupType value) {
  _internal_set_pickup_type(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.pickup_type)
}

// .transit_scheduled.StopTime.DropOffType drop_off_type = 8;
inline void StopTime::clear_drop_off_type() {
  drop_off_type_ = 0;
}
inline ::transit_scheduled::StopTime_DropOffType StopTime::_internal_drop_off_type() const {
  return static_cast< ::transit_scheduled::StopTime_DropOffType >(drop_off_type_);
}
inline ::transit_scheduled::StopTime_DropOffType StopTime::drop_off_type() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.drop_off_type)
  return _internal_drop_off_type();
}
inline void StopTime::_internal_set_drop_off_type(::transit_scheduled::StopTime_DropOffType value) {
  
  drop_off_type_ = value;
}
inline void StopTime::set_drop_off_type(::transit_scheduled::StopTime_DropOffType value) {
  _internal_set_drop_off_type(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.drop_off_type)
}

// .transit_scheduled.ContinuousPickup continuous_pickup = 9;
inline void StopTime::clear_continuous_pickup() {
  continuous_pickup_ = 0;
}
inline ::transit_scheduled::ContinuousPickup StopTime::_internal_continuous_pickup() const {
  return static_cast< ::transit_scheduled::ContinuousPickup >(continuous_pickup_);
}
inline ::transit_scheduled::ContinuousPickup StopTime::continuous_pickup() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.continuous_pickup)
  return _internal_continuous_pickup();
}
inline void StopTime::_internal_set_continuous_pickup(::transit_scheduled::ContinuousPickup value) {
  
  continuous_pickup_ = value;
}
inline void StopTime::set_continuous_pickup(::transit_scheduled::ContinuousPickup value) {
  _internal_set_continuous_pickup(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.continuous_pickup)
}

// .transit_scheduled.ContinuousDropOff continuous_drop_off = 10;
inline void StopTime::clear_continuous_drop_off() {
  continuous_drop_off_ = 0;
}
inline ::transit_scheduled::ContinuousDropOff StopTime::_internal_continuous_drop_off() const {
  return static_cast< ::transit_scheduled::ContinuousDropOff >(continuous_drop_off_);
}
inline ::transit_scheduled::ContinuousDropOff StopTime::continuous_drop_off() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.continuous_drop_off)
  return _internal_continuous_drop_off();
}
inline void StopTime::_internal_set_continuous_drop_off(::transit_scheduled::ContinuousDropOff value) {
  
  continuous_drop_off_ = value;
}
inline void StopTime::set_continuous_drop_off(::transit_scheduled::ContinuousDropOff value) {
  _internal_set_continuous_drop_off(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.continuous_drop_off)
}

// float shape_dist_traveled = 11;
inline void StopTime::clear_shape_dist_traveled() {
  shape_dist_traveled_ = 0;
}
inline float StopTime::_internal_shape_dist_traveled() const {
  return shape_dist_traveled_;
}
inline float StopTime::shape_dist_traveled() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.shape_dist_traveled)
  return _internal_shape_dist_traveled();
}
inline void StopTime::_internal_set_shape_dist_traveled(float value) {
  
  shape_dist_traveled_ = value;
}
inline void StopTime::set_shape_dist_traveled(float value) {
  _internal_set_shape_dist_traveled(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.shape_dist_traveled)
}

// uint32 timepoint = 12;
inline void StopTime::clear_timepoint() {
  timepoint_ = 0u;
}
inline uint32_t StopTime::_internal_timepoint() const {
  return timepoint_;
}
inline uint32_t StopTime::timepoint() const {
  // @@protoc_insertion_point(field_get:transit_scheduled.StopTime.timepoint)
  return _internal_timepoint();
}
inline void StopTime::_internal_set_timepoint(uint32_t value) {
  
  timepoint_ = value;
}
inline void StopTime::set_timepoint(uint32_t value) {
  _internal_set_timepoint(value);
  // @@protoc_insertion_point(field_set:transit_scheduled.StopTime.timepoint)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace transit_scheduled

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::transit_scheduled::Stop_LocationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::Stop_LocationType>() {
  return ::transit_scheduled::Stop_LocationType_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::Stop_WheelchairBoarding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::Stop_WheelchairBoarding>() {
  return ::transit_scheduled::Stop_WheelchairBoarding_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::Route_RouteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::Route_RouteType>() {
  return ::transit_scheduled::Route_RouteType_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::Trip_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::Trip_Direction>() {
  return ::transit_scheduled::Trip_Direction_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::Trip_WheelchairAccessibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::Trip_WheelchairAccessibility>() {
  return ::transit_scheduled::Trip_WheelchairAccessibility_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::Trip_BikeAllowance> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::Trip_BikeAllowance>() {
  return ::transit_scheduled::Trip_BikeAllowance_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::StopTime_PickupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::StopTime_PickupType>() {
  return ::transit_scheduled::StopTime_PickupType_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::StopTime_DropOffType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::StopTime_DropOffType>() {
  return ::transit_scheduled::StopTime_DropOffType_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::StopTime_TimePoint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::StopTime_TimePoint>() {
  return ::transit_scheduled::StopTime_TimePoint_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::ContinuousPickup> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::ContinuousPickup>() {
  return ::transit_scheduled::ContinuousPickup_descriptor();
}
template <> struct is_proto_enum< ::transit_scheduled::ContinuousDropOff> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_scheduled::ContinuousDropOff>() {
  return ::transit_scheduled::ContinuousDropOff_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fv1_2fgtfs_2dschedule_2eproto
