// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: protos/v1/gtfs-schedule.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace TransitScheduled {

  /// <summary>Holder for reflection information generated from protos/v1/gtfs-schedule.proto</summary>
  public static partial class GtfsScheduleReflection {

    #region Descriptor
    /// <summary>File descriptor for protos/v1/gtfs-schedule.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static GtfsScheduleReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch1wcm90b3MvdjEvZ3Rmcy1zY2hlZHVsZS5wcm90bxIRdHJhbnNpdF9zY2hl",
            "ZHVsZWQitwEKBkFnZW5jeRIRCglhZ2VuY3lfaWQYASABKAkSEwoLYWdlbmN5",
            "X25hbWUYAiABKAkSEgoKYWdlbmN5X3VybBgDIAEoCRIXCg9hZ2VuY3lfdGlt",
            "ZXpvbmUYBCABKAkSEwoLYWdlbmN5X2xhbmcYBSABKAkSFAoMYWdlbmN5X3Bo",
            "b25lGAYgASgJEhcKD2FnZW5jeV9mYXJlX3VybBgHIAEoCRIUCgxhZ2VuY3lf",
            "ZW1haWwYCCABKAkisQUKBFN0b3ASDwoHc3RvcF9pZBgBIAEoCRIRCglzdG9w",
            "X2NvZGUYAiABKAkSEQoJc3RvcF9uYW1lGAMgASgJEhUKDXR0c19zdG9wX25h",
            "bWUYBCABKAkSEQoJc3RvcF9kZXNjGAUgASgJEhAKCHN0b3BfbGF0GAYgASgB",
            "EhAKCHN0b3BfbG9uGAcgASgBEg8KB3pvbmVfaWQYCCABKAkSEAoIc3RvcF91",
            "cmwYCSABKAkSOwoNbG9jYXRpb25fdHlwZRgKIAEoDjIkLnRyYW5zaXRfc2No",
            "ZWR1bGVkLlN0b3AuTG9jYXRpb25UeXBlEhYKDnBhcmVudF9zdGF0aW9uGAsg",
            "ASgJEhUKDXN0b3BfdGltZXpvbmUYDCABKAkSRwoTd2hlZWxjaGFpcl9ib2Fy",
            "ZGluZxgNIAEoDjIqLnRyYW5zaXRfc2NoZWR1bGVkLlN0b3AuV2hlZWxjaGFp",
            "ckJvYXJkaW5nEhAKCGxldmVsX2lkGA4gASgJEhUKDXBsYXRmb3JtX2NvZGUY",
            "DyABKAkiowEKDExvY2F0aW9uVHlwZRIWChJMT0NBVElPTl9UWVBFX1NUT1AQ",
            "ABIZChVMT0NBVElPTl9UWVBFX1NUQVRJT04QARIfChtMT0NBVElPTl9UWVBF",
            "X0VOVFJBTkNFX0VYSVQQAhIeChpMT0NBVElPTl9UWVBFX0dFTkVSSUNfTk9E",
            "RRADEh8KG0xPQ0FUSU9OX1RZUEVfQk9BUkRJTkdfQVJFQRAEIn0KEldoZWVs",
            "Y2hhaXJCb2FyZGluZxIfChtXSEVFTENIQUlSX0JPQVJESU5HX05PX0lORk8Q",
            "ABIgChxXSEVFTENIQUlSX0JPQVJESU5HX1BPU1NJQkxFEAESJAogV0hFRUxD",
            "SEFJUl9CT0FSRElOR19OT1RfUE9TU0lCTEUQAiLKBQoFUm91dGUSEAoIcm91",
            "dGVfaWQYASABKAkSEQoJYWdlbmN5X2lkGAIgASgJEhgKEHJvdXRlX3Nob3J0",
            "X25hbWUYAyABKAkSFwoPcm91dGVfbG9uZ19uYW1lGAQgASgJEhIKCnJvdXRl",
            "X2Rlc2MYBSABKAkSNgoKcm91dGVfdHlwZRgGIAEoDjIiLnRyYW5zaXRfc2No",
            "ZWR1bGVkLlJvdXRlLlJvdXRlVHlwZRIRCglyb3V0ZV91cmwYByABKAkSEwoL",
            "cm91dGVfY29sb3IYCCABKAkSGAoQcm91dGVfdGV4dF9jb2xvchgJIAEoCRIY",
            "ChByb3V0ZV9zb3J0X29yZGVyGAogASgNEj4KEWNvbnRpbnVvdXNfcGlja3Vw",
            "GAsgASgOMiMudHJhbnNpdF9zY2hlZHVsZWQuQ29udGludW91c1BpY2t1cBJB",
            "ChNjb250aW51b3VzX2Ryb3Bfb2ZmGAwgASgOMiQudHJhbnNpdF9zY2hlZHVs",
            "ZWQuQ29udGludW91c0Ryb3BPZmYSEgoKbmV0d29ya19pZBgNIAEoCSKpAgoJ",
            "Um91dGVUeXBlEicKI1JPVVRFX1RZUEVfVFJBTV9TVFJFRVRDQVJfTElHSFRS",
            "QUlMEAASGwoXUk9VVEVfVFlQRV9TVUJXQVlfTUVUUk8QARITCg9ST1VURV9U",
            "WVBFX1JBSUwQAhISCg5ST1VURV9UWVBFX0JVUxADEhQKEFJPVVRFX1RZUEVf",
            "RkVSUlkQBBIZChVST1VURV9UWVBFX0NBQkxFX1RSQU0QBRIuCipST1VURV9U",
            "WVBFX0FFUklBTF9MSUZUX1NVU1BFTkRFRF9DQUJMRV9DQVIQBhIYChRST1VU",
            "RV9UWVBFX0ZVTklDVUxBUhAHEhkKFVJPVVRFX1RZUEVfVFJPTExFWUJVUxAL",
            "EhcKE1JPVVRFX1RZUEVfTU9OT1JBSUwQDCKbBQoEVHJpcBIQCghyb3V0ZV9p",
            "ZBgBIAEoCRISCgpzZXJ2aWNlX2lkGAIgASgJEg8KB3RyaXBfaWQYAyABKAkS",
            "FQoNdHJpcF9oZWFkc2lnbhgEIAEoCRIXCg90cmlwX3Nob3J0X25hbWUYBSAB",
            "KAkSNwoMZGlyZWN0aW9uX2lkGAYgASgOMiEudHJhbnNpdF9zY2hlZHVsZWQu",
            "VHJpcC5EaXJlY3Rpb24SEAoIYmxvY2tfaWQYByABKAkSEAoIc2hhcGVfaWQY",
            "CCABKAkSTgoVd2hlZWxjaGFpcl9hY2Nlc3NpYmxlGAkgASgOMi8udHJhbnNp",
            "dF9zY2hlZHVsZWQuVHJpcC5XaGVlbGNoYWlyQWNjZXNzaWJpbGl0eRI8Cg1i",
            "aWtlc19hbGxvd2VkGAogASgOMiUudHJhbnNpdF9zY2hlZHVsZWQuVHJpcC5C",
            "aWtlQWxsb3dhbmNlIkAKCURpcmVjdGlvbhIbChdESVJFQ1RJT05fT05FX0RJ",
            "UkVDVElPThAAEhYKEkRJUkVDVElPTl9PUFBPU0lURRABIpUBChdXaGVlbGNo",
            "YWlyQWNjZXNzaWJpbGl0eRIkCiBXSEVFTENIQUlSX0FDQ0VTU0lCSUxJVFlf",
            "Tk9fSU5GTxAAEicKI1dIRUVMQ0hBSVJfQUNDRVNTSUJJTElUWV9BQ0NFU1NJ",
            "QkxFEAESKwonV0hFRUxDSEFJUl9BQ0NFU1NJQklMSVRZX05PVF9BQ0NFU1NJ",
            "QkxFEAIiZwoNQmlrZUFsbG93YW5jZRIaChZCSUtFX0FMTE9XQU5DRV9OT19J",
            "TkZPEAASGgoWQklLRV9BTExPV0FOQ0VfQUxMT1dFRBABEh4KGkJJS0VfQUxM",
            "T1dBTkNFX05PVF9BTExPV0VEEAIiyAYKCFN0b3BUaW1lEg8KB3RyaXBfaWQY",
            "ASABKAkSFAoMYXJyaXZhbF90aW1lGAIgASgJEhYKDmRlcGFydHVyZV90aW1l",
            "GAMgASgJEg8KB3N0b3BfaWQYBCABKAkSFQoNc3RvcF9zZXF1ZW5jZRgFIAEo",
            "DRIVCg1zdG9wX2hlYWRzaWduGAYgASgJEjsKC3BpY2t1cF90eXBlGAcgASgO",
            "MiYudHJhbnNpdF9zY2hlZHVsZWQuU3RvcFRpbWUuUGlja3VwVHlwZRI+Cg1k",
            "cm9wX29mZl90eXBlGAggASgOMicudHJhbnNpdF9zY2hlZHVsZWQuU3RvcFRp",
            "bWUuRHJvcE9mZlR5cGUSPgoRY29udGludW91c19waWNrdXAYCSABKA4yIy50",
            "cmFuc2l0X3NjaGVkdWxlZC5Db250aW51b3VzUGlja3VwEkEKE2NvbnRpbnVv",
            "dXNfZHJvcF9vZmYYCiABKA4yJC50cmFuc2l0X3NjaGVkdWxlZC5Db250aW51",
            "b3VzRHJvcE9mZhIbChNzaGFwZV9kaXN0X3RyYXZlbGVkGAsgASgCEhEKCXRp",
            "bWVwb2ludBgMIAEoDSKhAQoKUGlja3VwVHlwZRIjCh9QSUNLVVBfVFlQRV9S",
            "RUdVTEFSTFlfU0NIRURVTEVEEAASHgoaUElDS1VQX1RZUEVfTk9ORV9BVkFJ",
            "TEFCTEUQARIhCh1QSUNLVVBfVFlQRV9NVVNUX1BIT05FX0FHRU5DWRACEisK",
            "J1BJQ0tVUF9UWVBFX01VU1RfQ09PUkRJTkFURV9XSVRIX0RSSVZFUhADIqoB",
            "CgtEcm9wT2ZmVHlwZRIlCiFEUk9QX09GRl9UWVBFX1JFR1VMQVJMWV9TQ0hF",
            "RFVMRUQQABIgChxEUk9QX09GRl9UWVBFX05PTkVfQVZBSUxBQkxFEAESIwof",
            "RFJPUF9PRkZfVFlQRV9NVVNUX1BIT05FX0FHRU5DWRACEi0KKURST1BfT0ZG",
            "X1RZUEVfTVVTVF9DT09SRElOQVRFX1dJVEhfRFJJVkVSEAMiPQoJVGltZVBv",
            "aW50EhoKFlRJTUVfUE9JTlRfQVBQUk9YSU1BVEUQABIUChBUSU1FX1BPSU5U",
            "X0VYQUNUEAEqvAEKEENvbnRpbnVvdXNQaWNrdXASHgoaQ09OVElOVU9VU19Q",
            "SUNLVVBfU1RPUFBJTkcQABIsCihDT05USU5VT1VTX1BJQ0tVUF9OT19DT05U",
            "SU5VT1VTX1NUT1BQSU5HEAESJwojQ09OVElOVU9VU19QSUNLVVBfTVVTVF9Q",
            "SE9ORV9BR0VOQ1kQAhIxCi1DT05USU5VT1VTX1BJQ0tVUF9NVVNUX0NPT1JE",
            "SU5BVEVfV0lUSF9EUklWRVIQAyrQAQoRQ29udGludW91c0Ryb3BPZmYSKwon",
            "Q09OVElOVU9VU19EUk9QX09GRl9DT05USU5VT1VTX1NUT1BQSU5HEAASLgoq",
            "Q09OVElOVU9VU19EUk9QX09GRl9OT19DT05USU5VT1VTX1NUT1BQSU5HEAES",
            "KQolQ09OVElOVU9VU19EUk9QX09GRl9NVVNUX1BIT05FX0FHRU5DWRACEjMK",
            "L0NPTlRJTlVPVVNfRFJPUF9PRkZfTVVTVF9DT09SRElOQVRFX1dJVEhfRFJJ",
            "VkVSEANiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::TransitScheduled.ContinuousPickup), typeof(global::TransitScheduled.ContinuousDropOff), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitScheduled.Agency), global::TransitScheduled.Agency.Parser, new[]{ "AgencyId", "AgencyName", "AgencyUrl", "AgencyTimezone", "AgencyLang", "AgencyPhone", "AgencyFareUrl", "AgencyEmail" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitScheduled.Stop), global::TransitScheduled.Stop.Parser, new[]{ "StopId", "StopCode", "StopName", "TtsStopName", "StopDesc", "StopLat", "StopLon", "ZoneId", "StopUrl", "LocationType", "ParentStation", "StopTimezone", "WheelchairBoarding", "LevelId", "PlatformCode" }, null, new[]{ typeof(global::TransitScheduled.Stop.Types.LocationType), typeof(global::TransitScheduled.Stop.Types.WheelchairBoarding) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitScheduled.Route), global::TransitScheduled.Route.Parser, new[]{ "RouteId", "AgencyId", "RouteShortName", "RouteLongName", "RouteDesc", "RouteType", "RouteUrl", "RouteColor", "RouteTextColor", "RouteSortOrder", "ContinuousPickup", "ContinuousDropOff", "NetworkId" }, null, new[]{ typeof(global::TransitScheduled.Route.Types.RouteType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitScheduled.Trip), global::TransitScheduled.Trip.Parser, new[]{ "RouteId", "ServiceId", "TripId", "TripHeadsign", "TripShortName", "DirectionId", "BlockId", "ShapeId", "WheelchairAccessible", "BikesAllowed" }, null, new[]{ typeof(global::TransitScheduled.Trip.Types.Direction), typeof(global::TransitScheduled.Trip.Types.WheelchairAccessibility), typeof(global::TransitScheduled.Trip.Types.BikeAllowance) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitScheduled.StopTime), global::TransitScheduled.StopTime.Parser, new[]{ "TripId", "ArrivalTime", "DepartureTime", "StopId", "StopSequence", "StopHeadsign", "PickupType", "DropOffType", "ContinuousPickup", "ContinuousDropOff", "ShapeDistTraveled", "Timepoint" }, null, new[]{ typeof(global::TransitScheduled.StopTime.Types.PickupType), typeof(global::TransitScheduled.StopTime.Types.DropOffType), typeof(global::TransitScheduled.StopTime.Types.TimePoint) }, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Indicates that the rider can board the transit vehicle at any point along the
  /// vehicle’s travel path as described by shapes.txt.
  /// Valid options are:
  ///   0 - Continuous stopping pickup.
  ///   1 or empty - No continuous stopping pickup.
  ///   2 - Must phone agency to arrange continuous stopping pickup.
  ///   3 - Must coordinate with driver to arrange continuous stopping pickup.
  /// </summary>
  public enum ContinuousPickup {
    [pbr::OriginalName("CONTINUOUS_PICKUP_STOPPING")] Stopping = 0,
    [pbr::OriginalName("CONTINUOUS_PICKUP_NO_CONTINUOUS_STOPPING")] NoContinuousStopping = 1,
    [pbr::OriginalName("CONTINUOUS_PICKUP_MUST_PHONE_AGENCY")] MustPhoneAgency = 2,
    [pbr::OriginalName("CONTINUOUS_PICKUP_MUST_COORDINATE_WITH_DRIVER")] MustCoordinateWithDriver = 3,
  }

  /// <summary>
  /// Indicates that the rider can alight from the transit vehicle at any point
  /// along the vehicle’s travel path as described by shapes.txt, on every trip
  /// of the route.
  /// </summary>
  public enum ContinuousDropOff {
    [pbr::OriginalName("CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING")] ContinuousStopping = 0,
    [pbr::OriginalName("CONTINUOUS_DROP_OFF_NO_CONTINUOUS_STOPPING")] NoContinuousStopping = 1,
    [pbr::OriginalName("CONTINUOUS_DROP_OFF_MUST_PHONE_AGENCY")] MustPhoneAgency = 2,
    [pbr::OriginalName("CONTINUOUS_DROP_OFF_MUST_COORDINATE_WITH_DRIVER")] MustCoordinateWithDriver = 3,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Transit agencies with service represented in this dataset.
  /// </summary>
  public sealed partial class Agency : pb::IMessage<Agency>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Agency> _parser = new pb::MessageParser<Agency>(() => new Agency());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Agency> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitScheduled.GtfsScheduleReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Agency() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Agency(Agency other) : this() {
      agencyId_ = other.agencyId_;
      agencyName_ = other.agencyName_;
      agencyUrl_ = other.agencyUrl_;
      agencyTimezone_ = other.agencyTimezone_;
      agencyLang_ = other.agencyLang_;
      agencyPhone_ = other.agencyPhone_;
      agencyFareUrl_ = other.agencyFareUrl_;
      agencyEmail_ = other.agencyEmail_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Agency Clone() {
      return new Agency(this);
    }

    /// <summary>Field number for the "agency_id" field.</summary>
    public const int AgencyIdFieldNumber = 1;
    private string agencyId_ = "";
    /// <summary>
    /// Identifies a transit brand which is often synonymous with a transit agency.
    /// Note that in some cases, such as when a single agency operates multiple
    /// separate services, agencies and brands are distinct. This document uses the
    /// term "agency" in place of "brand". A dataset may contain data from multiple
    /// agencies.
    /// Conditionally Required:
    /// - Required when the dataset contains data for multiple transit agencies.
    /// - Recommended otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyId {
      get { return agencyId_; }
      set {
        agencyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "agency_name" field.</summary>
    public const int AgencyNameFieldNumber = 2;
    private string agencyName_ = "";
    /// <summary>
    /// Full name of the transit agency.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyName {
      get { return agencyName_; }
      set {
        agencyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "agency_url" field.</summary>
    public const int AgencyUrlFieldNumber = 3;
    private string agencyUrl_ = "";
    /// <summary>
    /// URL of the transit agency.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyUrl {
      get { return agencyUrl_; }
      set {
        agencyUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "agency_timezone" field.</summary>
    public const int AgencyTimezoneFieldNumber = 4;
    private string agencyTimezone_ = "";
    /// <summary>
    /// Timezone where the transit agency is located. If multiple agencies are
    /// specified in the dataset, each must have the same agency_timezone.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyTimezone {
      get { return agencyTimezone_; }
      set {
        agencyTimezone_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "agency_lang" field.</summary>
    public const int AgencyLangFieldNumber = 5;
    private string agencyLang_ = "";
    /// <summary>
    /// Primary language used by this transit agency. Should be provided to help
    /// GTFS consumers choose capitalization rules and other language-specific
    /// settings for the dataset.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyLang {
      get { return agencyLang_; }
      set {
        agencyLang_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "agency_phone" field.</summary>
    public const int AgencyPhoneFieldNumber = 6;
    private string agencyPhone_ = "";
    /// <summary>
    /// A voice telephone number for the specified agency. This field is a string
    /// value that presents the telephone number as typical for the agency's
    /// service area. It may contain punctuation marks to group the digits of the
    /// number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
    /// but the field must not contain any other descriptive text.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyPhone {
      get { return agencyPhone_; }
      set {
        agencyPhone_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "agency_fare_url" field.</summary>
    public const int AgencyFareUrlFieldNumber = 7;
    private string agencyFareUrl_ = "";
    /// <summary>
    /// URL of a web page that allows a rider to purchase tickets or other fare
    /// instruments for that agency online.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyFareUrl {
      get { return agencyFareUrl_; }
      set {
        agencyFareUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "agency_email" field.</summary>
    public const int AgencyEmailFieldNumber = 8;
    private string agencyEmail_ = "";
    /// <summary>
    /// Email address actively monitored by the agency’s customer service
    /// department. This email address should be a direct contact point where
    /// transit riders can reach a customer service representative at the agency.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyEmail {
      get { return agencyEmail_; }
      set {
        agencyEmail_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Agency);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Agency other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AgencyId != other.AgencyId) return false;
      if (AgencyName != other.AgencyName) return false;
      if (AgencyUrl != other.AgencyUrl) return false;
      if (AgencyTimezone != other.AgencyTimezone) return false;
      if (AgencyLang != other.AgencyLang) return false;
      if (AgencyPhone != other.AgencyPhone) return false;
      if (AgencyFareUrl != other.AgencyFareUrl) return false;
      if (AgencyEmail != other.AgencyEmail) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (AgencyId.Length != 0) hash ^= AgencyId.GetHashCode();
      if (AgencyName.Length != 0) hash ^= AgencyName.GetHashCode();
      if (AgencyUrl.Length != 0) hash ^= AgencyUrl.GetHashCode();
      if (AgencyTimezone.Length != 0) hash ^= AgencyTimezone.GetHashCode();
      if (AgencyLang.Length != 0) hash ^= AgencyLang.GetHashCode();
      if (AgencyPhone.Length != 0) hash ^= AgencyPhone.GetHashCode();
      if (AgencyFareUrl.Length != 0) hash ^= AgencyFareUrl.GetHashCode();
      if (AgencyEmail.Length != 0) hash ^= AgencyEmail.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (AgencyId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(AgencyId);
      }
      if (AgencyName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AgencyName);
      }
      if (AgencyUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(AgencyUrl);
      }
      if (AgencyTimezone.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(AgencyTimezone);
      }
      if (AgencyLang.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(AgencyLang);
      }
      if (AgencyPhone.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(AgencyPhone);
      }
      if (AgencyFareUrl.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(AgencyFareUrl);
      }
      if (AgencyEmail.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(AgencyEmail);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (AgencyId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(AgencyId);
      }
      if (AgencyName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AgencyName);
      }
      if (AgencyUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(AgencyUrl);
      }
      if (AgencyTimezone.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(AgencyTimezone);
      }
      if (AgencyLang.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(AgencyLang);
      }
      if (AgencyPhone.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(AgencyPhone);
      }
      if (AgencyFareUrl.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(AgencyFareUrl);
      }
      if (AgencyEmail.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(AgencyEmail);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (AgencyId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyId);
      }
      if (AgencyName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyName);
      }
      if (AgencyUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyUrl);
      }
      if (AgencyTimezone.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyTimezone);
      }
      if (AgencyLang.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyLang);
      }
      if (AgencyPhone.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyPhone);
      }
      if (AgencyFareUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyFareUrl);
      }
      if (AgencyEmail.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyEmail);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Agency other) {
      if (other == null) {
        return;
      }
      if (other.AgencyId.Length != 0) {
        AgencyId = other.AgencyId;
      }
      if (other.AgencyName.Length != 0) {
        AgencyName = other.AgencyName;
      }
      if (other.AgencyUrl.Length != 0) {
        AgencyUrl = other.AgencyUrl;
      }
      if (other.AgencyTimezone.Length != 0) {
        AgencyTimezone = other.AgencyTimezone;
      }
      if (other.AgencyLang.Length != 0) {
        AgencyLang = other.AgencyLang;
      }
      if (other.AgencyPhone.Length != 0) {
        AgencyPhone = other.AgencyPhone;
      }
      if (other.AgencyFareUrl.Length != 0) {
        AgencyFareUrl = other.AgencyFareUrl;
      }
      if (other.AgencyEmail.Length != 0) {
        AgencyEmail = other.AgencyEmail;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            AgencyId = input.ReadString();
            break;
          }
          case 18: {
            AgencyName = input.ReadString();
            break;
          }
          case 26: {
            AgencyUrl = input.ReadString();
            break;
          }
          case 34: {
            AgencyTimezone = input.ReadString();
            break;
          }
          case 42: {
            AgencyLang = input.ReadString();
            break;
          }
          case 50: {
            AgencyPhone = input.ReadString();
            break;
          }
          case 58: {
            AgencyFareUrl = input.ReadString();
            break;
          }
          case 66: {
            AgencyEmail = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            AgencyId = input.ReadString();
            break;
          }
          case 18: {
            AgencyName = input.ReadString();
            break;
          }
          case 26: {
            AgencyUrl = input.ReadString();
            break;
          }
          case 34: {
            AgencyTimezone = input.ReadString();
            break;
          }
          case 42: {
            AgencyLang = input.ReadString();
            break;
          }
          case 50: {
            AgencyPhone = input.ReadString();
            break;
          }
          case 58: {
            AgencyFareUrl = input.ReadString();
            break;
          }
          case 66: {
            AgencyEmail = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Stops where vehicles pick up or drop off riders. Also defines stations and
  /// station entrances.
  /// </summary>
  public sealed partial class Stop : pb::IMessage<Stop>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Stop> _parser = new pb::MessageParser<Stop>(() => new Stop());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Stop> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitScheduled.GtfsScheduleReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Stop() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Stop(Stop other) : this() {
      stopId_ = other.stopId_;
      stopCode_ = other.stopCode_;
      stopName_ = other.stopName_;
      ttsStopName_ = other.ttsStopName_;
      stopDesc_ = other.stopDesc_;
      stopLat_ = other.stopLat_;
      stopLon_ = other.stopLon_;
      zoneId_ = other.zoneId_;
      stopUrl_ = other.stopUrl_;
      locationType_ = other.locationType_;
      parentStation_ = other.parentStation_;
      stopTimezone_ = other.stopTimezone_;
      wheelchairBoarding_ = other.wheelchairBoarding_;
      levelId_ = other.levelId_;
      platformCode_ = other.platformCode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Stop Clone() {
      return new Stop(this);
    }

    /// <summary>Field number for the "stop_id" field.</summary>
    public const int StopIdFieldNumber = 1;
    private string stopId_ = "";
    /// <summary>
    /// Identifies a location: stop/platform, station, entrance/exit, generic node
    /// or boarding area (see location_type).
    /// Multiple routes may use the same stop_id.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopId {
      get { return stopId_; }
      set {
        stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stop_code" field.</summary>
    public const int StopCodeFieldNumber = 2;
    private string stopCode_ = "";
    /// <summary>
    /// Short text or a number that identifies the location for riders. These codes
    /// are often used in phone-based transit information systems or printed on
    /// signage to make it easier for riders to get information for a particular
    /// location. The stop_code may be the same as stop_id if it is public facing.
    /// This field should be left empty for locations without a code presented to
    /// riders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopCode {
      get { return stopCode_; }
      set {
        stopCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stop_name" field.</summary>
    public const int StopNameFieldNumber = 3;
    private string stopName_ = "";
    /// <summary>
    /// Name of the location. The stop_name should match the agency's rider-facing
    /// name for the location as printed on a timetable, published online, or
    /// represented on signage. For translations into other languages, use
    /// translations.txt.
    /// When the location is a boarding area (location_type=4), the stop_name
    /// should contains the name of the boarding area as displayed by the agency.
    /// It could be just one letter (like on some European intercity railway
    /// stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
    /// of short trains” (Paris’ RER).
    /// Conditionally Required:
    /// - Required for locations which are stops (location_type=0), stations
    /// (location_type=1) or entrances/exits (location_type=2).
    /// - Optional for locations which are generic nodes (location_type=3) or
    /// boarding areas (location_type=4).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopName {
      get { return stopName_; }
      set {
        stopName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tts_stop_name" field.</summary>
    public const int TtsStopNameFieldNumber = 4;
    private string ttsStopName_ = "";
    /// <summary>
    /// Readable version of the stop_name. See "Text-to-speech field" in the Term
    /// Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TtsStopName {
      get { return ttsStopName_; }
      set {
        ttsStopName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stop_desc" field.</summary>
    public const int StopDescFieldNumber = 5;
    private string stopDesc_ = "";
    /// <summary>
    /// Description of the location that provides useful, quality information.
    /// Should not be a duplicate of stop_name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopDesc {
      get { return stopDesc_; }
      set {
        stopDesc_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stop_lat" field.</summary>
    public const int StopLatFieldNumber = 6;
    private double stopLat_;
    /// <summary>
    /// Latitude of the location.
    /// For stops/platforms (location_type=0) and boarding area (location_type=4),
    /// the coordinates must be the ones of the bus pole — if exists — and
    /// otherwise of where the travelers are boarding the vehicle (on the sidewalk
    /// or the platform, and not on the roadway or the track where the vehicle
    /// stops).
    /// Conditionally Required:
    /// - Required for locations which are stops (location_type=0), stations
    /// (location_type=1) or entrances/exits (location_type=2).
    /// - Optional for locations which are generic nodes (location_type=3) or
    /// boarding areas (location_type=4).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double StopLat {
      get { return stopLat_; }
      set {
        stopLat_ = value;
      }
    }

    /// <summary>Field number for the "stop_lon" field.</summary>
    public const int StopLonFieldNumber = 7;
    private double stopLon_;
    /// <summary>
    /// Longitude of the location.
    /// For stops/platforms (location_type=0) and boarding area (location_type=4),
    /// the coordinates must be the ones of the bus pole — if exists — and
    /// otherwise of where the travelers are boarding the vehicle (on the sidewalk
    /// or the platform, and not on the roadway or the track where the vehicle
    /// stops).
    /// Conditionally Required:
    /// - Required for locations which are stops (location_type=0), stations
    /// (location_type=1) or entrances/exits (location_type=2).
    /// - Optional for locations which are generic nodes (location_type=3) or
    /// boarding areas (location_type=4).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double StopLon {
      get { return stopLon_; }
      set {
        stopLon_ = value;
      }
    }

    /// <summary>Field number for the "zone_id" field.</summary>
    public const int ZoneIdFieldNumber = 8;
    private string zoneId_ = "";
    /// <summary>
    /// Identifies the fare zone for a stop. If this record represents a station or
    /// station entrance, the zone_id is ignored.
    /// Conditionally Required:
    /// - Required if providing fare information using fare_rules.txt
    /// - Optional otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ZoneId {
      get { return zoneId_; }
      set {
        zoneId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stop_url" field.</summary>
    public const int StopUrlFieldNumber = 9;
    private string stopUrl_ = "";
    /// <summary>
    /// URL of a web page about the location. This should be different from the
    /// agency.agency_url and the routes.route_url field values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopUrl {
      get { return stopUrl_; }
      set {
        stopUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "location_type" field.</summary>
    public const int LocationTypeFieldNumber = 10;
    private global::TransitScheduled.Stop.Types.LocationType locationType_ = global::TransitScheduled.Stop.Types.LocationType.Stop;
    /// <summary>
    /// Location type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.Stop.Types.LocationType LocationType {
      get { return locationType_; }
      set {
        locationType_ = value;
      }
    }

    /// <summary>Field number for the "parent_station" field.</summary>
    public const int ParentStationFieldNumber = 11;
    private string parentStation_ = "";
    /// <summary>
    /// Defines hierarchy between the different locations defined in stops.txt. It
    /// contains the ID of the parent location, as followed:
    /// - Stop/platform (location_type=0): the parent_station field contains the ID
    /// of a station.
    /// - Station (location_type=1): this field must be empty.
    /// - Entrance/exit (location_type=2) or generic node (location_type=3): the
    /// parent_station field contains the ID of a station (location_type=1)
    /// - Boarding Area (location_type=4): the parent_station field contains ID of
    /// a platform.
    /// Conditionally Required:
    /// - Required for locations which are entrances (location_type=2), generic
    /// nodes (location_type=3) or boarding areas (location_type=4).
    /// - Optional for stops/platforms (location_type=0).
    /// - Forbidden for stations (location_type=1).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ParentStation {
      get { return parentStation_; }
      set {
        parentStation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stop_timezone" field.</summary>
    public const int StopTimezoneFieldNumber = 12;
    private string stopTimezone_ = "";
    /// <summary>
    /// Timezone of the location. If the location has a parent station, it inherits
    /// the parent station’s timezone instead of applying its own. Stations and
    /// parentless stops with empty stop_timezone inherit the timezone specified by
    /// agency.agency_timezone. If stop_timezone values are provided, the times in
    /// stop_times.txt should be entered as the time since midnight in the timezone
    /// specified by agency.agency_timezone. This ensures that the time values in a
    /// trip always increase over the course of a trip, regardless of which
    /// timezones the trip crosses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopTimezone {
      get { return stopTimezone_; }
      set {
        stopTimezone_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "wheelchair_boarding" field.</summary>
    public const int WheelchairBoardingFieldNumber = 13;
    private global::TransitScheduled.Stop.Types.WheelchairBoarding wheelchairBoarding_ = global::TransitScheduled.Stop.Types.WheelchairBoarding.NoInfo;
    /// <summary>
    /// Indicates whether wheelchair boardings are possible from the location.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.Stop.Types.WheelchairBoarding WheelchairBoarding {
      get { return wheelchairBoarding_; }
      set {
        wheelchairBoarding_ = value;
      }
    }

    /// <summary>Field number for the "level_id" field.</summary>
    public const int LevelIdFieldNumber = 14;
    private string levelId_ = "";
    /// <summary>
    /// Level of the location. The same level may be used by multiple unlinked
    /// stations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LevelId {
      get { return levelId_; }
      set {
        levelId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "platform_code" field.</summary>
    public const int PlatformCodeFieldNumber = 15;
    private string platformCode_ = "";
    /// <summary>
    /// Platform identifier for a platform stop (a stop belonging to a station).
    /// This should be just the platform identifier (eg. "G" or "3"). Words like
    /// “platform” or "track" (or the feed’s language-specific equivalent) should
    /// not be included. This allows feed consumers to more easily internationalize
    /// and localize the platform identifier into other languages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PlatformCode {
      get { return platformCode_; }
      set {
        platformCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Stop);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Stop other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StopId != other.StopId) return false;
      if (StopCode != other.StopCode) return false;
      if (StopName != other.StopName) return false;
      if (TtsStopName != other.TtsStopName) return false;
      if (StopDesc != other.StopDesc) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(StopLat, other.StopLat)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(StopLon, other.StopLon)) return false;
      if (ZoneId != other.ZoneId) return false;
      if (StopUrl != other.StopUrl) return false;
      if (LocationType != other.LocationType) return false;
      if (ParentStation != other.ParentStation) return false;
      if (StopTimezone != other.StopTimezone) return false;
      if (WheelchairBoarding != other.WheelchairBoarding) return false;
      if (LevelId != other.LevelId) return false;
      if (PlatformCode != other.PlatformCode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (StopId.Length != 0) hash ^= StopId.GetHashCode();
      if (StopCode.Length != 0) hash ^= StopCode.GetHashCode();
      if (StopName.Length != 0) hash ^= StopName.GetHashCode();
      if (TtsStopName.Length != 0) hash ^= TtsStopName.GetHashCode();
      if (StopDesc.Length != 0) hash ^= StopDesc.GetHashCode();
      if (StopLat != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(StopLat);
      if (StopLon != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(StopLon);
      if (ZoneId.Length != 0) hash ^= ZoneId.GetHashCode();
      if (StopUrl.Length != 0) hash ^= StopUrl.GetHashCode();
      if (LocationType != global::TransitScheduled.Stop.Types.LocationType.Stop) hash ^= LocationType.GetHashCode();
      if (ParentStation.Length != 0) hash ^= ParentStation.GetHashCode();
      if (StopTimezone.Length != 0) hash ^= StopTimezone.GetHashCode();
      if (WheelchairBoarding != global::TransitScheduled.Stop.Types.WheelchairBoarding.NoInfo) hash ^= WheelchairBoarding.GetHashCode();
      if (LevelId.Length != 0) hash ^= LevelId.GetHashCode();
      if (PlatformCode.Length != 0) hash ^= PlatformCode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (StopId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(StopId);
      }
      if (StopCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StopCode);
      }
      if (StopName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(StopName);
      }
      if (TtsStopName.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(TtsStopName);
      }
      if (StopDesc.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(StopDesc);
      }
      if (StopLat != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(StopLat);
      }
      if (StopLon != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(StopLon);
      }
      if (ZoneId.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(ZoneId);
      }
      if (StopUrl.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(StopUrl);
      }
      if (LocationType != global::TransitScheduled.Stop.Types.LocationType.Stop) {
        output.WriteRawTag(80);
        output.WriteEnum((int) LocationType);
      }
      if (ParentStation.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(ParentStation);
      }
      if (StopTimezone.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(StopTimezone);
      }
      if (WheelchairBoarding != global::TransitScheduled.Stop.Types.WheelchairBoarding.NoInfo) {
        output.WriteRawTag(104);
        output.WriteEnum((int) WheelchairBoarding);
      }
      if (LevelId.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(LevelId);
      }
      if (PlatformCode.Length != 0) {
        output.WriteRawTag(122);
        output.WriteString(PlatformCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (StopId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(StopId);
      }
      if (StopCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StopCode);
      }
      if (StopName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(StopName);
      }
      if (TtsStopName.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(TtsStopName);
      }
      if (StopDesc.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(StopDesc);
      }
      if (StopLat != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(StopLat);
      }
      if (StopLon != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(StopLon);
      }
      if (ZoneId.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(ZoneId);
      }
      if (StopUrl.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(StopUrl);
      }
      if (LocationType != global::TransitScheduled.Stop.Types.LocationType.Stop) {
        output.WriteRawTag(80);
        output.WriteEnum((int) LocationType);
      }
      if (ParentStation.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(ParentStation);
      }
      if (StopTimezone.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(StopTimezone);
      }
      if (WheelchairBoarding != global::TransitScheduled.Stop.Types.WheelchairBoarding.NoInfo) {
        output.WriteRawTag(104);
        output.WriteEnum((int) WheelchairBoarding);
      }
      if (LevelId.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(LevelId);
      }
      if (PlatformCode.Length != 0) {
        output.WriteRawTag(122);
        output.WriteString(PlatformCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (StopId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
      }
      if (StopCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopCode);
      }
      if (StopName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopName);
      }
      if (TtsStopName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TtsStopName);
      }
      if (StopDesc.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopDesc);
      }
      if (StopLat != 0D) {
        size += 1 + 8;
      }
      if (StopLon != 0D) {
        size += 1 + 8;
      }
      if (ZoneId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ZoneId);
      }
      if (StopUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopUrl);
      }
      if (LocationType != global::TransitScheduled.Stop.Types.LocationType.Stop) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LocationType);
      }
      if (ParentStation.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ParentStation);
      }
      if (StopTimezone.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopTimezone);
      }
      if (WheelchairBoarding != global::TransitScheduled.Stop.Types.WheelchairBoarding.NoInfo) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) WheelchairBoarding);
      }
      if (LevelId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LevelId);
      }
      if (PlatformCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PlatformCode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Stop other) {
      if (other == null) {
        return;
      }
      if (other.StopId.Length != 0) {
        StopId = other.StopId;
      }
      if (other.StopCode.Length != 0) {
        StopCode = other.StopCode;
      }
      if (other.StopName.Length != 0) {
        StopName = other.StopName;
      }
      if (other.TtsStopName.Length != 0) {
        TtsStopName = other.TtsStopName;
      }
      if (other.StopDesc.Length != 0) {
        StopDesc = other.StopDesc;
      }
      if (other.StopLat != 0D) {
        StopLat = other.StopLat;
      }
      if (other.StopLon != 0D) {
        StopLon = other.StopLon;
      }
      if (other.ZoneId.Length != 0) {
        ZoneId = other.ZoneId;
      }
      if (other.StopUrl.Length != 0) {
        StopUrl = other.StopUrl;
      }
      if (other.LocationType != global::TransitScheduled.Stop.Types.LocationType.Stop) {
        LocationType = other.LocationType;
      }
      if (other.ParentStation.Length != 0) {
        ParentStation = other.ParentStation;
      }
      if (other.StopTimezone.Length != 0) {
        StopTimezone = other.StopTimezone;
      }
      if (other.WheelchairBoarding != global::TransitScheduled.Stop.Types.WheelchairBoarding.NoInfo) {
        WheelchairBoarding = other.WheelchairBoarding;
      }
      if (other.LevelId.Length != 0) {
        LevelId = other.LevelId;
      }
      if (other.PlatformCode.Length != 0) {
        PlatformCode = other.PlatformCode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            StopId = input.ReadString();
            break;
          }
          case 18: {
            StopCode = input.ReadString();
            break;
          }
          case 26: {
            StopName = input.ReadString();
            break;
          }
          case 34: {
            TtsStopName = input.ReadString();
            break;
          }
          case 42: {
            StopDesc = input.ReadString();
            break;
          }
          case 49: {
            StopLat = input.ReadDouble();
            break;
          }
          case 57: {
            StopLon = input.ReadDouble();
            break;
          }
          case 66: {
            ZoneId = input.ReadString();
            break;
          }
          case 74: {
            StopUrl = input.ReadString();
            break;
          }
          case 80: {
            LocationType = (global::TransitScheduled.Stop.Types.LocationType) input.ReadEnum();
            break;
          }
          case 90: {
            ParentStation = input.ReadString();
            break;
          }
          case 98: {
            StopTimezone = input.ReadString();
            break;
          }
          case 104: {
            WheelchairBoarding = (global::TransitScheduled.Stop.Types.WheelchairBoarding) input.ReadEnum();
            break;
          }
          case 114: {
            LevelId = input.ReadString();
            break;
          }
          case 122: {
            PlatformCode = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            StopId = input.ReadString();
            break;
          }
          case 18: {
            StopCode = input.ReadString();
            break;
          }
          case 26: {
            StopName = input.ReadString();
            break;
          }
          case 34: {
            TtsStopName = input.ReadString();
            break;
          }
          case 42: {
            StopDesc = input.ReadString();
            break;
          }
          case 49: {
            StopLat = input.ReadDouble();
            break;
          }
          case 57: {
            StopLon = input.ReadDouble();
            break;
          }
          case 66: {
            ZoneId = input.ReadString();
            break;
          }
          case 74: {
            StopUrl = input.ReadString();
            break;
          }
          case 80: {
            LocationType = (global::TransitScheduled.Stop.Types.LocationType) input.ReadEnum();
            break;
          }
          case 90: {
            ParentStation = input.ReadString();
            break;
          }
          case 98: {
            StopTimezone = input.ReadString();
            break;
          }
          case 104: {
            WheelchairBoarding = (global::TransitScheduled.Stop.Types.WheelchairBoarding) input.ReadEnum();
            break;
          }
          case 114: {
            LevelId = input.ReadString();
            break;
          }
          case 122: {
            PlatformCode = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Stop message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Location type. Valid options are:
      ///   0 (or blank) - Stop (or Platform). A location where passengers board or
      ///   disembark from a transit vehicle. Is called a platform when defined
      ///   within a parent_station.
      ///   1 - Station. A physical structure or area that contains one or more
      ///   platform.
      ///   2 - Entrance/Exit. A location where passengers can enter or exit a
      ///   station from the street. If an entrance/exit belongs to multiple
      ///   stations, it may be linked by pathways to both, but the data provider
      ///   must pick one of them as parent.
      ///   3 - Generic Node. A location within a station, not matching any other
      ///   location_type, that may be used to link together pathways define in
      ///   pathways.txt.
      ///   4 - Boarding Area. A specific location on a platform, where passengers
      ///   can board and/or alight vehicles.
      /// </summary>
      public enum LocationType {
        [pbr::OriginalName("LOCATION_TYPE_STOP")] Stop = 0,
        [pbr::OriginalName("LOCATION_TYPE_STATION")] Station = 1,
        [pbr::OriginalName("LOCATION_TYPE_ENTRANCE_EXIT")] EntranceExit = 2,
        [pbr::OriginalName("LOCATION_TYPE_GENERIC_NODE")] GenericNode = 3,
        [pbr::OriginalName("LOCATION_TYPE_BOARDING_AREA")] BoardingArea = 4,
      }

      /// <summary>
      /// Indicates whether wheelchair boardings are possible from the location.
      /// Valid options are:
      ///   For parentless stops:
      ///     0 or empty - No accessibility information for the stop.
      ///     1 - Some vehicles at this stop can be boarded by a rider in a
      ///     wheelchair.
      ///     2 - Wheelchair boarding is not possible at this stop.
      ///   For child stops:
      ///     0 or empty - Stop will inherit its wheelchair_boarding behavior from
      ///     the parent station, if specified in the parent.
      ///     1 - There exists some accessible path from outside the station to the
      ///     specific stop/platform.
      ///     2 - There exists no accessible path from outside the station to the
      ///     specific stop/platform.
      ///   For station entrances/exits:
      ///     0 or empty - Station entrance will inherit its wheelchair_boarding
      ///     behavior from the parent station, if specified for the parent.
      ///     1 - Station entrance is wheelchair accessible.
      ///     2 - No accessible path from station entrance to stops/platforms.
      /// </summary>
      public enum WheelchairBoarding {
        [pbr::OriginalName("WHEELCHAIR_BOARDING_NO_INFO")] NoInfo = 0,
        [pbr::OriginalName("WHEELCHAIR_BOARDING_POSSIBLE")] Possible = 1,
        [pbr::OriginalName("WHEELCHAIR_BOARDING_NOT_POSSIBLE")] NotPossible = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Transit routes. A route is a group of trips that are displayed to riders as a
  /// single service.
  /// </summary>
  public sealed partial class Route : pb::IMessage<Route>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Route> _parser = new pb::MessageParser<Route>(() => new Route());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Route> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitScheduled.GtfsScheduleReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Route() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Route(Route other) : this() {
      routeId_ = other.routeId_;
      agencyId_ = other.agencyId_;
      routeShortName_ = other.routeShortName_;
      routeLongName_ = other.routeLongName_;
      routeDesc_ = other.routeDesc_;
      routeType_ = other.routeType_;
      routeUrl_ = other.routeUrl_;
      routeColor_ = other.routeColor_;
      routeTextColor_ = other.routeTextColor_;
      routeSortOrder_ = other.routeSortOrder_;
      continuousPickup_ = other.continuousPickup_;
      continuousDropOff_ = other.continuousDropOff_;
      networkId_ = other.networkId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Route Clone() {
      return new Route(this);
    }

    /// <summary>Field number for the "route_id" field.</summary>
    public const int RouteIdFieldNumber = 1;
    private string routeId_ = "";
    /// <summary>
    /// Identifies a route.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteId {
      get { return routeId_; }
      set {
        routeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "agency_id" field.</summary>
    public const int AgencyIdFieldNumber = 2;
    private string agencyId_ = "";
    /// <summary>
    /// Agency for the specified route.
    /// Conditionally Required:
    /// - Required if multiple agencies are defined in agency.txt.
    /// - Recommended otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyId {
      get { return agencyId_; }
      set {
        agencyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_short_name" field.</summary>
    public const int RouteShortNameFieldNumber = 3;
    private string routeShortName_ = "";
    /// <summary>
    /// Short name of a route. Often a short, abstract identifier (e.g., "32",
    /// "100X", "Green") that riders use to identify a route. Both route_short_name
    /// and route_long_name may be defined.
    /// Conditionally Required:
    /// - Required if routes.route_long_name is empty.
    /// - Recommended if there is a brief service designation. This should be the
    /// commonly-known passenger name of the service, and should be no longer than
    /// 12 characters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteShortName {
      get { return routeShortName_; }
      set {
        routeShortName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_long_name" field.</summary>
    public const int RouteLongNameFieldNumber = 4;
    private string routeLongName_ = "";
    /// <summary>
    /// Full name of a route. This name is generally more descriptive than the
    /// route_short_name and often includes the route's destination or stop. Both
    /// route_short_name and route_long_name may be defined.
    /// Conditionally Required:
    /// - Required if routes.route_short_name is empty.
    /// - Optional otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteLongName {
      get { return routeLongName_; }
      set {
        routeLongName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_desc" field.</summary>
    public const int RouteDescFieldNumber = 5;
    private string routeDesc_ = "";
    /// <summary>
    /// Description of a route that provides useful, quality information. Should
    /// not be a duplicate of route_short_name or route_long_name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteDesc {
      get { return routeDesc_; }
      set {
        routeDesc_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_type" field.</summary>
    public const int RouteTypeFieldNumber = 6;
    private global::TransitScheduled.Route.Types.RouteType routeType_ = global::TransitScheduled.Route.Types.RouteType.TramStreetcarLightrail;
    /// <summary>
    /// Indicates the type of transportation used on a route.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.Route.Types.RouteType RouteType {
      get { return routeType_; }
      set {
        routeType_ = value;
      }
    }

    /// <summary>Field number for the "route_url" field.</summary>
    public const int RouteUrlFieldNumber = 7;
    private string routeUrl_ = "";
    /// <summary>
    /// URL of a web page about the particular route. Should be different from the
    /// agency.agency_url value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteUrl {
      get { return routeUrl_; }
      set {
        routeUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_color" field.</summary>
    public const int RouteColorFieldNumber = 8;
    private string routeColor_ = "";
    /// <summary>
    /// Route color designation that matches public facing material. Defaults to
    /// white (FFFFFF) when omitted or left empty. The color difference between
    /// route_color and route_text_color should provide sufficient contrast when
    /// viewed on a black and white screen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteColor {
      get { return routeColor_; }
      set {
        routeColor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_text_color" field.</summary>
    public const int RouteTextColorFieldNumber = 9;
    private string routeTextColor_ = "";
    /// <summary>
    /// Legible color to use for text drawn against a background of route_color.
    /// Defaults to black (000000) when omitted or left empty. The color difference
    /// between route_color and route_text_color should provide sufficient contrast
    /// when viewed on a black and white screen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteTextColor {
      get { return routeTextColor_; }
      set {
        routeTextColor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "route_sort_order" field.</summary>
    public const int RouteSortOrderFieldNumber = 10;
    private uint routeSortOrder_;
    /// <summary>
    /// Orders the routes in a way which is ideal for presentation to customers.
    /// Routes with smaller route_sort_order values should be displayed first.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint RouteSortOrder {
      get { return routeSortOrder_; }
      set {
        routeSortOrder_ = value;
      }
    }

    /// <summary>Field number for the "continuous_pickup" field.</summary>
    public const int ContinuousPickupFieldNumber = 11;
    private global::TransitScheduled.ContinuousPickup continuousPickup_ = global::TransitScheduled.ContinuousPickup.Stopping;
    /// <summary>
    /// Indicates that the rider can board the transit vehicle at any point along
    /// the vehicle’s travel path as described by shapes.txt, on every trip of the
    /// route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.ContinuousPickup ContinuousPickup {
      get { return continuousPickup_; }
      set {
        continuousPickup_ = value;
      }
    }

    /// <summary>Field number for the "continuous_drop_off" field.</summary>
    public const int ContinuousDropOffFieldNumber = 12;
    private global::TransitScheduled.ContinuousDropOff continuousDropOff_ = global::TransitScheduled.ContinuousDropOff.ContinuousStopping;
    /// <summary>
    /// Indicates that the rider can alight from the transit vehicle at any point
    /// along the vehicle’s travel path as described by shapes.txt, on every trip
    /// of the route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.ContinuousDropOff ContinuousDropOff {
      get { return continuousDropOff_; }
      set {
        continuousDropOff_ = value;
      }
    }

    /// <summary>Field number for the "network_id" field.</summary>
    public const int NetworkIdFieldNumber = 13;
    private string networkId_ = "";
    /// <summary>
    /// Identifies a group of routes. Multiple rows in routes.txt may have the same
    /// network_id.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string NetworkId {
      get { return networkId_; }
      set {
        networkId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Route);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Route other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RouteId != other.RouteId) return false;
      if (AgencyId != other.AgencyId) return false;
      if (RouteShortName != other.RouteShortName) return false;
      if (RouteLongName != other.RouteLongName) return false;
      if (RouteDesc != other.RouteDesc) return false;
      if (RouteType != other.RouteType) return false;
      if (RouteUrl != other.RouteUrl) return false;
      if (RouteColor != other.RouteColor) return false;
      if (RouteTextColor != other.RouteTextColor) return false;
      if (RouteSortOrder != other.RouteSortOrder) return false;
      if (ContinuousPickup != other.ContinuousPickup) return false;
      if (ContinuousDropOff != other.ContinuousDropOff) return false;
      if (NetworkId != other.NetworkId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (RouteId.Length != 0) hash ^= RouteId.GetHashCode();
      if (AgencyId.Length != 0) hash ^= AgencyId.GetHashCode();
      if (RouteShortName.Length != 0) hash ^= RouteShortName.GetHashCode();
      if (RouteLongName.Length != 0) hash ^= RouteLongName.GetHashCode();
      if (RouteDesc.Length != 0) hash ^= RouteDesc.GetHashCode();
      if (RouteType != global::TransitScheduled.Route.Types.RouteType.TramStreetcarLightrail) hash ^= RouteType.GetHashCode();
      if (RouteUrl.Length != 0) hash ^= RouteUrl.GetHashCode();
      if (RouteColor.Length != 0) hash ^= RouteColor.GetHashCode();
      if (RouteTextColor.Length != 0) hash ^= RouteTextColor.GetHashCode();
      if (RouteSortOrder != 0) hash ^= RouteSortOrder.GetHashCode();
      if (ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) hash ^= ContinuousPickup.GetHashCode();
      if (ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) hash ^= ContinuousDropOff.GetHashCode();
      if (NetworkId.Length != 0) hash ^= NetworkId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (RouteId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RouteId);
      }
      if (AgencyId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AgencyId);
      }
      if (RouteShortName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RouteShortName);
      }
      if (RouteLongName.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(RouteLongName);
      }
      if (RouteDesc.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(RouteDesc);
      }
      if (RouteType != global::TransitScheduled.Route.Types.RouteType.TramStreetcarLightrail) {
        output.WriteRawTag(48);
        output.WriteEnum((int) RouteType);
      }
      if (RouteUrl.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(RouteUrl);
      }
      if (RouteColor.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(RouteColor);
      }
      if (RouteTextColor.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(RouteTextColor);
      }
      if (RouteSortOrder != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(RouteSortOrder);
      }
      if (ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) {
        output.WriteRawTag(88);
        output.WriteEnum((int) ContinuousPickup);
      }
      if (ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) {
        output.WriteRawTag(96);
        output.WriteEnum((int) ContinuousDropOff);
      }
      if (NetworkId.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(NetworkId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (RouteId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RouteId);
      }
      if (AgencyId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AgencyId);
      }
      if (RouteShortName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RouteShortName);
      }
      if (RouteLongName.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(RouteLongName);
      }
      if (RouteDesc.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(RouteDesc);
      }
      if (RouteType != global::TransitScheduled.Route.Types.RouteType.TramStreetcarLightrail) {
        output.WriteRawTag(48);
        output.WriteEnum((int) RouteType);
      }
      if (RouteUrl.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(RouteUrl);
      }
      if (RouteColor.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(RouteColor);
      }
      if (RouteTextColor.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(RouteTextColor);
      }
      if (RouteSortOrder != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(RouteSortOrder);
      }
      if (ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) {
        output.WriteRawTag(88);
        output.WriteEnum((int) ContinuousPickup);
      }
      if (ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) {
        output.WriteRawTag(96);
        output.WriteEnum((int) ContinuousDropOff);
      }
      if (NetworkId.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(NetworkId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (RouteId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteId);
      }
      if (AgencyId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyId);
      }
      if (RouteShortName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteShortName);
      }
      if (RouteLongName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteLongName);
      }
      if (RouteDesc.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteDesc);
      }
      if (RouteType != global::TransitScheduled.Route.Types.RouteType.TramStreetcarLightrail) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RouteType);
      }
      if (RouteUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteUrl);
      }
      if (RouteColor.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteColor);
      }
      if (RouteTextColor.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteTextColor);
      }
      if (RouteSortOrder != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RouteSortOrder);
      }
      if (ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ContinuousPickup);
      }
      if (ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ContinuousDropOff);
      }
      if (NetworkId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NetworkId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Route other) {
      if (other == null) {
        return;
      }
      if (other.RouteId.Length != 0) {
        RouteId = other.RouteId;
      }
      if (other.AgencyId.Length != 0) {
        AgencyId = other.AgencyId;
      }
      if (other.RouteShortName.Length != 0) {
        RouteShortName = other.RouteShortName;
      }
      if (other.RouteLongName.Length != 0) {
        RouteLongName = other.RouteLongName;
      }
      if (other.RouteDesc.Length != 0) {
        RouteDesc = other.RouteDesc;
      }
      if (other.RouteType != global::TransitScheduled.Route.Types.RouteType.TramStreetcarLightrail) {
        RouteType = other.RouteType;
      }
      if (other.RouteUrl.Length != 0) {
        RouteUrl = other.RouteUrl;
      }
      if (other.RouteColor.Length != 0) {
        RouteColor = other.RouteColor;
      }
      if (other.RouteTextColor.Length != 0) {
        RouteTextColor = other.RouteTextColor;
      }
      if (other.RouteSortOrder != 0) {
        RouteSortOrder = other.RouteSortOrder;
      }
      if (other.ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) {
        ContinuousPickup = other.ContinuousPickup;
      }
      if (other.ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) {
        ContinuousDropOff = other.ContinuousDropOff;
      }
      if (other.NetworkId.Length != 0) {
        NetworkId = other.NetworkId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RouteId = input.ReadString();
            break;
          }
          case 18: {
            AgencyId = input.ReadString();
            break;
          }
          case 26: {
            RouteShortName = input.ReadString();
            break;
          }
          case 34: {
            RouteLongName = input.ReadString();
            break;
          }
          case 42: {
            RouteDesc = input.ReadString();
            break;
          }
          case 48: {
            RouteType = (global::TransitScheduled.Route.Types.RouteType) input.ReadEnum();
            break;
          }
          case 58: {
            RouteUrl = input.ReadString();
            break;
          }
          case 66: {
            RouteColor = input.ReadString();
            break;
          }
          case 74: {
            RouteTextColor = input.ReadString();
            break;
          }
          case 80: {
            RouteSortOrder = input.ReadUInt32();
            break;
          }
          case 88: {
            ContinuousPickup = (global::TransitScheduled.ContinuousPickup) input.ReadEnum();
            break;
          }
          case 96: {
            ContinuousDropOff = (global::TransitScheduled.ContinuousDropOff) input.ReadEnum();
            break;
          }
          case 106: {
            NetworkId = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            RouteId = input.ReadString();
            break;
          }
          case 18: {
            AgencyId = input.ReadString();
            break;
          }
          case 26: {
            RouteShortName = input.ReadString();
            break;
          }
          case 34: {
            RouteLongName = input.ReadString();
            break;
          }
          case 42: {
            RouteDesc = input.ReadString();
            break;
          }
          case 48: {
            RouteType = (global::TransitScheduled.Route.Types.RouteType) input.ReadEnum();
            break;
          }
          case 58: {
            RouteUrl = input.ReadString();
            break;
          }
          case 66: {
            RouteColor = input.ReadString();
            break;
          }
          case 74: {
            RouteTextColor = input.ReadString();
            break;
          }
          case 80: {
            RouteSortOrder = input.ReadUInt32();
            break;
          }
          case 88: {
            ContinuousPickup = (global::TransitScheduled.ContinuousPickup) input.ReadEnum();
            break;
          }
          case 96: {
            ContinuousDropOff = (global::TransitScheduled.ContinuousDropOff) input.ReadEnum();
            break;
          }
          case 106: {
            NetworkId = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Route message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Indicates the type of transportation used on a route. Valid options are:
      ///   0 - Tram, Streetcar, Light rail. Any light rail or street level system
      ///   within a metropolitan area.
      ///   1 - Subway, Metro. Any underground rail system within a metropolitan
      ///   area.
      ///   2 - Rail. Used for intercity or long-distance travel.
      ///   3 - Bus. Used for short- and long-distance bus routes.
      ///   4 - Ferry. Used for short- and long-distance boat service.
      ///   5 - Cable tram. Used for street-level rail cars where the cable runs
      ///   beneath the vehicle (e.g., cable car in San Francisco).
      ///   6 - Aerial lift, suspended cable car (e.g., gondola lift, aerial
      ///   tramway). Cable transport where cabins, cars, gondolas or open chairs are
      ///   suspended by means of one or more cables.
      ///   7 - Funicular. Any rail system designed for steep inclines.
      ///   11 - Trolleybus. Electric buses that draw power from overhead wires using
      ///   poles.
      ///   12 - Monorail. Railway in which the track consists of a single rail or a
      ///   beam.
      /// </summary>
      public enum RouteType {
        [pbr::OriginalName("ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL")] TramStreetcarLightrail = 0,
        [pbr::OriginalName("ROUTE_TYPE_SUBWAY_METRO")] SubwayMetro = 1,
        [pbr::OriginalName("ROUTE_TYPE_RAIL")] Rail = 2,
        [pbr::OriginalName("ROUTE_TYPE_BUS")] Bus = 3,
        [pbr::OriginalName("ROUTE_TYPE_FERRY")] Ferry = 4,
        [pbr::OriginalName("ROUTE_TYPE_CABLE_TRAM")] CableTram = 5,
        [pbr::OriginalName("ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABLE_CAR")] AerialLiftSuspendedCableCar = 6,
        [pbr::OriginalName("ROUTE_TYPE_FUNICULAR")] Funicular = 7,
        [pbr::OriginalName("ROUTE_TYPE_TROLLEYBUS")] Trolleybus = 11,
        [pbr::OriginalName("ROUTE_TYPE_MONORAIL")] Monorail = 12,
      }

    }
    #endregion

  }

  /// <summary>
  /// Trips for each route. A trip is a sequence of two or more stops that occur
  /// during a specific time period.
  /// </summary>
  public sealed partial class Trip : pb::IMessage<Trip>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Trip> _parser = new pb::MessageParser<Trip>(() => new Trip());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Trip> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitScheduled.GtfsScheduleReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Trip() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Trip(Trip other) : this() {
      routeId_ = other.routeId_;
      serviceId_ = other.serviceId_;
      tripId_ = other.tripId_;
      tripHeadsign_ = other.tripHeadsign_;
      tripShortName_ = other.tripShortName_;
      directionId_ = other.directionId_;
      blockId_ = other.blockId_;
      shapeId_ = other.shapeId_;
      wheelchairAccessible_ = other.wheelchairAccessible_;
      bikesAllowed_ = other.bikesAllowed_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Trip Clone() {
      return new Trip(this);
    }

    /// <summary>Field number for the "route_id" field.</summary>
    public const int RouteIdFieldNumber = 1;
    private string routeId_ = "";
    /// <summary>
    /// Identifies a route.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteId {
      get { return routeId_; }
      set {
        routeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "service_id" field.</summary>
    public const int ServiceIdFieldNumber = 2;
    private string serviceId_ = "";
    /// <summary>
    /// Identifies a set of dates when service is available for one or more routes.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ServiceId {
      get { return serviceId_; }
      set {
        serviceId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trip_id" field.</summary>
    public const int TripIdFieldNumber = 3;
    private string tripId_ = "";
    /// <summary>
    /// Identifies a trip.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TripId {
      get { return tripId_; }
      set {
        tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trip_headsign" field.</summary>
    public const int TripHeadsignFieldNumber = 4;
    private string tripHeadsign_ = "";
    /// <summary>
    /// Text that appears on signage identifying the trip's destination to riders.
    /// Should be used to distinguish between different patterns of service on the
    /// same route.
    /// If the headsign changes during a trip, values for trip_headsign may be
    /// overridden by defining values in stop_times.stop_headsign for specific
    /// stop_times along the trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TripHeadsign {
      get { return tripHeadsign_; }
      set {
        tripHeadsign_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trip_short_name" field.</summary>
    public const int TripShortNameFieldNumber = 5;
    private string tripShortName_ = "";
    /// <summary>
    /// Public facing text used to identify the trip to riders, for instance, to
    /// identify train numbers for commuter rail trips. If riders do not commonly
    /// rely on trip names, trip_short_name should be empty. A trip_short_name
    /// value, if provided, should uniquely identify a trip within a service day;
    /// it should not be used for destination names or limited/express
    /// designations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TripShortName {
      get { return tripShortName_; }
      set {
        tripShortName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "direction_id" field.</summary>
    public const int DirectionIdFieldNumber = 6;
    private global::TransitScheduled.Trip.Types.Direction directionId_ = global::TransitScheduled.Trip.Types.Direction.OneDirection;
    /// <summary>
    /// Indicates the direction of travel for a trip.
    /// This field should not be used in routing; it provides a way to separate
    /// trips by direction when publishing time tables.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.Trip.Types.Direction DirectionId {
      get { return directionId_; }
      set {
        directionId_ = value;
      }
    }

    /// <summary>Field number for the "block_id" field.</summary>
    public const int BlockIdFieldNumber = 7;
    private string blockId_ = "";
    /// <summary>
    /// Identifies the block to which the trip belongs. A block consists of a
    /// single trip or many sequential trips made using the same vehicle, defined
    /// by shared service days and block_id. A block_id may have trips with
    /// different service days, making distinct blocks. See the example below. To
    /// provide in-seat transfers information, transfers of transfer_type 4 should
    /// be provided instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string BlockId {
      get { return blockId_; }
      set {
        blockId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "shape_id" field.</summary>
    public const int ShapeIdFieldNumber = 8;
    private string shapeId_ = "";
    /// <summary>
    /// Identifies a geospatial shape describing the vehicle travel path for a
    /// trip.
    /// Conditionally Required:
    /// - Required if the trip has a continuous pickup or drop-off behavior defined
    /// either in routes.txt or in stop_times.txt.
    /// - Optional otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ShapeId {
      get { return shapeId_; }
      set {
        shapeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "wheelchair_accessible" field.</summary>
    public const int WheelchairAccessibleFieldNumber = 9;
    private global::TransitScheduled.Trip.Types.WheelchairAccessibility wheelchairAccessible_ = global::TransitScheduled.Trip.Types.WheelchairAccessibility.NoInfo;
    /// <summary>
    /// Indicates wheelchair accessibility.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.Trip.Types.WheelchairAccessibility WheelchairAccessible {
      get { return wheelchairAccessible_; }
      set {
        wheelchairAccessible_ = value;
      }
    }

    /// <summary>Field number for the "bikes_allowed" field.</summary>
    public const int BikesAllowedFieldNumber = 10;
    private global::TransitScheduled.Trip.Types.BikeAllowance bikesAllowed_ = global::TransitScheduled.Trip.Types.BikeAllowance.NoInfo;
    /// <summary>
    /// Indicates whether bikes are allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.Trip.Types.BikeAllowance BikesAllowed {
      get { return bikesAllowed_; }
      set {
        bikesAllowed_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Trip);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Trip other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RouteId != other.RouteId) return false;
      if (ServiceId != other.ServiceId) return false;
      if (TripId != other.TripId) return false;
      if (TripHeadsign != other.TripHeadsign) return false;
      if (TripShortName != other.TripShortName) return false;
      if (DirectionId != other.DirectionId) return false;
      if (BlockId != other.BlockId) return false;
      if (ShapeId != other.ShapeId) return false;
      if (WheelchairAccessible != other.WheelchairAccessible) return false;
      if (BikesAllowed != other.BikesAllowed) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (RouteId.Length != 0) hash ^= RouteId.GetHashCode();
      if (ServiceId.Length != 0) hash ^= ServiceId.GetHashCode();
      if (TripId.Length != 0) hash ^= TripId.GetHashCode();
      if (TripHeadsign.Length != 0) hash ^= TripHeadsign.GetHashCode();
      if (TripShortName.Length != 0) hash ^= TripShortName.GetHashCode();
      if (DirectionId != global::TransitScheduled.Trip.Types.Direction.OneDirection) hash ^= DirectionId.GetHashCode();
      if (BlockId.Length != 0) hash ^= BlockId.GetHashCode();
      if (ShapeId.Length != 0) hash ^= ShapeId.GetHashCode();
      if (WheelchairAccessible != global::TransitScheduled.Trip.Types.WheelchairAccessibility.NoInfo) hash ^= WheelchairAccessible.GetHashCode();
      if (BikesAllowed != global::TransitScheduled.Trip.Types.BikeAllowance.NoInfo) hash ^= BikesAllowed.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (RouteId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RouteId);
      }
      if (ServiceId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ServiceId);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(TripId);
      }
      if (TripHeadsign.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(TripHeadsign);
      }
      if (TripShortName.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(TripShortName);
      }
      if (DirectionId != global::TransitScheduled.Trip.Types.Direction.OneDirection) {
        output.WriteRawTag(48);
        output.WriteEnum((int) DirectionId);
      }
      if (BlockId.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(BlockId);
      }
      if (ShapeId.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(ShapeId);
      }
      if (WheelchairAccessible != global::TransitScheduled.Trip.Types.WheelchairAccessibility.NoInfo) {
        output.WriteRawTag(72);
        output.WriteEnum((int) WheelchairAccessible);
      }
      if (BikesAllowed != global::TransitScheduled.Trip.Types.BikeAllowance.NoInfo) {
        output.WriteRawTag(80);
        output.WriteEnum((int) BikesAllowed);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (RouteId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RouteId);
      }
      if (ServiceId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ServiceId);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(TripId);
      }
      if (TripHeadsign.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(TripHeadsign);
      }
      if (TripShortName.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(TripShortName);
      }
      if (DirectionId != global::TransitScheduled.Trip.Types.Direction.OneDirection) {
        output.WriteRawTag(48);
        output.WriteEnum((int) DirectionId);
      }
      if (BlockId.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(BlockId);
      }
      if (ShapeId.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(ShapeId);
      }
      if (WheelchairAccessible != global::TransitScheduled.Trip.Types.WheelchairAccessibility.NoInfo) {
        output.WriteRawTag(72);
        output.WriteEnum((int) WheelchairAccessible);
      }
      if (BikesAllowed != global::TransitScheduled.Trip.Types.BikeAllowance.NoInfo) {
        output.WriteRawTag(80);
        output.WriteEnum((int) BikesAllowed);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (RouteId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteId);
      }
      if (ServiceId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceId);
      }
      if (TripId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TripId);
      }
      if (TripHeadsign.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TripHeadsign);
      }
      if (TripShortName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TripShortName);
      }
      if (DirectionId != global::TransitScheduled.Trip.Types.Direction.OneDirection) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DirectionId);
      }
      if (BlockId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BlockId);
      }
      if (ShapeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ShapeId);
      }
      if (WheelchairAccessible != global::TransitScheduled.Trip.Types.WheelchairAccessibility.NoInfo) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) WheelchairAccessible);
      }
      if (BikesAllowed != global::TransitScheduled.Trip.Types.BikeAllowance.NoInfo) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BikesAllowed);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Trip other) {
      if (other == null) {
        return;
      }
      if (other.RouteId.Length != 0) {
        RouteId = other.RouteId;
      }
      if (other.ServiceId.Length != 0) {
        ServiceId = other.ServiceId;
      }
      if (other.TripId.Length != 0) {
        TripId = other.TripId;
      }
      if (other.TripHeadsign.Length != 0) {
        TripHeadsign = other.TripHeadsign;
      }
      if (other.TripShortName.Length != 0) {
        TripShortName = other.TripShortName;
      }
      if (other.DirectionId != global::TransitScheduled.Trip.Types.Direction.OneDirection) {
        DirectionId = other.DirectionId;
      }
      if (other.BlockId.Length != 0) {
        BlockId = other.BlockId;
      }
      if (other.ShapeId.Length != 0) {
        ShapeId = other.ShapeId;
      }
      if (other.WheelchairAccessible != global::TransitScheduled.Trip.Types.WheelchairAccessibility.NoInfo) {
        WheelchairAccessible = other.WheelchairAccessible;
      }
      if (other.BikesAllowed != global::TransitScheduled.Trip.Types.BikeAllowance.NoInfo) {
        BikesAllowed = other.BikesAllowed;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RouteId = input.ReadString();
            break;
          }
          case 18: {
            ServiceId = input.ReadString();
            break;
          }
          case 26: {
            TripId = input.ReadString();
            break;
          }
          case 34: {
            TripHeadsign = input.ReadString();
            break;
          }
          case 42: {
            TripShortName = input.ReadString();
            break;
          }
          case 48: {
            DirectionId = (global::TransitScheduled.Trip.Types.Direction) input.ReadEnum();
            break;
          }
          case 58: {
            BlockId = input.ReadString();
            break;
          }
          case 66: {
            ShapeId = input.ReadString();
            break;
          }
          case 72: {
            WheelchairAccessible = (global::TransitScheduled.Trip.Types.WheelchairAccessibility) input.ReadEnum();
            break;
          }
          case 80: {
            BikesAllowed = (global::TransitScheduled.Trip.Types.BikeAllowance) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            RouteId = input.ReadString();
            break;
          }
          case 18: {
            ServiceId = input.ReadString();
            break;
          }
          case 26: {
            TripId = input.ReadString();
            break;
          }
          case 34: {
            TripHeadsign = input.ReadString();
            break;
          }
          case 42: {
            TripShortName = input.ReadString();
            break;
          }
          case 48: {
            DirectionId = (global::TransitScheduled.Trip.Types.Direction) input.ReadEnum();
            break;
          }
          case 58: {
            BlockId = input.ReadString();
            break;
          }
          case 66: {
            ShapeId = input.ReadString();
            break;
          }
          case 72: {
            WheelchairAccessible = (global::TransitScheduled.Trip.Types.WheelchairAccessibility) input.ReadEnum();
            break;
          }
          case 80: {
            BikesAllowed = (global::TransitScheduled.Trip.Types.BikeAllowance) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Trip message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Indicates the direction of travel for a trip. This field should not be used
      /// in routing; it provides a way to separate trips by direction when
      /// publishing time tables. Valid options are:
      ///   0 - Travel in one direction (e.g. outbound travel).
      ///   1 - Travel in the opposite direction (e.g. inbound travel).
      /// </summary>
      public enum Direction {
        [pbr::OriginalName("DIRECTION_ONE_DIRECTION")] OneDirection = 0,
        [pbr::OriginalName("DIRECTION_OPPOSITE")] Opposite = 1,
      }

      /// <summary>
      /// Indicates wheelchair accessibility. Valid options are:
      ///   0 or empty - No accessibility information for the trip.
      ///   1 - Vehicle being used on this particular trip can accommodate at least
      ///   one rider in a wheelchair.
      ///   2 - No riders in wheelchairs can be accommodated on this trip.
      /// </summary>
      public enum WheelchairAccessibility {
        [pbr::OriginalName("WHEELCHAIR_ACCESSIBILITY_NO_INFO")] NoInfo = 0,
        [pbr::OriginalName("WHEELCHAIR_ACCESSIBILITY_ACCESSIBLE")] Accessible = 1,
        [pbr::OriginalName("WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE")] NotAccessible = 2,
      }

      /// <summary>
      /// Indicates whether bikes are allowed. Valid options are:
      ///   0 or empty - No bike information for the trip.
      ///   1 - Vehicle being used on this particular trip can accommodate at least
      ///   one bicycle.
      ///   2 - No bicycles are allowed on this trip.
      /// </summary>
      public enum BikeAllowance {
        [pbr::OriginalName("BIKE_ALLOWANCE_NO_INFO")] NoInfo = 0,
        [pbr::OriginalName("BIKE_ALLOWANCE_ALLOWED")] Allowed = 1,
        [pbr::OriginalName("BIKE_ALLOWANCE_NOT_ALLOWED")] NotAllowed = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Times that a vehicle arrives at and departs from stops for each trip.
  /// </summary>
  public sealed partial class StopTime : pb::IMessage<StopTime>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StopTime> _parser = new pb::MessageParser<StopTime>(() => new StopTime());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StopTime> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitScheduled.GtfsScheduleReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StopTime() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StopTime(StopTime other) : this() {
      tripId_ = other.tripId_;
      arrivalTime_ = other.arrivalTime_;
      departureTime_ = other.departureTime_;
      stopId_ = other.stopId_;
      stopSequence_ = other.stopSequence_;
      stopHeadsign_ = other.stopHeadsign_;
      pickupType_ = other.pickupType_;
      dropOffType_ = other.dropOffType_;
      continuousPickup_ = other.continuousPickup_;
      continuousDropOff_ = other.continuousDropOff_;
      shapeDistTraveled_ = other.shapeDistTraveled_;
      timepoint_ = other.timepoint_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StopTime Clone() {
      return new StopTime(this);
    }

    /// <summary>Field number for the "trip_id" field.</summary>
    public const int TripIdFieldNumber = 1;
    private string tripId_ = "";
    /// <summary>
    /// Identifies a trip.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TripId {
      get { return tripId_; }
      set {
        tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "arrival_time" field.</summary>
    public const int ArrivalTimeFieldNumber = 2;
    private string arrivalTime_ = "";
    /// <summary>
    /// Arrival time at the stop (defined by stop_times.stop_id) for a specific
    /// trip (defined by stop_times.trip_id) in the time zone specified by
    /// agency.agency_timezone, not stops.stop_timezone.
    /// If there are not separate times for arrival and departure at a stop,
    /// arrival_time and departure_time should be the same.
    /// For times occurring after midnight on the service day, enter the time as a
    /// value greater than 24:00:00 in HH:MM:SS.
    /// If exact arrival and departure times (timepoint=1 or empty) are not
    /// available, estimated or interpolated arrival and departure times
    /// (timepoint=0) should be provided.
    /// Conditionally Required:
    /// - Required for the first and last stop in a trip (defined by
    /// stop_times.stop_sequence).
    /// - Required for timepoint=1.
    /// - Optional otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ArrivalTime {
      get { return arrivalTime_; }
      set {
        arrivalTime_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "departure_time" field.</summary>
    public const int DepartureTimeFieldNumber = 3;
    private string departureTime_ = "";
    /// <summary>
    /// Departure time from the stop (defined by stop_times.stop_id) for a specific
    /// trip (defined by stop_times.trip_id) in the time zone specified by
    /// agency.agency_timezone, not stops.stop_timezone.
    /// If there are not separate times for arrival and departure at a stop,
    /// arrival_time and departure_time should be the same.
    /// For times occurring after midnight on the service day, enter the time as a
    /// value greater than 24:00:00 in HH:MM:SS.
    /// If exact arrival and departure times (timepoint=1 or empty) are not
    /// available, estimated or interpolated arrival and departure times
    /// (timepoint=0) should be provided.
    /// Conditionally Required:
    /// - Required for timepoint=1.
    /// - Optional otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DepartureTime {
      get { return departureTime_; }
      set {
        departureTime_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stop_id" field.</summary>
    public const int StopIdFieldNumber = 4;
    private string stopId_ = "";
    /// <summary>
    /// Identifies the serviced stop. All stops serviced during a trip must have a
    /// record in stop_times.txt. Referenced locations must be stops/platforms,
    /// i.e. their stops.location_type value must be 0 or empty. A stop may be
    /// serviced multiple times in the same trip, and multiple trips and routes may
    /// service the same stop.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopId {
      get { return stopId_; }
      set {
        stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stop_sequence" field.</summary>
    public const int StopSequenceFieldNumber = 5;
    private uint stopSequence_;
    /// <summary>
    /// Order of stops for a particular trip. The values must increase along the
    /// trip but do not need to be consecutive.
    /// Required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint StopSequence {
      get { return stopSequence_; }
      set {
        stopSequence_ = value;
      }
    }

    /// <summary>Field number for the "stop_headsign" field.</summary>
    public const int StopHeadsignFieldNumber = 6;
    private string stopHeadsign_ = "";
    /// <summary>
    /// Text that appears on signage identifying the trip's destination to riders.
    /// This field overrides the default trips.trip_headsign when the headsign
    /// changes between stops. If the headsign is displayed for an entire trip,
    /// trips.trip_headsign should be used instead.
    /// A stop_headsign value specified for one stop_time does not apply to
    /// subsequent stop_times in the same trip. If you want to override the
    /// trip_headsign for multiple stop_times in the same trip, the stop_headsign
    /// value must be repeated in each stop_time row.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopHeadsign {
      get { return stopHeadsign_; }
      set {
        stopHeadsign_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "pickup_type" field.</summary>
    public const int PickupTypeFieldNumber = 7;
    private global::TransitScheduled.StopTime.Types.PickupType pickupType_ = global::TransitScheduled.StopTime.Types.PickupType.RegularlyScheduled;
    /// <summary>
    /// Indicates pickup method.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.StopTime.Types.PickupType PickupType {
      get { return pickupType_; }
      set {
        pickupType_ = value;
      }
    }

    /// <summary>Field number for the "drop_off_type" field.</summary>
    public const int DropOffTypeFieldNumber = 8;
    private global::TransitScheduled.StopTime.Types.DropOffType dropOffType_ = global::TransitScheduled.StopTime.Types.DropOffType.RegularlyScheduled;
    /// <summary>
    /// Indicates drop off method.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.StopTime.Types.DropOffType DropOffType {
      get { return dropOffType_; }
      set {
        dropOffType_ = value;
      }
    }

    /// <summary>Field number for the "continuous_pickup" field.</summary>
    public const int ContinuousPickupFieldNumber = 9;
    private global::TransitScheduled.ContinuousPickup continuousPickup_ = global::TransitScheduled.ContinuousPickup.Stopping;
    /// <summary>
    /// Indicates that the rider can board the transit vehicle at any point along
    /// the vehicle’s travel path as described by shapes.txt, from this stop_time
    /// to the next stop_time in the trip’s stop_sequence.
    /// If this field is populated, it overrides any continuous pickup behavior
    /// defined in routes.txt. If this field is empty, the stop_time inherits any
    /// continuous pickup behavior defined in routes.txt.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.ContinuousPickup ContinuousPickup {
      get { return continuousPickup_; }
      set {
        continuousPickup_ = value;
      }
    }

    /// <summary>Field number for the "continuous_drop_off" field.</summary>
    public const int ContinuousDropOffFieldNumber = 10;
    private global::TransitScheduled.ContinuousDropOff continuousDropOff_ = global::TransitScheduled.ContinuousDropOff.ContinuousStopping;
    /// <summary>
    /// Indicates that the rider can alight from the transit vehicle at any point
    /// along the vehicle’s travel path as described by shapes.txt, from this
    /// stop_time to the next stop_time in the trip’s stop_sequence.
    /// If this field is populated, it overrides any continuous drop-off behavior
    /// defined in routes.txt. If this field is empty, the stop_time inherits any
    /// continuous drop-off behavior defined in routes.txt.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitScheduled.ContinuousDropOff ContinuousDropOff {
      get { return continuousDropOff_; }
      set {
        continuousDropOff_ = value;
      }
    }

    /// <summary>Field number for the "shape_dist_traveled" field.</summary>
    public const int ShapeDistTraveledFieldNumber = 11;
    private float shapeDistTraveled_;
    /// <summary>
    /// Actual distance traveled along the associated shape, from the first stop to
    /// the stop specified in this record. This field specifies how much of the
    /// shape to draw between any two stops during a trip. Must be in the same
    /// units used in shapes.txt. Values used for shape_dist_traveled must increase
    /// along with stop_sequence; they must not be used to show reverse travel
    /// along a route.
    /// Recommended for routes that have looping or inlining (the vehicle crosses
    /// or travels over the same portion of alignment in one trip). See
    /// shapes.shape_dist_traveled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float ShapeDistTraveled {
      get { return shapeDistTraveled_; }
      set {
        shapeDistTraveled_ = value;
      }
    }

    /// <summary>Field number for the "timepoint" field.</summary>
    public const int TimepointFieldNumber = 12;
    private uint timepoint_;
    /// <summary>
    /// Indicates if arrival and departure times for a stop are strictly adhered to
    /// by the vehicle or if they are instead approximate and/or interpolated
    /// times. This field allows a GTFS producer to provide interpolated
    /// stop-times, while indicating that the times are approximate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Timepoint {
      get { return timepoint_; }
      set {
        timepoint_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StopTime);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StopTime other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TripId != other.TripId) return false;
      if (ArrivalTime != other.ArrivalTime) return false;
      if (DepartureTime != other.DepartureTime) return false;
      if (StopId != other.StopId) return false;
      if (StopSequence != other.StopSequence) return false;
      if (StopHeadsign != other.StopHeadsign) return false;
      if (PickupType != other.PickupType) return false;
      if (DropOffType != other.DropOffType) return false;
      if (ContinuousPickup != other.ContinuousPickup) return false;
      if (ContinuousDropOff != other.ContinuousDropOff) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ShapeDistTraveled, other.ShapeDistTraveled)) return false;
      if (Timepoint != other.Timepoint) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (TripId.Length != 0) hash ^= TripId.GetHashCode();
      if (ArrivalTime.Length != 0) hash ^= ArrivalTime.GetHashCode();
      if (DepartureTime.Length != 0) hash ^= DepartureTime.GetHashCode();
      if (StopId.Length != 0) hash ^= StopId.GetHashCode();
      if (StopSequence != 0) hash ^= StopSequence.GetHashCode();
      if (StopHeadsign.Length != 0) hash ^= StopHeadsign.GetHashCode();
      if (PickupType != global::TransitScheduled.StopTime.Types.PickupType.RegularlyScheduled) hash ^= PickupType.GetHashCode();
      if (DropOffType != global::TransitScheduled.StopTime.Types.DropOffType.RegularlyScheduled) hash ^= DropOffType.GetHashCode();
      if (ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) hash ^= ContinuousPickup.GetHashCode();
      if (ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) hash ^= ContinuousDropOff.GetHashCode();
      if (ShapeDistTraveled != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ShapeDistTraveled);
      if (Timepoint != 0) hash ^= Timepoint.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TripId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(TripId);
      }
      if (ArrivalTime.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ArrivalTime);
      }
      if (DepartureTime.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DepartureTime);
      }
      if (StopId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(StopId);
      }
      if (StopSequence != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(StopSequence);
      }
      if (StopHeadsign.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(StopHeadsign);
      }
      if (PickupType != global::TransitScheduled.StopTime.Types.PickupType.RegularlyScheduled) {
        output.WriteRawTag(56);
        output.WriteEnum((int) PickupType);
      }
      if (DropOffType != global::TransitScheduled.StopTime.Types.DropOffType.RegularlyScheduled) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DropOffType);
      }
      if (ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) {
        output.WriteRawTag(72);
        output.WriteEnum((int) ContinuousPickup);
      }
      if (ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) {
        output.WriteRawTag(80);
        output.WriteEnum((int) ContinuousDropOff);
      }
      if (ShapeDistTraveled != 0F) {
        output.WriteRawTag(93);
        output.WriteFloat(ShapeDistTraveled);
      }
      if (Timepoint != 0) {
        output.WriteRawTag(96);
        output.WriteUInt32(Timepoint);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TripId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(TripId);
      }
      if (ArrivalTime.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ArrivalTime);
      }
      if (DepartureTime.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DepartureTime);
      }
      if (StopId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(StopId);
      }
      if (StopSequence != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(StopSequence);
      }
      if (StopHeadsign.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(StopHeadsign);
      }
      if (PickupType != global::TransitScheduled.StopTime.Types.PickupType.RegularlyScheduled) {
        output.WriteRawTag(56);
        output.WriteEnum((int) PickupType);
      }
      if (DropOffType != global::TransitScheduled.StopTime.Types.DropOffType.RegularlyScheduled) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DropOffType);
      }
      if (ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) {
        output.WriteRawTag(72);
        output.WriteEnum((int) ContinuousPickup);
      }
      if (ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) {
        output.WriteRawTag(80);
        output.WriteEnum((int) ContinuousDropOff);
      }
      if (ShapeDistTraveled != 0F) {
        output.WriteRawTag(93);
        output.WriteFloat(ShapeDistTraveled);
      }
      if (Timepoint != 0) {
        output.WriteRawTag(96);
        output.WriteUInt32(Timepoint);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (TripId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TripId);
      }
      if (ArrivalTime.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ArrivalTime);
      }
      if (DepartureTime.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DepartureTime);
      }
      if (StopId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
      }
      if (StopSequence != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StopSequence);
      }
      if (StopHeadsign.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopHeadsign);
      }
      if (PickupType != global::TransitScheduled.StopTime.Types.PickupType.RegularlyScheduled) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PickupType);
      }
      if (DropOffType != global::TransitScheduled.StopTime.Types.DropOffType.RegularlyScheduled) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DropOffType);
      }
      if (ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ContinuousPickup);
      }
      if (ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ContinuousDropOff);
      }
      if (ShapeDistTraveled != 0F) {
        size += 1 + 4;
      }
      if (Timepoint != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Timepoint);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StopTime other) {
      if (other == null) {
        return;
      }
      if (other.TripId.Length != 0) {
        TripId = other.TripId;
      }
      if (other.ArrivalTime.Length != 0) {
        ArrivalTime = other.ArrivalTime;
      }
      if (other.DepartureTime.Length != 0) {
        DepartureTime = other.DepartureTime;
      }
      if (other.StopId.Length != 0) {
        StopId = other.StopId;
      }
      if (other.StopSequence != 0) {
        StopSequence = other.StopSequence;
      }
      if (other.StopHeadsign.Length != 0) {
        StopHeadsign = other.StopHeadsign;
      }
      if (other.PickupType != global::TransitScheduled.StopTime.Types.PickupType.RegularlyScheduled) {
        PickupType = other.PickupType;
      }
      if (other.DropOffType != global::TransitScheduled.StopTime.Types.DropOffType.RegularlyScheduled) {
        DropOffType = other.DropOffType;
      }
      if (other.ContinuousPickup != global::TransitScheduled.ContinuousPickup.Stopping) {
        ContinuousPickup = other.ContinuousPickup;
      }
      if (other.ContinuousDropOff != global::TransitScheduled.ContinuousDropOff.ContinuousStopping) {
        ContinuousDropOff = other.ContinuousDropOff;
      }
      if (other.ShapeDistTraveled != 0F) {
        ShapeDistTraveled = other.ShapeDistTraveled;
      }
      if (other.Timepoint != 0) {
        Timepoint = other.Timepoint;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            TripId = input.ReadString();
            break;
          }
          case 18: {
            ArrivalTime = input.ReadString();
            break;
          }
          case 26: {
            DepartureTime = input.ReadString();
            break;
          }
          case 34: {
            StopId = input.ReadString();
            break;
          }
          case 40: {
            StopSequence = input.ReadUInt32();
            break;
          }
          case 50: {
            StopHeadsign = input.ReadString();
            break;
          }
          case 56: {
            PickupType = (global::TransitScheduled.StopTime.Types.PickupType) input.ReadEnum();
            break;
          }
          case 64: {
            DropOffType = (global::TransitScheduled.StopTime.Types.DropOffType) input.ReadEnum();
            break;
          }
          case 72: {
            ContinuousPickup = (global::TransitScheduled.ContinuousPickup) input.ReadEnum();
            break;
          }
          case 80: {
            ContinuousDropOff = (global::TransitScheduled.ContinuousDropOff) input.ReadEnum();
            break;
          }
          case 93: {
            ShapeDistTraveled = input.ReadFloat();
            break;
          }
          case 96: {
            Timepoint = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            TripId = input.ReadString();
            break;
          }
          case 18: {
            ArrivalTime = input.ReadString();
            break;
          }
          case 26: {
            DepartureTime = input.ReadString();
            break;
          }
          case 34: {
            StopId = input.ReadString();
            break;
          }
          case 40: {
            StopSequence = input.ReadUInt32();
            break;
          }
          case 50: {
            StopHeadsign = input.ReadString();
            break;
          }
          case 56: {
            PickupType = (global::TransitScheduled.StopTime.Types.PickupType) input.ReadEnum();
            break;
          }
          case 64: {
            DropOffType = (global::TransitScheduled.StopTime.Types.DropOffType) input.ReadEnum();
            break;
          }
          case 72: {
            ContinuousPickup = (global::TransitScheduled.ContinuousPickup) input.ReadEnum();
            break;
          }
          case 80: {
            ContinuousDropOff = (global::TransitScheduled.ContinuousDropOff) input.ReadEnum();
            break;
          }
          case 93: {
            ShapeDistTraveled = input.ReadFloat();
            break;
          }
          case 96: {
            Timepoint = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StopTime message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Indicates pickup method. Valid options are:
      ///   0 or empty - Regularly scheduled pickup.
      ///   1 - No pickup available.
      ///   2 - Must phone agency to arrange pickup.
      ///   3 - Must coordinate with driver to arrange pickup.
      /// </summary>
      public enum PickupType {
        [pbr::OriginalName("PICKUP_TYPE_REGULARLY_SCHEDULED")] RegularlyScheduled = 0,
        [pbr::OriginalName("PICKUP_TYPE_NONE_AVAILABLE")] NoneAvailable = 1,
        [pbr::OriginalName("PICKUP_TYPE_MUST_PHONE_AGENCY")] MustPhoneAgency = 2,
        [pbr::OriginalName("PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER")] MustCoordinateWithDriver = 3,
      }

      /// <summary>
      /// Indicates drop off method. Valid options are:
      ///   0 or empty - Regularly scheduled drop off.
      ///   1 - No drop off available.
      ///   2 - Must phone agency to arrange drop off.
      ///   3 - Must coordinate with driver to arrange drop off.
      /// </summary>
      public enum DropOffType {
        [pbr::OriginalName("DROP_OFF_TYPE_REGULARLY_SCHEDULED")] RegularlyScheduled = 0,
        [pbr::OriginalName("DROP_OFF_TYPE_NONE_AVAILABLE")] NoneAvailable = 1,
        [pbr::OriginalName("DROP_OFF_TYPE_MUST_PHONE_AGENCY")] MustPhoneAgency = 2,
        [pbr::OriginalName("DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER")] MustCoordinateWithDriver = 3,
      }

      /// <summary>
      /// Indicates if arrival and departure times for a stop are strictly adhered to
      /// by the vehicle or if they are instead approximate and/or interpolated
      /// times. This field allows a GTFS producer to provide interpolated
      /// stop-times, while indicating that the times are approximate.
      /// Valid options are:
      ///   0 - Times are considered approximate.
      ///   1 or empty - Times are considered exact.
      /// </summary>
      public enum TimePoint {
        [pbr::OriginalName("TIME_POINT_APPROXIMATE")] Approximate = 0,
        [pbr::OriginalName("TIME_POINT_EXACT")] Exact = 1,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
