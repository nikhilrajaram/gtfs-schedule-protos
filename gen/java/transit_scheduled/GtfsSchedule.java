// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/v1/gtfs-schedule.proto

package transit_scheduled;

public final class GtfsSchedule {
  private GtfsSchedule() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * Indicates that the rider can board the transit vehicle at any point along the
   * vehicle’s travel path as described by shapes.txt.
   * Valid options are:
   *   0 - Continuous stopping pickup.
   *   1 or empty - No continuous stopping pickup.
   *   2 - Must phone agency to arrange continuous stopping pickup.
   *   3 - Must coordinate with driver to arrange continuous stopping pickup.
   * </pre>
   *
   * Protobuf enum {@code transit_scheduled.ContinuousPickup}
   */
  public enum ContinuousPickup
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>CONTINUOUS_PICKUP_STOPPING = 0;</code>
     */
    CONTINUOUS_PICKUP_STOPPING(0),
    /**
     * <code>CONTINUOUS_PICKUP_NO_CONTINUOUS_STOPPING = 1;</code>
     */
    CONTINUOUS_PICKUP_NO_CONTINUOUS_STOPPING(1),
    /**
     * <code>CONTINUOUS_PICKUP_MUST_PHONE_AGENCY = 2;</code>
     */
    CONTINUOUS_PICKUP_MUST_PHONE_AGENCY(2),
    /**
     * <code>CONTINUOUS_PICKUP_MUST_COORDINATE_WITH_DRIVER = 3;</code>
     */
    CONTINUOUS_PICKUP_MUST_COORDINATE_WITH_DRIVER(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>CONTINUOUS_PICKUP_STOPPING = 0;</code>
     */
    public static final int CONTINUOUS_PICKUP_STOPPING_VALUE = 0;
    /**
     * <code>CONTINUOUS_PICKUP_NO_CONTINUOUS_STOPPING = 1;</code>
     */
    public static final int CONTINUOUS_PICKUP_NO_CONTINUOUS_STOPPING_VALUE = 1;
    /**
     * <code>CONTINUOUS_PICKUP_MUST_PHONE_AGENCY = 2;</code>
     */
    public static final int CONTINUOUS_PICKUP_MUST_PHONE_AGENCY_VALUE = 2;
    /**
     * <code>CONTINUOUS_PICKUP_MUST_COORDINATE_WITH_DRIVER = 3;</code>
     */
    public static final int CONTINUOUS_PICKUP_MUST_COORDINATE_WITH_DRIVER_VALUE = 3;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ContinuousPickup valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ContinuousPickup forNumber(int value) {
      switch (value) {
        case 0: return CONTINUOUS_PICKUP_STOPPING;
        case 1: return CONTINUOUS_PICKUP_NO_CONTINUOUS_STOPPING;
        case 2: return CONTINUOUS_PICKUP_MUST_PHONE_AGENCY;
        case 3: return CONTINUOUS_PICKUP_MUST_COORDINATE_WITH_DRIVER;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ContinuousPickup>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ContinuousPickup> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ContinuousPickup>() {
            public ContinuousPickup findValueByNumber(int number) {
              return ContinuousPickup.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return transit_scheduled.GtfsSchedule.getDescriptor().getEnumTypes().get(0);
    }

    private static final ContinuousPickup[] VALUES = values();

    public static ContinuousPickup valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ContinuousPickup(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:transit_scheduled.ContinuousPickup)
  }

  /**
   * <pre>
   * Indicates that the rider can alight from the transit vehicle at any point
   * along the vehicle’s travel path as described by shapes.txt, on every trip
   * of the route.
   * </pre>
   *
   * Protobuf enum {@code transit_scheduled.ContinuousDropOff}
   */
  public enum ContinuousDropOff
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING = 0;</code>
     */
    CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING(0),
    /**
     * <code>CONTINUOUS_DROP_OFF_NO_CONTINUOUS_STOPPING = 1;</code>
     */
    CONTINUOUS_DROP_OFF_NO_CONTINUOUS_STOPPING(1),
    /**
     * <code>CONTINUOUS_DROP_OFF_MUST_PHONE_AGENCY = 2;</code>
     */
    CONTINUOUS_DROP_OFF_MUST_PHONE_AGENCY(2),
    /**
     * <code>CONTINUOUS_DROP_OFF_MUST_COORDINATE_WITH_DRIVER = 3;</code>
     */
    CONTINUOUS_DROP_OFF_MUST_COORDINATE_WITH_DRIVER(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING = 0;</code>
     */
    public static final int CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING_VALUE = 0;
    /**
     * <code>CONTINUOUS_DROP_OFF_NO_CONTINUOUS_STOPPING = 1;</code>
     */
    public static final int CONTINUOUS_DROP_OFF_NO_CONTINUOUS_STOPPING_VALUE = 1;
    /**
     * <code>CONTINUOUS_DROP_OFF_MUST_PHONE_AGENCY = 2;</code>
     */
    public static final int CONTINUOUS_DROP_OFF_MUST_PHONE_AGENCY_VALUE = 2;
    /**
     * <code>CONTINUOUS_DROP_OFF_MUST_COORDINATE_WITH_DRIVER = 3;</code>
     */
    public static final int CONTINUOUS_DROP_OFF_MUST_COORDINATE_WITH_DRIVER_VALUE = 3;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ContinuousDropOff valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ContinuousDropOff forNumber(int value) {
      switch (value) {
        case 0: return CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING;
        case 1: return CONTINUOUS_DROP_OFF_NO_CONTINUOUS_STOPPING;
        case 2: return CONTINUOUS_DROP_OFF_MUST_PHONE_AGENCY;
        case 3: return CONTINUOUS_DROP_OFF_MUST_COORDINATE_WITH_DRIVER;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ContinuousDropOff>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ContinuousDropOff> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ContinuousDropOff>() {
            public ContinuousDropOff findValueByNumber(int number) {
              return ContinuousDropOff.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return transit_scheduled.GtfsSchedule.getDescriptor().getEnumTypes().get(1);
    }

    private static final ContinuousDropOff[] VALUES = values();

    public static ContinuousDropOff valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ContinuousDropOff(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:transit_scheduled.ContinuousDropOff)
  }

  public interface AgencyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_scheduled.Agency)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Identifies a transit brand which is often synonymous with a transit agency.
     * Note that in some cases, such as when a single agency operates multiple
     * separate services, agencies and brands are distinct. This document uses the
     * term "agency" in place of "brand". A dataset may contain data from multiple
     * agencies.
     * Conditionally Required:
     * - Required when the dataset contains data for multiple transit agencies.
     * - Recommended otherwise.
     * </pre>
     *
     * <code>string agency_id = 1;</code>
     * @return The agencyId.
     */
    java.lang.String getAgencyId();
    /**
     * <pre>
     * Identifies a transit brand which is often synonymous with a transit agency.
     * Note that in some cases, such as when a single agency operates multiple
     * separate services, agencies and brands are distinct. This document uses the
     * term "agency" in place of "brand". A dataset may contain data from multiple
     * agencies.
     * Conditionally Required:
     * - Required when the dataset contains data for multiple transit agencies.
     * - Recommended otherwise.
     * </pre>
     *
     * <code>string agency_id = 1;</code>
     * @return The bytes for agencyId.
     */
    com.google.protobuf.ByteString
        getAgencyIdBytes();

    /**
     * <pre>
     * Full name of the transit agency.
     * Required
     * </pre>
     *
     * <code>string agency_name = 2;</code>
     * @return The agencyName.
     */
    java.lang.String getAgencyName();
    /**
     * <pre>
     * Full name of the transit agency.
     * Required
     * </pre>
     *
     * <code>string agency_name = 2;</code>
     * @return The bytes for agencyName.
     */
    com.google.protobuf.ByteString
        getAgencyNameBytes();

    /**
     * <pre>
     * URL of the transit agency.
     * Required
     * </pre>
     *
     * <code>string agency_url = 3;</code>
     * @return The agencyUrl.
     */
    java.lang.String getAgencyUrl();
    /**
     * <pre>
     * URL of the transit agency.
     * Required
     * </pre>
     *
     * <code>string agency_url = 3;</code>
     * @return The bytes for agencyUrl.
     */
    com.google.protobuf.ByteString
        getAgencyUrlBytes();

    /**
     * <pre>
     * Timezone where the transit agency is located. If multiple agencies are
     * specified in the dataset, each must have the same agency_timezone.
     * Required
     * </pre>
     *
     * <code>string agency_timezone = 4;</code>
     * @return The agencyTimezone.
     */
    java.lang.String getAgencyTimezone();
    /**
     * <pre>
     * Timezone where the transit agency is located. If multiple agencies are
     * specified in the dataset, each must have the same agency_timezone.
     * Required
     * </pre>
     *
     * <code>string agency_timezone = 4;</code>
     * @return The bytes for agencyTimezone.
     */
    com.google.protobuf.ByteString
        getAgencyTimezoneBytes();

    /**
     * <pre>
     * Primary language used by this transit agency. Should be provided to help
     * GTFS consumers choose capitalization rules and other language-specific
     * settings for the dataset.
     * </pre>
     *
     * <code>string agency_lang = 5;</code>
     * @return The agencyLang.
     */
    java.lang.String getAgencyLang();
    /**
     * <pre>
     * Primary language used by this transit agency. Should be provided to help
     * GTFS consumers choose capitalization rules and other language-specific
     * settings for the dataset.
     * </pre>
     *
     * <code>string agency_lang = 5;</code>
     * @return The bytes for agencyLang.
     */
    com.google.protobuf.ByteString
        getAgencyLangBytes();

    /**
     * <pre>
     * A voice telephone number for the specified agency. This field is a string
     * value that presents the telephone number as typical for the agency's
     * service area. It may contain punctuation marks to group the digits of the
     * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
     * but the field must not contain any other descriptive text.
     * </pre>
     *
     * <code>string agency_phone = 6;</code>
     * @return The agencyPhone.
     */
    java.lang.String getAgencyPhone();
    /**
     * <pre>
     * A voice telephone number for the specified agency. This field is a string
     * value that presents the telephone number as typical for the agency's
     * service area. It may contain punctuation marks to group the digits of the
     * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
     * but the field must not contain any other descriptive text.
     * </pre>
     *
     * <code>string agency_phone = 6;</code>
     * @return The bytes for agencyPhone.
     */
    com.google.protobuf.ByteString
        getAgencyPhoneBytes();

    /**
     * <pre>
     * URL of a web page that allows a rider to purchase tickets or other fare
     * instruments for that agency online.
     * </pre>
     *
     * <code>string agency_fare_url = 7;</code>
     * @return The agencyFareUrl.
     */
    java.lang.String getAgencyFareUrl();
    /**
     * <pre>
     * URL of a web page that allows a rider to purchase tickets or other fare
     * instruments for that agency online.
     * </pre>
     *
     * <code>string agency_fare_url = 7;</code>
     * @return The bytes for agencyFareUrl.
     */
    com.google.protobuf.ByteString
        getAgencyFareUrlBytes();

    /**
     * <pre>
     * Email address actively monitored by the agency’s customer service
     * department. This email address should be a direct contact point where
     * transit riders can reach a customer service representative at the agency.
     * </pre>
     *
     * <code>string agency_email = 8;</code>
     * @return The agencyEmail.
     */
    java.lang.String getAgencyEmail();
    /**
     * <pre>
     * Email address actively monitored by the agency’s customer service
     * department. This email address should be a direct contact point where
     * transit riders can reach a customer service representative at the agency.
     * </pre>
     *
     * <code>string agency_email = 8;</code>
     * @return The bytes for agencyEmail.
     */
    com.google.protobuf.ByteString
        getAgencyEmailBytes();
  }
  /**
   * <pre>
   * Transit agencies with service represented in this dataset.
   * </pre>
   *
   * Protobuf type {@code transit_scheduled.Agency}
   */
  public static final class Agency extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:transit_scheduled.Agency)
      AgencyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Agency.newBuilder() to construct.
    private Agency(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Agency() {
      agencyId_ = "";
      agencyName_ = "";
      agencyUrl_ = "";
      agencyTimezone_ = "";
      agencyLang_ = "";
      agencyPhone_ = "";
      agencyFareUrl_ = "";
      agencyEmail_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Agency();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Agency_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Agency_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              transit_scheduled.GtfsSchedule.Agency.class, transit_scheduled.GtfsSchedule.Agency.Builder.class);
    }

    public static final int AGENCY_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object agencyId_;
    /**
     * <pre>
     * Identifies a transit brand which is often synonymous with a transit agency.
     * Note that in some cases, such as when a single agency operates multiple
     * separate services, agencies and brands are distinct. This document uses the
     * term "agency" in place of "brand". A dataset may contain data from multiple
     * agencies.
     * Conditionally Required:
     * - Required when the dataset contains data for multiple transit agencies.
     * - Recommended otherwise.
     * </pre>
     *
     * <code>string agency_id = 1;</code>
     * @return The agencyId.
     */
    @java.lang.Override
    public java.lang.String getAgencyId() {
      java.lang.Object ref = agencyId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agencyId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies a transit brand which is often synonymous with a transit agency.
     * Note that in some cases, such as when a single agency operates multiple
     * separate services, agencies and brands are distinct. This document uses the
     * term "agency" in place of "brand". A dataset may contain data from multiple
     * agencies.
     * Conditionally Required:
     * - Required when the dataset contains data for multiple transit agencies.
     * - Recommended otherwise.
     * </pre>
     *
     * <code>string agency_id = 1;</code>
     * @return The bytes for agencyId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyIdBytes() {
      java.lang.Object ref = agencyId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENCY_NAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object agencyName_;
    /**
     * <pre>
     * Full name of the transit agency.
     * Required
     * </pre>
     *
     * <code>string agency_name = 2;</code>
     * @return The agencyName.
     */
    @java.lang.Override
    public java.lang.String getAgencyName() {
      java.lang.Object ref = agencyName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agencyName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Full name of the transit agency.
     * Required
     * </pre>
     *
     * <code>string agency_name = 2;</code>
     * @return The bytes for agencyName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyNameBytes() {
      java.lang.Object ref = agencyName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENCY_URL_FIELD_NUMBER = 3;
    private volatile java.lang.Object agencyUrl_;
    /**
     * <pre>
     * URL of the transit agency.
     * Required
     * </pre>
     *
     * <code>string agency_url = 3;</code>
     * @return The agencyUrl.
     */
    @java.lang.Override
    public java.lang.String getAgencyUrl() {
      java.lang.Object ref = agencyUrl_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agencyUrl_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * URL of the transit agency.
     * Required
     * </pre>
     *
     * <code>string agency_url = 3;</code>
     * @return The bytes for agencyUrl.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyUrlBytes() {
      java.lang.Object ref = agencyUrl_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyUrl_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENCY_TIMEZONE_FIELD_NUMBER = 4;
    private volatile java.lang.Object agencyTimezone_;
    /**
     * <pre>
     * Timezone where the transit agency is located. If multiple agencies are
     * specified in the dataset, each must have the same agency_timezone.
     * Required
     * </pre>
     *
     * <code>string agency_timezone = 4;</code>
     * @return The agencyTimezone.
     */
    @java.lang.Override
    public java.lang.String getAgencyTimezone() {
      java.lang.Object ref = agencyTimezone_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agencyTimezone_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Timezone where the transit agency is located. If multiple agencies are
     * specified in the dataset, each must have the same agency_timezone.
     * Required
     * </pre>
     *
     * <code>string agency_timezone = 4;</code>
     * @return The bytes for agencyTimezone.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyTimezoneBytes() {
      java.lang.Object ref = agencyTimezone_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyTimezone_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENCY_LANG_FIELD_NUMBER = 5;
    private volatile java.lang.Object agencyLang_;
    /**
     * <pre>
     * Primary language used by this transit agency. Should be provided to help
     * GTFS consumers choose capitalization rules and other language-specific
     * settings for the dataset.
     * </pre>
     *
     * <code>string agency_lang = 5;</code>
     * @return The agencyLang.
     */
    @java.lang.Override
    public java.lang.String getAgencyLang() {
      java.lang.Object ref = agencyLang_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agencyLang_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Primary language used by this transit agency. Should be provided to help
     * GTFS consumers choose capitalization rules and other language-specific
     * settings for the dataset.
     * </pre>
     *
     * <code>string agency_lang = 5;</code>
     * @return The bytes for agencyLang.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyLangBytes() {
      java.lang.Object ref = agencyLang_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyLang_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENCY_PHONE_FIELD_NUMBER = 6;
    private volatile java.lang.Object agencyPhone_;
    /**
     * <pre>
     * A voice telephone number for the specified agency. This field is a string
     * value that presents the telephone number as typical for the agency's
     * service area. It may contain punctuation marks to group the digits of the
     * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
     * but the field must not contain any other descriptive text.
     * </pre>
     *
     * <code>string agency_phone = 6;</code>
     * @return The agencyPhone.
     */
    @java.lang.Override
    public java.lang.String getAgencyPhone() {
      java.lang.Object ref = agencyPhone_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agencyPhone_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A voice telephone number for the specified agency. This field is a string
     * value that presents the telephone number as typical for the agency's
     * service area. It may contain punctuation marks to group the digits of the
     * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
     * but the field must not contain any other descriptive text.
     * </pre>
     *
     * <code>string agency_phone = 6;</code>
     * @return The bytes for agencyPhone.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyPhoneBytes() {
      java.lang.Object ref = agencyPhone_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyPhone_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENCY_FARE_URL_FIELD_NUMBER = 7;
    private volatile java.lang.Object agencyFareUrl_;
    /**
     * <pre>
     * URL of a web page that allows a rider to purchase tickets or other fare
     * instruments for that agency online.
     * </pre>
     *
     * <code>string agency_fare_url = 7;</code>
     * @return The agencyFareUrl.
     */
    @java.lang.Override
    public java.lang.String getAgencyFareUrl() {
      java.lang.Object ref = agencyFareUrl_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agencyFareUrl_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * URL of a web page that allows a rider to purchase tickets or other fare
     * instruments for that agency online.
     * </pre>
     *
     * <code>string agency_fare_url = 7;</code>
     * @return The bytes for agencyFareUrl.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyFareUrlBytes() {
      java.lang.Object ref = agencyFareUrl_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyFareUrl_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENCY_EMAIL_FIELD_NUMBER = 8;
    private volatile java.lang.Object agencyEmail_;
    /**
     * <pre>
     * Email address actively monitored by the agency’s customer service
     * department. This email address should be a direct contact point where
     * transit riders can reach a customer service representative at the agency.
     * </pre>
     *
     * <code>string agency_email = 8;</code>
     * @return The agencyEmail.
     */
    @java.lang.Override
    public java.lang.String getAgencyEmail() {
      java.lang.Object ref = agencyEmail_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agencyEmail_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Email address actively monitored by the agency’s customer service
     * department. This email address should be a direct contact point where
     * transit riders can reach a customer service representative at the agency.
     * </pre>
     *
     * <code>string agency_email = 8;</code>
     * @return The bytes for agencyEmail.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyEmailBytes() {
      java.lang.Object ref = agencyEmail_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyEmail_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, agencyId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyName_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, agencyName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyUrl_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, agencyUrl_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyTimezone_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, agencyTimezone_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyLang_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, agencyLang_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyPhone_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, agencyPhone_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyFareUrl_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, agencyFareUrl_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyEmail_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, agencyEmail_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, agencyId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyName_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, agencyName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyUrl_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, agencyUrl_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyTimezone_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, agencyTimezone_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyLang_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, agencyLang_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyPhone_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, agencyPhone_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyFareUrl_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, agencyFareUrl_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyEmail_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, agencyEmail_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof transit_scheduled.GtfsSchedule.Agency)) {
        return super.equals(obj);
      }
      transit_scheduled.GtfsSchedule.Agency other = (transit_scheduled.GtfsSchedule.Agency) obj;

      if (!getAgencyId()
          .equals(other.getAgencyId())) return false;
      if (!getAgencyName()
          .equals(other.getAgencyName())) return false;
      if (!getAgencyUrl()
          .equals(other.getAgencyUrl())) return false;
      if (!getAgencyTimezone()
          .equals(other.getAgencyTimezone())) return false;
      if (!getAgencyLang()
          .equals(other.getAgencyLang())) return false;
      if (!getAgencyPhone()
          .equals(other.getAgencyPhone())) return false;
      if (!getAgencyFareUrl()
          .equals(other.getAgencyFareUrl())) return false;
      if (!getAgencyEmail()
          .equals(other.getAgencyEmail())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + AGENCY_ID_FIELD_NUMBER;
      hash = (53 * hash) + getAgencyId().hashCode();
      hash = (37 * hash) + AGENCY_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getAgencyName().hashCode();
      hash = (37 * hash) + AGENCY_URL_FIELD_NUMBER;
      hash = (53 * hash) + getAgencyUrl().hashCode();
      hash = (37 * hash) + AGENCY_TIMEZONE_FIELD_NUMBER;
      hash = (53 * hash) + getAgencyTimezone().hashCode();
      hash = (37 * hash) + AGENCY_LANG_FIELD_NUMBER;
      hash = (53 * hash) + getAgencyLang().hashCode();
      hash = (37 * hash) + AGENCY_PHONE_FIELD_NUMBER;
      hash = (53 * hash) + getAgencyPhone().hashCode();
      hash = (37 * hash) + AGENCY_FARE_URL_FIELD_NUMBER;
      hash = (53 * hash) + getAgencyFareUrl().hashCode();
      hash = (37 * hash) + AGENCY_EMAIL_FIELD_NUMBER;
      hash = (53 * hash) + getAgencyEmail().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static transit_scheduled.GtfsSchedule.Agency parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Agency parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(transit_scheduled.GtfsSchedule.Agency prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Transit agencies with service represented in this dataset.
     * </pre>
     *
     * Protobuf type {@code transit_scheduled.Agency}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_scheduled.Agency)
        transit_scheduled.GtfsSchedule.AgencyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Agency_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Agency_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                transit_scheduled.GtfsSchedule.Agency.class, transit_scheduled.GtfsSchedule.Agency.Builder.class);
      }

      // Construct using transit_scheduled.GtfsSchedule.Agency.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        agencyId_ = "";

        agencyName_ = "";

        agencyUrl_ = "";

        agencyTimezone_ = "";

        agencyLang_ = "";

        agencyPhone_ = "";

        agencyFareUrl_ = "";

        agencyEmail_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Agency_descriptor;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Agency getDefaultInstanceForType() {
        return transit_scheduled.GtfsSchedule.Agency.getDefaultInstance();
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Agency build() {
        transit_scheduled.GtfsSchedule.Agency result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Agency buildPartial() {
        transit_scheduled.GtfsSchedule.Agency result = new transit_scheduled.GtfsSchedule.Agency(this);
        result.agencyId_ = agencyId_;
        result.agencyName_ = agencyName_;
        result.agencyUrl_ = agencyUrl_;
        result.agencyTimezone_ = agencyTimezone_;
        result.agencyLang_ = agencyLang_;
        result.agencyPhone_ = agencyPhone_;
        result.agencyFareUrl_ = agencyFareUrl_;
        result.agencyEmail_ = agencyEmail_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof transit_scheduled.GtfsSchedule.Agency) {
          return mergeFrom((transit_scheduled.GtfsSchedule.Agency)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(transit_scheduled.GtfsSchedule.Agency other) {
        if (other == transit_scheduled.GtfsSchedule.Agency.getDefaultInstance()) return this;
        if (!other.getAgencyId().isEmpty()) {
          agencyId_ = other.agencyId_;
          onChanged();
        }
        if (!other.getAgencyName().isEmpty()) {
          agencyName_ = other.agencyName_;
          onChanged();
        }
        if (!other.getAgencyUrl().isEmpty()) {
          agencyUrl_ = other.agencyUrl_;
          onChanged();
        }
        if (!other.getAgencyTimezone().isEmpty()) {
          agencyTimezone_ = other.agencyTimezone_;
          onChanged();
        }
        if (!other.getAgencyLang().isEmpty()) {
          agencyLang_ = other.agencyLang_;
          onChanged();
        }
        if (!other.getAgencyPhone().isEmpty()) {
          agencyPhone_ = other.agencyPhone_;
          onChanged();
        }
        if (!other.getAgencyFareUrl().isEmpty()) {
          agencyFareUrl_ = other.agencyFareUrl_;
          onChanged();
        }
        if (!other.getAgencyEmail().isEmpty()) {
          agencyEmail_ = other.agencyEmail_;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                agencyId_ = input.readStringRequireUtf8();

                break;
              } // case 10
              case 18: {
                agencyName_ = input.readStringRequireUtf8();

                break;
              } // case 18
              case 26: {
                agencyUrl_ = input.readStringRequireUtf8();

                break;
              } // case 26
              case 34: {
                agencyTimezone_ = input.readStringRequireUtf8();

                break;
              } // case 34
              case 42: {
                agencyLang_ = input.readStringRequireUtf8();

                break;
              } // case 42
              case 50: {
                agencyPhone_ = input.readStringRequireUtf8();

                break;
              } // case 50
              case 58: {
                agencyFareUrl_ = input.readStringRequireUtf8();

                break;
              } // case 58
              case 66: {
                agencyEmail_ = input.readStringRequireUtf8();

                break;
              } // case 66
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private java.lang.Object agencyId_ = "";
      /**
       * <pre>
       * Identifies a transit brand which is often synonymous with a transit agency.
       * Note that in some cases, such as when a single agency operates multiple
       * separate services, agencies and brands are distinct. This document uses the
       * term "agency" in place of "brand". A dataset may contain data from multiple
       * agencies.
       * Conditionally Required:
       * - Required when the dataset contains data for multiple transit agencies.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 1;</code>
       * @return The agencyId.
       */
      public java.lang.String getAgencyId() {
        java.lang.Object ref = agencyId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agencyId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies a transit brand which is often synonymous with a transit agency.
       * Note that in some cases, such as when a single agency operates multiple
       * separate services, agencies and brands are distinct. This document uses the
       * term "agency" in place of "brand". A dataset may contain data from multiple
       * agencies.
       * Conditionally Required:
       * - Required when the dataset contains data for multiple transit agencies.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 1;</code>
       * @return The bytes for agencyId.
       */
      public com.google.protobuf.ByteString
          getAgencyIdBytes() {
        java.lang.Object ref = agencyId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies a transit brand which is often synonymous with a transit agency.
       * Note that in some cases, such as when a single agency operates multiple
       * separate services, agencies and brands are distinct. This document uses the
       * term "agency" in place of "brand". A dataset may contain data from multiple
       * agencies.
       * Conditionally Required:
       * - Required when the dataset contains data for multiple transit agencies.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 1;</code>
       * @param value The agencyId to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agencyId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a transit brand which is often synonymous with a transit agency.
       * Note that in some cases, such as when a single agency operates multiple
       * separate services, agencies and brands are distinct. This document uses the
       * term "agency" in place of "brand". A dataset may contain data from multiple
       * agencies.
       * Conditionally Required:
       * - Required when the dataset contains data for multiple transit agencies.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyId() {
        
        agencyId_ = getDefaultInstance().getAgencyId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a transit brand which is often synonymous with a transit agency.
       * Note that in some cases, such as when a single agency operates multiple
       * separate services, agencies and brands are distinct. This document uses the
       * term "agency" in place of "brand". A dataset may contain data from multiple
       * agencies.
       * Conditionally Required:
       * - Required when the dataset contains data for multiple transit agencies.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 1;</code>
       * @param value The bytes for agencyId to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agencyId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object agencyName_ = "";
      /**
       * <pre>
       * Full name of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_name = 2;</code>
       * @return The agencyName.
       */
      public java.lang.String getAgencyName() {
        java.lang.Object ref = agencyName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agencyName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Full name of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_name = 2;</code>
       * @return The bytes for agencyName.
       */
      public com.google.protobuf.ByteString
          getAgencyNameBytes() {
        java.lang.Object ref = agencyName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Full name of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_name = 2;</code>
       * @param value The agencyName to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agencyName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Full name of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_name = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyName() {
        
        agencyName_ = getDefaultInstance().getAgencyName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Full name of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_name = 2;</code>
       * @param value The bytes for agencyName to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agencyName_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object agencyUrl_ = "";
      /**
       * <pre>
       * URL of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_url = 3;</code>
       * @return The agencyUrl.
       */
      public java.lang.String getAgencyUrl() {
        java.lang.Object ref = agencyUrl_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agencyUrl_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * URL of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_url = 3;</code>
       * @return The bytes for agencyUrl.
       */
      public com.google.protobuf.ByteString
          getAgencyUrlBytes() {
        java.lang.Object ref = agencyUrl_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyUrl_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * URL of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_url = 3;</code>
       * @param value The agencyUrl to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyUrl(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agencyUrl_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * URL of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_url = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyUrl() {
        
        agencyUrl_ = getDefaultInstance().getAgencyUrl();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * URL of the transit agency.
       * Required
       * </pre>
       *
       * <code>string agency_url = 3;</code>
       * @param value The bytes for agencyUrl to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyUrlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agencyUrl_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object agencyTimezone_ = "";
      /**
       * <pre>
       * Timezone where the transit agency is located. If multiple agencies are
       * specified in the dataset, each must have the same agency_timezone.
       * Required
       * </pre>
       *
       * <code>string agency_timezone = 4;</code>
       * @return The agencyTimezone.
       */
      public java.lang.String getAgencyTimezone() {
        java.lang.Object ref = agencyTimezone_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agencyTimezone_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Timezone where the transit agency is located. If multiple agencies are
       * specified in the dataset, each must have the same agency_timezone.
       * Required
       * </pre>
       *
       * <code>string agency_timezone = 4;</code>
       * @return The bytes for agencyTimezone.
       */
      public com.google.protobuf.ByteString
          getAgencyTimezoneBytes() {
        java.lang.Object ref = agencyTimezone_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyTimezone_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Timezone where the transit agency is located. If multiple agencies are
       * specified in the dataset, each must have the same agency_timezone.
       * Required
       * </pre>
       *
       * <code>string agency_timezone = 4;</code>
       * @param value The agencyTimezone to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyTimezone(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agencyTimezone_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timezone where the transit agency is located. If multiple agencies are
       * specified in the dataset, each must have the same agency_timezone.
       * Required
       * </pre>
       *
       * <code>string agency_timezone = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyTimezone() {
        
        agencyTimezone_ = getDefaultInstance().getAgencyTimezone();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timezone where the transit agency is located. If multiple agencies are
       * specified in the dataset, each must have the same agency_timezone.
       * Required
       * </pre>
       *
       * <code>string agency_timezone = 4;</code>
       * @param value The bytes for agencyTimezone to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyTimezoneBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agencyTimezone_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object agencyLang_ = "";
      /**
       * <pre>
       * Primary language used by this transit agency. Should be provided to help
       * GTFS consumers choose capitalization rules and other language-specific
       * settings for the dataset.
       * </pre>
       *
       * <code>string agency_lang = 5;</code>
       * @return The agencyLang.
       */
      public java.lang.String getAgencyLang() {
        java.lang.Object ref = agencyLang_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agencyLang_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Primary language used by this transit agency. Should be provided to help
       * GTFS consumers choose capitalization rules and other language-specific
       * settings for the dataset.
       * </pre>
       *
       * <code>string agency_lang = 5;</code>
       * @return The bytes for agencyLang.
       */
      public com.google.protobuf.ByteString
          getAgencyLangBytes() {
        java.lang.Object ref = agencyLang_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyLang_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Primary language used by this transit agency. Should be provided to help
       * GTFS consumers choose capitalization rules and other language-specific
       * settings for the dataset.
       * </pre>
       *
       * <code>string agency_lang = 5;</code>
       * @param value The agencyLang to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyLang(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agencyLang_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Primary language used by this transit agency. Should be provided to help
       * GTFS consumers choose capitalization rules and other language-specific
       * settings for the dataset.
       * </pre>
       *
       * <code>string agency_lang = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyLang() {
        
        agencyLang_ = getDefaultInstance().getAgencyLang();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Primary language used by this transit agency. Should be provided to help
       * GTFS consumers choose capitalization rules and other language-specific
       * settings for the dataset.
       * </pre>
       *
       * <code>string agency_lang = 5;</code>
       * @param value The bytes for agencyLang to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyLangBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agencyLang_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object agencyPhone_ = "";
      /**
       * <pre>
       * A voice telephone number for the specified agency. This field is a string
       * value that presents the telephone number as typical for the agency's
       * service area. It may contain punctuation marks to group the digits of the
       * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
       * but the field must not contain any other descriptive text.
       * </pre>
       *
       * <code>string agency_phone = 6;</code>
       * @return The agencyPhone.
       */
      public java.lang.String getAgencyPhone() {
        java.lang.Object ref = agencyPhone_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agencyPhone_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A voice telephone number for the specified agency. This field is a string
       * value that presents the telephone number as typical for the agency's
       * service area. It may contain punctuation marks to group the digits of the
       * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
       * but the field must not contain any other descriptive text.
       * </pre>
       *
       * <code>string agency_phone = 6;</code>
       * @return The bytes for agencyPhone.
       */
      public com.google.protobuf.ByteString
          getAgencyPhoneBytes() {
        java.lang.Object ref = agencyPhone_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyPhone_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A voice telephone number for the specified agency. This field is a string
       * value that presents the telephone number as typical for the agency's
       * service area. It may contain punctuation marks to group the digits of the
       * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
       * but the field must not contain any other descriptive text.
       * </pre>
       *
       * <code>string agency_phone = 6;</code>
       * @param value The agencyPhone to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyPhone(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agencyPhone_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A voice telephone number for the specified agency. This field is a string
       * value that presents the telephone number as typical for the agency's
       * service area. It may contain punctuation marks to group the digits of the
       * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
       * but the field must not contain any other descriptive text.
       * </pre>
       *
       * <code>string agency_phone = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyPhone() {
        
        agencyPhone_ = getDefaultInstance().getAgencyPhone();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A voice telephone number for the specified agency. This field is a string
       * value that presents the telephone number as typical for the agency's
       * service area. It may contain punctuation marks to group the digits of the
       * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
       * but the field must not contain any other descriptive text.
       * </pre>
       *
       * <code>string agency_phone = 6;</code>
       * @param value The bytes for agencyPhone to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyPhoneBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agencyPhone_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object agencyFareUrl_ = "";
      /**
       * <pre>
       * URL of a web page that allows a rider to purchase tickets or other fare
       * instruments for that agency online.
       * </pre>
       *
       * <code>string agency_fare_url = 7;</code>
       * @return The agencyFareUrl.
       */
      public java.lang.String getAgencyFareUrl() {
        java.lang.Object ref = agencyFareUrl_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agencyFareUrl_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * URL of a web page that allows a rider to purchase tickets or other fare
       * instruments for that agency online.
       * </pre>
       *
       * <code>string agency_fare_url = 7;</code>
       * @return The bytes for agencyFareUrl.
       */
      public com.google.protobuf.ByteString
          getAgencyFareUrlBytes() {
        java.lang.Object ref = agencyFareUrl_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyFareUrl_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * URL of a web page that allows a rider to purchase tickets or other fare
       * instruments for that agency online.
       * </pre>
       *
       * <code>string agency_fare_url = 7;</code>
       * @param value The agencyFareUrl to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyFareUrl(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agencyFareUrl_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * URL of a web page that allows a rider to purchase tickets or other fare
       * instruments for that agency online.
       * </pre>
       *
       * <code>string agency_fare_url = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyFareUrl() {
        
        agencyFareUrl_ = getDefaultInstance().getAgencyFareUrl();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * URL of a web page that allows a rider to purchase tickets or other fare
       * instruments for that agency online.
       * </pre>
       *
       * <code>string agency_fare_url = 7;</code>
       * @param value The bytes for agencyFareUrl to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyFareUrlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agencyFareUrl_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object agencyEmail_ = "";
      /**
       * <pre>
       * Email address actively monitored by the agency’s customer service
       * department. This email address should be a direct contact point where
       * transit riders can reach a customer service representative at the agency.
       * </pre>
       *
       * <code>string agency_email = 8;</code>
       * @return The agencyEmail.
       */
      public java.lang.String getAgencyEmail() {
        java.lang.Object ref = agencyEmail_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agencyEmail_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Email address actively monitored by the agency’s customer service
       * department. This email address should be a direct contact point where
       * transit riders can reach a customer service representative at the agency.
       * </pre>
       *
       * <code>string agency_email = 8;</code>
       * @return The bytes for agencyEmail.
       */
      public com.google.protobuf.ByteString
          getAgencyEmailBytes() {
        java.lang.Object ref = agencyEmail_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyEmail_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Email address actively monitored by the agency’s customer service
       * department. This email address should be a direct contact point where
       * transit riders can reach a customer service representative at the agency.
       * </pre>
       *
       * <code>string agency_email = 8;</code>
       * @param value The agencyEmail to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyEmail(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agencyEmail_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Email address actively monitored by the agency’s customer service
       * department. This email address should be a direct contact point where
       * transit riders can reach a customer service representative at the agency.
       * </pre>
       *
       * <code>string agency_email = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyEmail() {
        
        agencyEmail_ = getDefaultInstance().getAgencyEmail();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Email address actively monitored by the agency’s customer service
       * department. This email address should be a direct contact point where
       * transit riders can reach a customer service representative at the agency.
       * </pre>
       *
       * <code>string agency_email = 8;</code>
       * @param value The bytes for agencyEmail to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyEmailBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agencyEmail_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:transit_scheduled.Agency)
    }

    // @@protoc_insertion_point(class_scope:transit_scheduled.Agency)
    private static final transit_scheduled.GtfsSchedule.Agency DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new transit_scheduled.GtfsSchedule.Agency();
    }

    public static transit_scheduled.GtfsSchedule.Agency getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Agency>
        PARSER = new com.google.protobuf.AbstractParser<Agency>() {
      @java.lang.Override
      public Agency parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Agency> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Agency> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public transit_scheduled.GtfsSchedule.Agency getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StopOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_scheduled.Stop)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Identifies a location: stop/platform, station, entrance/exit, generic node
     * or boarding area (see location_type).
     * Multiple routes may use the same stop_id.
     * Required
     * </pre>
     *
     * <code>string stop_id = 1;</code>
     * @return The stopId.
     */
    java.lang.String getStopId();
    /**
     * <pre>
     * Identifies a location: stop/platform, station, entrance/exit, generic node
     * or boarding area (see location_type).
     * Multiple routes may use the same stop_id.
     * Required
     * </pre>
     *
     * <code>string stop_id = 1;</code>
     * @return The bytes for stopId.
     */
    com.google.protobuf.ByteString
        getStopIdBytes();

    /**
     * <pre>
     * Short text or a number that identifies the location for riders. These codes
     * are often used in phone-based transit information systems or printed on
     * signage to make it easier for riders to get information for a particular
     * location. The stop_code may be the same as stop_id if it is public facing.
     * This field should be left empty for locations without a code presented to
     * riders.
     * </pre>
     *
     * <code>string stop_code = 2;</code>
     * @return The stopCode.
     */
    java.lang.String getStopCode();
    /**
     * <pre>
     * Short text or a number that identifies the location for riders. These codes
     * are often used in phone-based transit information systems or printed on
     * signage to make it easier for riders to get information for a particular
     * location. The stop_code may be the same as stop_id if it is public facing.
     * This field should be left empty for locations without a code presented to
     * riders.
     * </pre>
     *
     * <code>string stop_code = 2;</code>
     * @return The bytes for stopCode.
     */
    com.google.protobuf.ByteString
        getStopCodeBytes();

    /**
     * <pre>
     * Name of the location. The stop_name should match the agency's rider-facing
     * name for the location as printed on a timetable, published online, or
     * represented on signage. For translations into other languages, use
     * translations.txt.
     * When the location is a boarding area (location_type=4), the stop_name
     * should contains the name of the boarding area as displayed by the agency.
     * It could be just one letter (like on some European intercity railway
     * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
     * of short trains” (Paris’ RER).
     * Conditionally Required:
     * - Required for locations which are stops (location_type=0), stations
     * (location_type=1) or entrances/exits (location_type=2).
     * - Optional for locations which are generic nodes (location_type=3) or
     * boarding areas (location_type=4).
     * </pre>
     *
     * <code>string stop_name = 3;</code>
     * @return The stopName.
     */
    java.lang.String getStopName();
    /**
     * <pre>
     * Name of the location. The stop_name should match the agency's rider-facing
     * name for the location as printed on a timetable, published online, or
     * represented on signage. For translations into other languages, use
     * translations.txt.
     * When the location is a boarding area (location_type=4), the stop_name
     * should contains the name of the boarding area as displayed by the agency.
     * It could be just one letter (like on some European intercity railway
     * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
     * of short trains” (Paris’ RER).
     * Conditionally Required:
     * - Required for locations which are stops (location_type=0), stations
     * (location_type=1) or entrances/exits (location_type=2).
     * - Optional for locations which are generic nodes (location_type=3) or
     * boarding areas (location_type=4).
     * </pre>
     *
     * <code>string stop_name = 3;</code>
     * @return The bytes for stopName.
     */
    com.google.protobuf.ByteString
        getStopNameBytes();

    /**
     * <pre>
     * Readable version of the stop_name. See "Text-to-speech field" in the Term
     * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
     * </pre>
     *
     * <code>string tts_stop_name = 4;</code>
     * @return The ttsStopName.
     */
    java.lang.String getTtsStopName();
    /**
     * <pre>
     * Readable version of the stop_name. See "Text-to-speech field" in the Term
     * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
     * </pre>
     *
     * <code>string tts_stop_name = 4;</code>
     * @return The bytes for ttsStopName.
     */
    com.google.protobuf.ByteString
        getTtsStopNameBytes();

    /**
     * <pre>
     * Description of the location that provides useful, quality information.
     * Should not be a duplicate of stop_name.
     * </pre>
     *
     * <code>string stop_desc = 5;</code>
     * @return The stopDesc.
     */
    java.lang.String getStopDesc();
    /**
     * <pre>
     * Description of the location that provides useful, quality information.
     * Should not be a duplicate of stop_name.
     * </pre>
     *
     * <code>string stop_desc = 5;</code>
     * @return The bytes for stopDesc.
     */
    com.google.protobuf.ByteString
        getStopDescBytes();

    /**
     * <pre>
     * Latitude of the location.
     * For stops/platforms (location_type=0) and boarding area (location_type=4),
     * the coordinates must be the ones of the bus pole — if exists — and
     * otherwise of where the travelers are boarding the vehicle (on the sidewalk
     * or the platform, and not on the roadway or the track where the vehicle
     * stops).
     * Conditionally Required:
     * - Required for locations which are stops (location_type=0), stations
     * (location_type=1) or entrances/exits (location_type=2).
     * - Optional for locations which are generic nodes (location_type=3) or
     * boarding areas (location_type=4).
     * </pre>
     *
     * <code>double stop_lat = 6;</code>
     * @return The stopLat.
     */
    double getStopLat();

    /**
     * <pre>
     * Longitude of the location.
     * For stops/platforms (location_type=0) and boarding area (location_type=4),
     * the coordinates must be the ones of the bus pole — if exists — and
     * otherwise of where the travelers are boarding the vehicle (on the sidewalk
     * or the platform, and not on the roadway or the track where the vehicle
     * stops).
     * Conditionally Required:
     * - Required for locations which are stops (location_type=0), stations
     * (location_type=1) or entrances/exits (location_type=2).
     * - Optional for locations which are generic nodes (location_type=3) or
     * boarding areas (location_type=4).
     * </pre>
     *
     * <code>double stop_lon = 7;</code>
     * @return The stopLon.
     */
    double getStopLon();

    /**
     * <pre>
     * Identifies the fare zone for a stop. If this record represents a station or
     * station entrance, the zone_id is ignored.
     * Conditionally Required:
     * - Required if providing fare information using fare_rules.txt
     * - Optional otherwise.
     * </pre>
     *
     * <code>string zone_id = 8;</code>
     * @return The zoneId.
     */
    java.lang.String getZoneId();
    /**
     * <pre>
     * Identifies the fare zone for a stop. If this record represents a station or
     * station entrance, the zone_id is ignored.
     * Conditionally Required:
     * - Required if providing fare information using fare_rules.txt
     * - Optional otherwise.
     * </pre>
     *
     * <code>string zone_id = 8;</code>
     * @return The bytes for zoneId.
     */
    com.google.protobuf.ByteString
        getZoneIdBytes();

    /**
     * <pre>
     * URL of a web page about the location. This should be different from the
     * agency.agency_url and the routes.route_url field values.
     * </pre>
     *
     * <code>string stop_url = 9;</code>
     * @return The stopUrl.
     */
    java.lang.String getStopUrl();
    /**
     * <pre>
     * URL of a web page about the location. This should be different from the
     * agency.agency_url and the routes.route_url field values.
     * </pre>
     *
     * <code>string stop_url = 9;</code>
     * @return The bytes for stopUrl.
     */
    com.google.protobuf.ByteString
        getStopUrlBytes();

    /**
     * <pre>
     * Location type.
     * </pre>
     *
     * <code>.transit_scheduled.Stop.LocationType location_type = 10;</code>
     * @return The enum numeric value on the wire for locationType.
     */
    int getLocationTypeValue();
    /**
     * <pre>
     * Location type.
     * </pre>
     *
     * <code>.transit_scheduled.Stop.LocationType location_type = 10;</code>
     * @return The locationType.
     */
    transit_scheduled.GtfsSchedule.Stop.LocationType getLocationType();

    /**
     * <pre>
     * Defines hierarchy between the different locations defined in stops.txt. It
     * contains the ID of the parent location, as followed:
     * - Stop/platform (location_type=0): the parent_station field contains the ID
     * of a station.
     * - Station (location_type=1): this field must be empty.
     * - Entrance/exit (location_type=2) or generic node (location_type=3): the
     * parent_station field contains the ID of a station (location_type=1)
     * - Boarding Area (location_type=4): the parent_station field contains ID of
     * a platform.
     * Conditionally Required:
     * - Required for locations which are entrances (location_type=2), generic
     * nodes (location_type=3) or boarding areas (location_type=4).
     * - Optional for stops/platforms (location_type=0).
     * - Forbidden for stations (location_type=1).
     * </pre>
     *
     * <code>string parent_station = 11;</code>
     * @return The parentStation.
     */
    java.lang.String getParentStation();
    /**
     * <pre>
     * Defines hierarchy between the different locations defined in stops.txt. It
     * contains the ID of the parent location, as followed:
     * - Stop/platform (location_type=0): the parent_station field contains the ID
     * of a station.
     * - Station (location_type=1): this field must be empty.
     * - Entrance/exit (location_type=2) or generic node (location_type=3): the
     * parent_station field contains the ID of a station (location_type=1)
     * - Boarding Area (location_type=4): the parent_station field contains ID of
     * a platform.
     * Conditionally Required:
     * - Required for locations which are entrances (location_type=2), generic
     * nodes (location_type=3) or boarding areas (location_type=4).
     * - Optional for stops/platforms (location_type=0).
     * - Forbidden for stations (location_type=1).
     * </pre>
     *
     * <code>string parent_station = 11;</code>
     * @return The bytes for parentStation.
     */
    com.google.protobuf.ByteString
        getParentStationBytes();

    /**
     * <pre>
     * Timezone of the location. If the location has a parent station, it inherits
     * the parent station’s timezone instead of applying its own. Stations and
     * parentless stops with empty stop_timezone inherit the timezone specified by
     * agency.agency_timezone. If stop_timezone values are provided, the times in
     * stop_times.txt should be entered as the time since midnight in the timezone
     * specified by agency.agency_timezone. This ensures that the time values in a
     * trip always increase over the course of a trip, regardless of which
     * timezones the trip crosses.
     * </pre>
     *
     * <code>string stop_timezone = 12;</code>
     * @return The stopTimezone.
     */
    java.lang.String getStopTimezone();
    /**
     * <pre>
     * Timezone of the location. If the location has a parent station, it inherits
     * the parent station’s timezone instead of applying its own. Stations and
     * parentless stops with empty stop_timezone inherit the timezone specified by
     * agency.agency_timezone. If stop_timezone values are provided, the times in
     * stop_times.txt should be entered as the time since midnight in the timezone
     * specified by agency.agency_timezone. This ensures that the time values in a
     * trip always increase over the course of a trip, regardless of which
     * timezones the trip crosses.
     * </pre>
     *
     * <code>string stop_timezone = 12;</code>
     * @return The bytes for stopTimezone.
     */
    com.google.protobuf.ByteString
        getStopTimezoneBytes();

    /**
     * <pre>
     * Indicates whether wheelchair boardings are possible from the location.
     * </pre>
     *
     * <code>.transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;</code>
     * @return The enum numeric value on the wire for wheelchairBoarding.
     */
    int getWheelchairBoardingValue();
    /**
     * <pre>
     * Indicates whether wheelchair boardings are possible from the location.
     * </pre>
     *
     * <code>.transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;</code>
     * @return The wheelchairBoarding.
     */
    transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding getWheelchairBoarding();

    /**
     * <pre>
     * Level of the location. The same level may be used by multiple unlinked
     * stations.
     * </pre>
     *
     * <code>string level_id = 14;</code>
     * @return The levelId.
     */
    java.lang.String getLevelId();
    /**
     * <pre>
     * Level of the location. The same level may be used by multiple unlinked
     * stations.
     * </pre>
     *
     * <code>string level_id = 14;</code>
     * @return The bytes for levelId.
     */
    com.google.protobuf.ByteString
        getLevelIdBytes();

    /**
     * <pre>
     * Platform identifier for a platform stop (a stop belonging to a station).
     * This should be just the platform identifier (eg. "G" or "3"). Words like
     * “platform” or "track" (or the feed’s language-specific equivalent) should
     * not be included. This allows feed consumers to more easily internationalize
     * and localize the platform identifier into other languages.
     * </pre>
     *
     * <code>string platform_code = 15;</code>
     * @return The platformCode.
     */
    java.lang.String getPlatformCode();
    /**
     * <pre>
     * Platform identifier for a platform stop (a stop belonging to a station).
     * This should be just the platform identifier (eg. "G" or "3"). Words like
     * “platform” or "track" (or the feed’s language-specific equivalent) should
     * not be included. This allows feed consumers to more easily internationalize
     * and localize the platform identifier into other languages.
     * </pre>
     *
     * <code>string platform_code = 15;</code>
     * @return The bytes for platformCode.
     */
    com.google.protobuf.ByteString
        getPlatformCodeBytes();
  }
  /**
   * <pre>
   * Stops where vehicles pick up or drop off riders. Also defines stations and
   * station entrances.
   * </pre>
   *
   * Protobuf type {@code transit_scheduled.Stop}
   */
  public static final class Stop extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:transit_scheduled.Stop)
      StopOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Stop.newBuilder() to construct.
    private Stop(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Stop() {
      stopId_ = "";
      stopCode_ = "";
      stopName_ = "";
      ttsStopName_ = "";
      stopDesc_ = "";
      zoneId_ = "";
      stopUrl_ = "";
      locationType_ = 0;
      parentStation_ = "";
      stopTimezone_ = "";
      wheelchairBoarding_ = 0;
      levelId_ = "";
      platformCode_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Stop();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Stop_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Stop_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              transit_scheduled.GtfsSchedule.Stop.class, transit_scheduled.GtfsSchedule.Stop.Builder.class);
    }

    /**
     * <pre>
     * Location type. Valid options are:
     *   0 (or blank) - Stop (or Platform). A location where passengers board or
     *   disembark from a transit vehicle. Is called a platform when defined
     *   within a parent_station.
     *   1 - Station. A physical structure or area that contains one or more
     *   platform.
     *   2 - Entrance/Exit. A location where passengers can enter or exit a
     *   station from the street. If an entrance/exit belongs to multiple
     *   stations, it may be linked by pathways to both, but the data provider
     *   must pick one of them as parent.
     *   3 - Generic Node. A location within a station, not matching any other
     *   location_type, that may be used to link together pathways define in
     *   pathways.txt.
     *   4 - Boarding Area. A specific location on a platform, where passengers
     *   can board and/or alight vehicles.
     * </pre>
     *
     * Protobuf enum {@code transit_scheduled.Stop.LocationType}
     */
    public enum LocationType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>LOCATION_TYPE_STOP = 0;</code>
       */
      LOCATION_TYPE_STOP(0),
      /**
       * <code>LOCATION_TYPE_STATION = 1;</code>
       */
      LOCATION_TYPE_STATION(1),
      /**
       * <code>LOCATION_TYPE_ENTRANCE_EXIT = 2;</code>
       */
      LOCATION_TYPE_ENTRANCE_EXIT(2),
      /**
       * <code>LOCATION_TYPE_GENERIC_NODE = 3;</code>
       */
      LOCATION_TYPE_GENERIC_NODE(3),
      /**
       * <code>LOCATION_TYPE_BOARDING_AREA = 4;</code>
       */
      LOCATION_TYPE_BOARDING_AREA(4),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>LOCATION_TYPE_STOP = 0;</code>
       */
      public static final int LOCATION_TYPE_STOP_VALUE = 0;
      /**
       * <code>LOCATION_TYPE_STATION = 1;</code>
       */
      public static final int LOCATION_TYPE_STATION_VALUE = 1;
      /**
       * <code>LOCATION_TYPE_ENTRANCE_EXIT = 2;</code>
       */
      public static final int LOCATION_TYPE_ENTRANCE_EXIT_VALUE = 2;
      /**
       * <code>LOCATION_TYPE_GENERIC_NODE = 3;</code>
       */
      public static final int LOCATION_TYPE_GENERIC_NODE_VALUE = 3;
      /**
       * <code>LOCATION_TYPE_BOARDING_AREA = 4;</code>
       */
      public static final int LOCATION_TYPE_BOARDING_AREA_VALUE = 4;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static LocationType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static LocationType forNumber(int value) {
        switch (value) {
          case 0: return LOCATION_TYPE_STOP;
          case 1: return LOCATION_TYPE_STATION;
          case 2: return LOCATION_TYPE_ENTRANCE_EXIT;
          case 3: return LOCATION_TYPE_GENERIC_NODE;
          case 4: return LOCATION_TYPE_BOARDING_AREA;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<LocationType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          LocationType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<LocationType>() {
              public LocationType findValueByNumber(int number) {
                return LocationType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.Stop.getDescriptor().getEnumTypes().get(0);
      }

      private static final LocationType[] VALUES = values();

      public static LocationType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private LocationType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_scheduled.Stop.LocationType)
    }

    /**
     * <pre>
     * Indicates whether wheelchair boardings are possible from the location.
     * Valid options are:
     *   For parentless stops:
     *     0 or empty - No accessibility information for the stop.
     *     1 - Some vehicles at this stop can be boarded by a rider in a
     *     wheelchair.
     *     2 - Wheelchair boarding is not possible at this stop.
     *   For child stops:
     *     0 or empty - Stop will inherit its wheelchair_boarding behavior from
     *     the parent station, if specified in the parent.
     *     1 - There exists some accessible path from outside the station to the
     *     specific stop/platform.
     *     2 - There exists no accessible path from outside the station to the
     *     specific stop/platform.
     *   For station entrances/exits:
     *     0 or empty - Station entrance will inherit its wheelchair_boarding
     *     behavior from the parent station, if specified for the parent.
     *     1 - Station entrance is wheelchair accessible.
     *     2 - No accessible path from station entrance to stops/platforms.
     * </pre>
     *
     * Protobuf enum {@code transit_scheduled.Stop.WheelchairBoarding}
     */
    public enum WheelchairBoarding
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>WHEELCHAIR_BOARDING_NO_INFO = 0;</code>
       */
      WHEELCHAIR_BOARDING_NO_INFO(0),
      /**
       * <code>WHEELCHAIR_BOARDING_POSSIBLE = 1;</code>
       */
      WHEELCHAIR_BOARDING_POSSIBLE(1),
      /**
       * <code>WHEELCHAIR_BOARDING_NOT_POSSIBLE = 2;</code>
       */
      WHEELCHAIR_BOARDING_NOT_POSSIBLE(2),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>WHEELCHAIR_BOARDING_NO_INFO = 0;</code>
       */
      public static final int WHEELCHAIR_BOARDING_NO_INFO_VALUE = 0;
      /**
       * <code>WHEELCHAIR_BOARDING_POSSIBLE = 1;</code>
       */
      public static final int WHEELCHAIR_BOARDING_POSSIBLE_VALUE = 1;
      /**
       * <code>WHEELCHAIR_BOARDING_NOT_POSSIBLE = 2;</code>
       */
      public static final int WHEELCHAIR_BOARDING_NOT_POSSIBLE_VALUE = 2;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static WheelchairBoarding valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static WheelchairBoarding forNumber(int value) {
        switch (value) {
          case 0: return WHEELCHAIR_BOARDING_NO_INFO;
          case 1: return WHEELCHAIR_BOARDING_POSSIBLE;
          case 2: return WHEELCHAIR_BOARDING_NOT_POSSIBLE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<WheelchairBoarding>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          WheelchairBoarding> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<WheelchairBoarding>() {
              public WheelchairBoarding findValueByNumber(int number) {
                return WheelchairBoarding.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.Stop.getDescriptor().getEnumTypes().get(1);
      }

      private static final WheelchairBoarding[] VALUES = values();

      public static WheelchairBoarding valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private WheelchairBoarding(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_scheduled.Stop.WheelchairBoarding)
    }

    public static final int STOP_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object stopId_;
    /**
     * <pre>
     * Identifies a location: stop/platform, station, entrance/exit, generic node
     * or boarding area (see location_type).
     * Multiple routes may use the same stop_id.
     * Required
     * </pre>
     *
     * <code>string stop_id = 1;</code>
     * @return The stopId.
     */
    @java.lang.Override
    public java.lang.String getStopId() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stopId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies a location: stop/platform, station, entrance/exit, generic node
     * or boarding area (see location_type).
     * Multiple routes may use the same stop_id.
     * Required
     * </pre>
     *
     * <code>string stop_id = 1;</code>
     * @return The bytes for stopId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopIdBytes() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_CODE_FIELD_NUMBER = 2;
    private volatile java.lang.Object stopCode_;
    /**
     * <pre>
     * Short text or a number that identifies the location for riders. These codes
     * are often used in phone-based transit information systems or printed on
     * signage to make it easier for riders to get information for a particular
     * location. The stop_code may be the same as stop_id if it is public facing.
     * This field should be left empty for locations without a code presented to
     * riders.
     * </pre>
     *
     * <code>string stop_code = 2;</code>
     * @return The stopCode.
     */
    @java.lang.Override
    public java.lang.String getStopCode() {
      java.lang.Object ref = stopCode_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stopCode_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Short text or a number that identifies the location for riders. These codes
     * are often used in phone-based transit information systems or printed on
     * signage to make it easier for riders to get information for a particular
     * location. The stop_code may be the same as stop_id if it is public facing.
     * This field should be left empty for locations without a code presented to
     * riders.
     * </pre>
     *
     * <code>string stop_code = 2;</code>
     * @return The bytes for stopCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopCodeBytes() {
      java.lang.Object ref = stopCode_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopCode_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_NAME_FIELD_NUMBER = 3;
    private volatile java.lang.Object stopName_;
    /**
     * <pre>
     * Name of the location. The stop_name should match the agency's rider-facing
     * name for the location as printed on a timetable, published online, or
     * represented on signage. For translations into other languages, use
     * translations.txt.
     * When the location is a boarding area (location_type=4), the stop_name
     * should contains the name of the boarding area as displayed by the agency.
     * It could be just one letter (like on some European intercity railway
     * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
     * of short trains” (Paris’ RER).
     * Conditionally Required:
     * - Required for locations which are stops (location_type=0), stations
     * (location_type=1) or entrances/exits (location_type=2).
     * - Optional for locations which are generic nodes (location_type=3) or
     * boarding areas (location_type=4).
     * </pre>
     *
     * <code>string stop_name = 3;</code>
     * @return The stopName.
     */
    @java.lang.Override
    public java.lang.String getStopName() {
      java.lang.Object ref = stopName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stopName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Name of the location. The stop_name should match the agency's rider-facing
     * name for the location as printed on a timetable, published online, or
     * represented on signage. For translations into other languages, use
     * translations.txt.
     * When the location is a boarding area (location_type=4), the stop_name
     * should contains the name of the boarding area as displayed by the agency.
     * It could be just one letter (like on some European intercity railway
     * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
     * of short trains” (Paris’ RER).
     * Conditionally Required:
     * - Required for locations which are stops (location_type=0), stations
     * (location_type=1) or entrances/exits (location_type=2).
     * - Optional for locations which are generic nodes (location_type=3) or
     * boarding areas (location_type=4).
     * </pre>
     *
     * <code>string stop_name = 3;</code>
     * @return The bytes for stopName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopNameBytes() {
      java.lang.Object ref = stopName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TTS_STOP_NAME_FIELD_NUMBER = 4;
    private volatile java.lang.Object ttsStopName_;
    /**
     * <pre>
     * Readable version of the stop_name. See "Text-to-speech field" in the Term
     * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
     * </pre>
     *
     * <code>string tts_stop_name = 4;</code>
     * @return The ttsStopName.
     */
    @java.lang.Override
    public java.lang.String getTtsStopName() {
      java.lang.Object ref = ttsStopName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        ttsStopName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Readable version of the stop_name. See "Text-to-speech field" in the Term
     * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
     * </pre>
     *
     * <code>string tts_stop_name = 4;</code>
     * @return The bytes for ttsStopName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTtsStopNameBytes() {
      java.lang.Object ref = ttsStopName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        ttsStopName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_DESC_FIELD_NUMBER = 5;
    private volatile java.lang.Object stopDesc_;
    /**
     * <pre>
     * Description of the location that provides useful, quality information.
     * Should not be a duplicate of stop_name.
     * </pre>
     *
     * <code>string stop_desc = 5;</code>
     * @return The stopDesc.
     */
    @java.lang.Override
    public java.lang.String getStopDesc() {
      java.lang.Object ref = stopDesc_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stopDesc_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Description of the location that provides useful, quality information.
     * Should not be a duplicate of stop_name.
     * </pre>
     *
     * <code>string stop_desc = 5;</code>
     * @return The bytes for stopDesc.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopDescBytes() {
      java.lang.Object ref = stopDesc_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopDesc_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_LAT_FIELD_NUMBER = 6;
    private double stopLat_;
    /**
     * <pre>
     * Latitude of the location.
     * For stops/platforms (location_type=0) and boarding area (location_type=4),
     * the coordinates must be the ones of the bus pole — if exists — and
     * otherwise of where the travelers are boarding the vehicle (on the sidewalk
     * or the platform, and not on the roadway or the track where the vehicle
     * stops).
     * Conditionally Required:
     * - Required for locations which are stops (location_type=0), stations
     * (location_type=1) or entrances/exits (location_type=2).
     * - Optional for locations which are generic nodes (location_type=3) or
     * boarding areas (location_type=4).
     * </pre>
     *
     * <code>double stop_lat = 6;</code>
     * @return The stopLat.
     */
    @java.lang.Override
    public double getStopLat() {
      return stopLat_;
    }

    public static final int STOP_LON_FIELD_NUMBER = 7;
    private double stopLon_;
    /**
     * <pre>
     * Longitude of the location.
     * For stops/platforms (location_type=0) and boarding area (location_type=4),
     * the coordinates must be the ones of the bus pole — if exists — and
     * otherwise of where the travelers are boarding the vehicle (on the sidewalk
     * or the platform, and not on the roadway or the track where the vehicle
     * stops).
     * Conditionally Required:
     * - Required for locations which are stops (location_type=0), stations
     * (location_type=1) or entrances/exits (location_type=2).
     * - Optional for locations which are generic nodes (location_type=3) or
     * boarding areas (location_type=4).
     * </pre>
     *
     * <code>double stop_lon = 7;</code>
     * @return The stopLon.
     */
    @java.lang.Override
    public double getStopLon() {
      return stopLon_;
    }

    public static final int ZONE_ID_FIELD_NUMBER = 8;
    private volatile java.lang.Object zoneId_;
    /**
     * <pre>
     * Identifies the fare zone for a stop. If this record represents a station or
     * station entrance, the zone_id is ignored.
     * Conditionally Required:
     * - Required if providing fare information using fare_rules.txt
     * - Optional otherwise.
     * </pre>
     *
     * <code>string zone_id = 8;</code>
     * @return The zoneId.
     */
    @java.lang.Override
    public java.lang.String getZoneId() {
      java.lang.Object ref = zoneId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        zoneId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies the fare zone for a stop. If this record represents a station or
     * station entrance, the zone_id is ignored.
     * Conditionally Required:
     * - Required if providing fare information using fare_rules.txt
     * - Optional otherwise.
     * </pre>
     *
     * <code>string zone_id = 8;</code>
     * @return The bytes for zoneId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getZoneIdBytes() {
      java.lang.Object ref = zoneId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        zoneId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_URL_FIELD_NUMBER = 9;
    private volatile java.lang.Object stopUrl_;
    /**
     * <pre>
     * URL of a web page about the location. This should be different from the
     * agency.agency_url and the routes.route_url field values.
     * </pre>
     *
     * <code>string stop_url = 9;</code>
     * @return The stopUrl.
     */
    @java.lang.Override
    public java.lang.String getStopUrl() {
      java.lang.Object ref = stopUrl_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stopUrl_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * URL of a web page about the location. This should be different from the
     * agency.agency_url and the routes.route_url field values.
     * </pre>
     *
     * <code>string stop_url = 9;</code>
     * @return The bytes for stopUrl.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopUrlBytes() {
      java.lang.Object ref = stopUrl_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopUrl_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LOCATION_TYPE_FIELD_NUMBER = 10;
    private int locationType_;
    /**
     * <pre>
     * Location type.
     * </pre>
     *
     * <code>.transit_scheduled.Stop.LocationType location_type = 10;</code>
     * @return The enum numeric value on the wire for locationType.
     */
    @java.lang.Override public int getLocationTypeValue() {
      return locationType_;
    }
    /**
     * <pre>
     * Location type.
     * </pre>
     *
     * <code>.transit_scheduled.Stop.LocationType location_type = 10;</code>
     * @return The locationType.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.Stop.LocationType getLocationType() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.Stop.LocationType result = transit_scheduled.GtfsSchedule.Stop.LocationType.valueOf(locationType_);
      return result == null ? transit_scheduled.GtfsSchedule.Stop.LocationType.UNRECOGNIZED : result;
    }

    public static final int PARENT_STATION_FIELD_NUMBER = 11;
    private volatile java.lang.Object parentStation_;
    /**
     * <pre>
     * Defines hierarchy between the different locations defined in stops.txt. It
     * contains the ID of the parent location, as followed:
     * - Stop/platform (location_type=0): the parent_station field contains the ID
     * of a station.
     * - Station (location_type=1): this field must be empty.
     * - Entrance/exit (location_type=2) or generic node (location_type=3): the
     * parent_station field contains the ID of a station (location_type=1)
     * - Boarding Area (location_type=4): the parent_station field contains ID of
     * a platform.
     * Conditionally Required:
     * - Required for locations which are entrances (location_type=2), generic
     * nodes (location_type=3) or boarding areas (location_type=4).
     * - Optional for stops/platforms (location_type=0).
     * - Forbidden for stations (location_type=1).
     * </pre>
     *
     * <code>string parent_station = 11;</code>
     * @return The parentStation.
     */
    @java.lang.Override
    public java.lang.String getParentStation() {
      java.lang.Object ref = parentStation_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        parentStation_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Defines hierarchy between the different locations defined in stops.txt. It
     * contains the ID of the parent location, as followed:
     * - Stop/platform (location_type=0): the parent_station field contains the ID
     * of a station.
     * - Station (location_type=1): this field must be empty.
     * - Entrance/exit (location_type=2) or generic node (location_type=3): the
     * parent_station field contains the ID of a station (location_type=1)
     * - Boarding Area (location_type=4): the parent_station field contains ID of
     * a platform.
     * Conditionally Required:
     * - Required for locations which are entrances (location_type=2), generic
     * nodes (location_type=3) or boarding areas (location_type=4).
     * - Optional for stops/platforms (location_type=0).
     * - Forbidden for stations (location_type=1).
     * </pre>
     *
     * <code>string parent_station = 11;</code>
     * @return The bytes for parentStation.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getParentStationBytes() {
      java.lang.Object ref = parentStation_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        parentStation_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_TIMEZONE_FIELD_NUMBER = 12;
    private volatile java.lang.Object stopTimezone_;
    /**
     * <pre>
     * Timezone of the location. If the location has a parent station, it inherits
     * the parent station’s timezone instead of applying its own. Stations and
     * parentless stops with empty stop_timezone inherit the timezone specified by
     * agency.agency_timezone. If stop_timezone values are provided, the times in
     * stop_times.txt should be entered as the time since midnight in the timezone
     * specified by agency.agency_timezone. This ensures that the time values in a
     * trip always increase over the course of a trip, regardless of which
     * timezones the trip crosses.
     * </pre>
     *
     * <code>string stop_timezone = 12;</code>
     * @return The stopTimezone.
     */
    @java.lang.Override
    public java.lang.String getStopTimezone() {
      java.lang.Object ref = stopTimezone_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stopTimezone_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Timezone of the location. If the location has a parent station, it inherits
     * the parent station’s timezone instead of applying its own. Stations and
     * parentless stops with empty stop_timezone inherit the timezone specified by
     * agency.agency_timezone. If stop_timezone values are provided, the times in
     * stop_times.txt should be entered as the time since midnight in the timezone
     * specified by agency.agency_timezone. This ensures that the time values in a
     * trip always increase over the course of a trip, regardless of which
     * timezones the trip crosses.
     * </pre>
     *
     * <code>string stop_timezone = 12;</code>
     * @return The bytes for stopTimezone.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopTimezoneBytes() {
      java.lang.Object ref = stopTimezone_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopTimezone_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WHEELCHAIR_BOARDING_FIELD_NUMBER = 13;
    private int wheelchairBoarding_;
    /**
     * <pre>
     * Indicates whether wheelchair boardings are possible from the location.
     * </pre>
     *
     * <code>.transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;</code>
     * @return The enum numeric value on the wire for wheelchairBoarding.
     */
    @java.lang.Override public int getWheelchairBoardingValue() {
      return wheelchairBoarding_;
    }
    /**
     * <pre>
     * Indicates whether wheelchair boardings are possible from the location.
     * </pre>
     *
     * <code>.transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;</code>
     * @return The wheelchairBoarding.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding getWheelchairBoarding() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding result = transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding.valueOf(wheelchairBoarding_);
      return result == null ? transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding.UNRECOGNIZED : result;
    }

    public static final int LEVEL_ID_FIELD_NUMBER = 14;
    private volatile java.lang.Object levelId_;
    /**
     * <pre>
     * Level of the location. The same level may be used by multiple unlinked
     * stations.
     * </pre>
     *
     * <code>string level_id = 14;</code>
     * @return The levelId.
     */
    @java.lang.Override
    public java.lang.String getLevelId() {
      java.lang.Object ref = levelId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        levelId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Level of the location. The same level may be used by multiple unlinked
     * stations.
     * </pre>
     *
     * <code>string level_id = 14;</code>
     * @return The bytes for levelId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLevelIdBytes() {
      java.lang.Object ref = levelId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        levelId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PLATFORM_CODE_FIELD_NUMBER = 15;
    private volatile java.lang.Object platformCode_;
    /**
     * <pre>
     * Platform identifier for a platform stop (a stop belonging to a station).
     * This should be just the platform identifier (eg. "G" or "3"). Words like
     * “platform” or "track" (or the feed’s language-specific equivalent) should
     * not be included. This allows feed consumers to more easily internationalize
     * and localize the platform identifier into other languages.
     * </pre>
     *
     * <code>string platform_code = 15;</code>
     * @return The platformCode.
     */
    @java.lang.Override
    public java.lang.String getPlatformCode() {
      java.lang.Object ref = platformCode_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        platformCode_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Platform identifier for a platform stop (a stop belonging to a station).
     * This should be just the platform identifier (eg. "G" or "3"). Words like
     * “platform” or "track" (or the feed’s language-specific equivalent) should
     * not be included. This allows feed consumers to more easily internationalize
     * and localize the platform identifier into other languages.
     * </pre>
     *
     * <code>string platform_code = 15;</code>
     * @return The bytes for platformCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPlatformCodeBytes() {
      java.lang.Object ref = platformCode_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        platformCode_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, stopId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopCode_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, stopCode_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopName_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, stopName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(ttsStopName_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, ttsStopName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopDesc_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, stopDesc_);
      }
      if (java.lang.Double.doubleToRawLongBits(stopLat_) != 0) {
        output.writeDouble(6, stopLat_);
      }
      if (java.lang.Double.doubleToRawLongBits(stopLon_) != 0) {
        output.writeDouble(7, stopLon_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(zoneId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, zoneId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopUrl_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, stopUrl_);
      }
      if (locationType_ != transit_scheduled.GtfsSchedule.Stop.LocationType.LOCATION_TYPE_STOP.getNumber()) {
        output.writeEnum(10, locationType_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(parentStation_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 11, parentStation_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopTimezone_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, stopTimezone_);
      }
      if (wheelchairBoarding_ != transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding.WHEELCHAIR_BOARDING_NO_INFO.getNumber()) {
        output.writeEnum(13, wheelchairBoarding_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(levelId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 14, levelId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(platformCode_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 15, platformCode_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, stopId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopCode_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, stopCode_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopName_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, stopName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(ttsStopName_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, ttsStopName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopDesc_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, stopDesc_);
      }
      if (java.lang.Double.doubleToRawLongBits(stopLat_) != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(6, stopLat_);
      }
      if (java.lang.Double.doubleToRawLongBits(stopLon_) != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(7, stopLon_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(zoneId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, zoneId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopUrl_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, stopUrl_);
      }
      if (locationType_ != transit_scheduled.GtfsSchedule.Stop.LocationType.LOCATION_TYPE_STOP.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, locationType_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(parentStation_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11, parentStation_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopTimezone_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, stopTimezone_);
      }
      if (wheelchairBoarding_ != transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding.WHEELCHAIR_BOARDING_NO_INFO.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(13, wheelchairBoarding_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(levelId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(14, levelId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(platformCode_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(15, platformCode_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof transit_scheduled.GtfsSchedule.Stop)) {
        return super.equals(obj);
      }
      transit_scheduled.GtfsSchedule.Stop other = (transit_scheduled.GtfsSchedule.Stop) obj;

      if (!getStopId()
          .equals(other.getStopId())) return false;
      if (!getStopCode()
          .equals(other.getStopCode())) return false;
      if (!getStopName()
          .equals(other.getStopName())) return false;
      if (!getTtsStopName()
          .equals(other.getTtsStopName())) return false;
      if (!getStopDesc()
          .equals(other.getStopDesc())) return false;
      if (java.lang.Double.doubleToLongBits(getStopLat())
          != java.lang.Double.doubleToLongBits(
              other.getStopLat())) return false;
      if (java.lang.Double.doubleToLongBits(getStopLon())
          != java.lang.Double.doubleToLongBits(
              other.getStopLon())) return false;
      if (!getZoneId()
          .equals(other.getZoneId())) return false;
      if (!getStopUrl()
          .equals(other.getStopUrl())) return false;
      if (locationType_ != other.locationType_) return false;
      if (!getParentStation()
          .equals(other.getParentStation())) return false;
      if (!getStopTimezone()
          .equals(other.getStopTimezone())) return false;
      if (wheelchairBoarding_ != other.wheelchairBoarding_) return false;
      if (!getLevelId()
          .equals(other.getLevelId())) return false;
      if (!getPlatformCode()
          .equals(other.getPlatformCode())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + STOP_ID_FIELD_NUMBER;
      hash = (53 * hash) + getStopId().hashCode();
      hash = (37 * hash) + STOP_CODE_FIELD_NUMBER;
      hash = (53 * hash) + getStopCode().hashCode();
      hash = (37 * hash) + STOP_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getStopName().hashCode();
      hash = (37 * hash) + TTS_STOP_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getTtsStopName().hashCode();
      hash = (37 * hash) + STOP_DESC_FIELD_NUMBER;
      hash = (53 * hash) + getStopDesc().hashCode();
      hash = (37 * hash) + STOP_LAT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          java.lang.Double.doubleToLongBits(getStopLat()));
      hash = (37 * hash) + STOP_LON_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          java.lang.Double.doubleToLongBits(getStopLon()));
      hash = (37 * hash) + ZONE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getZoneId().hashCode();
      hash = (37 * hash) + STOP_URL_FIELD_NUMBER;
      hash = (53 * hash) + getStopUrl().hashCode();
      hash = (37 * hash) + LOCATION_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + locationType_;
      hash = (37 * hash) + PARENT_STATION_FIELD_NUMBER;
      hash = (53 * hash) + getParentStation().hashCode();
      hash = (37 * hash) + STOP_TIMEZONE_FIELD_NUMBER;
      hash = (53 * hash) + getStopTimezone().hashCode();
      hash = (37 * hash) + WHEELCHAIR_BOARDING_FIELD_NUMBER;
      hash = (53 * hash) + wheelchairBoarding_;
      hash = (37 * hash) + LEVEL_ID_FIELD_NUMBER;
      hash = (53 * hash) + getLevelId().hashCode();
      hash = (37 * hash) + PLATFORM_CODE_FIELD_NUMBER;
      hash = (53 * hash) + getPlatformCode().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static transit_scheduled.GtfsSchedule.Stop parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Stop parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(transit_scheduled.GtfsSchedule.Stop prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Stops where vehicles pick up or drop off riders. Also defines stations and
     * station entrances.
     * </pre>
     *
     * Protobuf type {@code transit_scheduled.Stop}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_scheduled.Stop)
        transit_scheduled.GtfsSchedule.StopOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Stop_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Stop_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                transit_scheduled.GtfsSchedule.Stop.class, transit_scheduled.GtfsSchedule.Stop.Builder.class);
      }

      // Construct using transit_scheduled.GtfsSchedule.Stop.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        stopId_ = "";

        stopCode_ = "";

        stopName_ = "";

        ttsStopName_ = "";

        stopDesc_ = "";

        stopLat_ = 0D;

        stopLon_ = 0D;

        zoneId_ = "";

        stopUrl_ = "";

        locationType_ = 0;

        parentStation_ = "";

        stopTimezone_ = "";

        wheelchairBoarding_ = 0;

        levelId_ = "";

        platformCode_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Stop_descriptor;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Stop getDefaultInstanceForType() {
        return transit_scheduled.GtfsSchedule.Stop.getDefaultInstance();
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Stop build() {
        transit_scheduled.GtfsSchedule.Stop result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Stop buildPartial() {
        transit_scheduled.GtfsSchedule.Stop result = new transit_scheduled.GtfsSchedule.Stop(this);
        result.stopId_ = stopId_;
        result.stopCode_ = stopCode_;
        result.stopName_ = stopName_;
        result.ttsStopName_ = ttsStopName_;
        result.stopDesc_ = stopDesc_;
        result.stopLat_ = stopLat_;
        result.stopLon_ = stopLon_;
        result.zoneId_ = zoneId_;
        result.stopUrl_ = stopUrl_;
        result.locationType_ = locationType_;
        result.parentStation_ = parentStation_;
        result.stopTimezone_ = stopTimezone_;
        result.wheelchairBoarding_ = wheelchairBoarding_;
        result.levelId_ = levelId_;
        result.platformCode_ = platformCode_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof transit_scheduled.GtfsSchedule.Stop) {
          return mergeFrom((transit_scheduled.GtfsSchedule.Stop)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(transit_scheduled.GtfsSchedule.Stop other) {
        if (other == transit_scheduled.GtfsSchedule.Stop.getDefaultInstance()) return this;
        if (!other.getStopId().isEmpty()) {
          stopId_ = other.stopId_;
          onChanged();
        }
        if (!other.getStopCode().isEmpty()) {
          stopCode_ = other.stopCode_;
          onChanged();
        }
        if (!other.getStopName().isEmpty()) {
          stopName_ = other.stopName_;
          onChanged();
        }
        if (!other.getTtsStopName().isEmpty()) {
          ttsStopName_ = other.ttsStopName_;
          onChanged();
        }
        if (!other.getStopDesc().isEmpty()) {
          stopDesc_ = other.stopDesc_;
          onChanged();
        }
        if (other.getStopLat() != 0D) {
          setStopLat(other.getStopLat());
        }
        if (other.getStopLon() != 0D) {
          setStopLon(other.getStopLon());
        }
        if (!other.getZoneId().isEmpty()) {
          zoneId_ = other.zoneId_;
          onChanged();
        }
        if (!other.getStopUrl().isEmpty()) {
          stopUrl_ = other.stopUrl_;
          onChanged();
        }
        if (other.locationType_ != 0) {
          setLocationTypeValue(other.getLocationTypeValue());
        }
        if (!other.getParentStation().isEmpty()) {
          parentStation_ = other.parentStation_;
          onChanged();
        }
        if (!other.getStopTimezone().isEmpty()) {
          stopTimezone_ = other.stopTimezone_;
          onChanged();
        }
        if (other.wheelchairBoarding_ != 0) {
          setWheelchairBoardingValue(other.getWheelchairBoardingValue());
        }
        if (!other.getLevelId().isEmpty()) {
          levelId_ = other.levelId_;
          onChanged();
        }
        if (!other.getPlatformCode().isEmpty()) {
          platformCode_ = other.platformCode_;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                stopId_ = input.readStringRequireUtf8();

                break;
              } // case 10
              case 18: {
                stopCode_ = input.readStringRequireUtf8();

                break;
              } // case 18
              case 26: {
                stopName_ = input.readStringRequireUtf8();

                break;
              } // case 26
              case 34: {
                ttsStopName_ = input.readStringRequireUtf8();

                break;
              } // case 34
              case 42: {
                stopDesc_ = input.readStringRequireUtf8();

                break;
              } // case 42
              case 49: {
                stopLat_ = input.readDouble();

                break;
              } // case 49
              case 57: {
                stopLon_ = input.readDouble();

                break;
              } // case 57
              case 66: {
                zoneId_ = input.readStringRequireUtf8();

                break;
              } // case 66
              case 74: {
                stopUrl_ = input.readStringRequireUtf8();

                break;
              } // case 74
              case 80: {
                locationType_ = input.readEnum();

                break;
              } // case 80
              case 90: {
                parentStation_ = input.readStringRequireUtf8();

                break;
              } // case 90
              case 98: {
                stopTimezone_ = input.readStringRequireUtf8();

                break;
              } // case 98
              case 104: {
                wheelchairBoarding_ = input.readEnum();

                break;
              } // case 104
              case 114: {
                levelId_ = input.readStringRequireUtf8();

                break;
              } // case 114
              case 122: {
                platformCode_ = input.readStringRequireUtf8();

                break;
              } // case 122
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private java.lang.Object stopId_ = "";
      /**
       * <pre>
       * Identifies a location: stop/platform, station, entrance/exit, generic node
       * or boarding area (see location_type).
       * Multiple routes may use the same stop_id.
       * Required
       * </pre>
       *
       * <code>string stop_id = 1;</code>
       * @return The stopId.
       */
      public java.lang.String getStopId() {
        java.lang.Object ref = stopId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stopId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies a location: stop/platform, station, entrance/exit, generic node
       * or boarding area (see location_type).
       * Multiple routes may use the same stop_id.
       * Required
       * </pre>
       *
       * <code>string stop_id = 1;</code>
       * @return The bytes for stopId.
       */
      public com.google.protobuf.ByteString
          getStopIdBytes() {
        java.lang.Object ref = stopId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies a location: stop/platform, station, entrance/exit, generic node
       * or boarding area (see location_type).
       * Multiple routes may use the same stop_id.
       * Required
       * </pre>
       *
       * <code>string stop_id = 1;</code>
       * @param value The stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stopId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a location: stop/platform, station, entrance/exit, generic node
       * or boarding area (see location_type).
       * Multiple routes may use the same stop_id.
       * Required
       * </pre>
       *
       * <code>string stop_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopId() {
        
        stopId_ = getDefaultInstance().getStopId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a location: stop/platform, station, entrance/exit, generic node
       * or boarding area (see location_type).
       * Multiple routes may use the same stop_id.
       * Required
       * </pre>
       *
       * <code>string stop_id = 1;</code>
       * @param value The bytes for stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stopId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object stopCode_ = "";
      /**
       * <pre>
       * Short text or a number that identifies the location for riders. These codes
       * are often used in phone-based transit information systems or printed on
       * signage to make it easier for riders to get information for a particular
       * location. The stop_code may be the same as stop_id if it is public facing.
       * This field should be left empty for locations without a code presented to
       * riders.
       * </pre>
       *
       * <code>string stop_code = 2;</code>
       * @return The stopCode.
       */
      public java.lang.String getStopCode() {
        java.lang.Object ref = stopCode_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stopCode_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Short text or a number that identifies the location for riders. These codes
       * are often used in phone-based transit information systems or printed on
       * signage to make it easier for riders to get information for a particular
       * location. The stop_code may be the same as stop_id if it is public facing.
       * This field should be left empty for locations without a code presented to
       * riders.
       * </pre>
       *
       * <code>string stop_code = 2;</code>
       * @return The bytes for stopCode.
       */
      public com.google.protobuf.ByteString
          getStopCodeBytes() {
        java.lang.Object ref = stopCode_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopCode_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Short text or a number that identifies the location for riders. These codes
       * are often used in phone-based transit information systems or printed on
       * signage to make it easier for riders to get information for a particular
       * location. The stop_code may be the same as stop_id if it is public facing.
       * This field should be left empty for locations without a code presented to
       * riders.
       * </pre>
       *
       * <code>string stop_code = 2;</code>
       * @param value The stopCode to set.
       * @return This builder for chaining.
       */
      public Builder setStopCode(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stopCode_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Short text or a number that identifies the location for riders. These codes
       * are often used in phone-based transit information systems or printed on
       * signage to make it easier for riders to get information for a particular
       * location. The stop_code may be the same as stop_id if it is public facing.
       * This field should be left empty for locations without a code presented to
       * riders.
       * </pre>
       *
       * <code>string stop_code = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopCode() {
        
        stopCode_ = getDefaultInstance().getStopCode();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Short text or a number that identifies the location for riders. These codes
       * are often used in phone-based transit information systems or printed on
       * signage to make it easier for riders to get information for a particular
       * location. The stop_code may be the same as stop_id if it is public facing.
       * This field should be left empty for locations without a code presented to
       * riders.
       * </pre>
       *
       * <code>string stop_code = 2;</code>
       * @param value The bytes for stopCode to set.
       * @return This builder for chaining.
       */
      public Builder setStopCodeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stopCode_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object stopName_ = "";
      /**
       * <pre>
       * Name of the location. The stop_name should match the agency's rider-facing
       * name for the location as printed on a timetable, published online, or
       * represented on signage. For translations into other languages, use
       * translations.txt.
       * When the location is a boarding area (location_type=4), the stop_name
       * should contains the name of the boarding area as displayed by the agency.
       * It could be just one letter (like on some European intercity railway
       * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
       * of short trains” (Paris’ RER).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>string stop_name = 3;</code>
       * @return The stopName.
       */
      public java.lang.String getStopName() {
        java.lang.Object ref = stopName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stopName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name of the location. The stop_name should match the agency's rider-facing
       * name for the location as printed on a timetable, published online, or
       * represented on signage. For translations into other languages, use
       * translations.txt.
       * When the location is a boarding area (location_type=4), the stop_name
       * should contains the name of the boarding area as displayed by the agency.
       * It could be just one letter (like on some European intercity railway
       * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
       * of short trains” (Paris’ RER).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>string stop_name = 3;</code>
       * @return The bytes for stopName.
       */
      public com.google.protobuf.ByteString
          getStopNameBytes() {
        java.lang.Object ref = stopName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name of the location. The stop_name should match the agency's rider-facing
       * name for the location as printed on a timetable, published online, or
       * represented on signage. For translations into other languages, use
       * translations.txt.
       * When the location is a boarding area (location_type=4), the stop_name
       * should contains the name of the boarding area as displayed by the agency.
       * It could be just one letter (like on some European intercity railway
       * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
       * of short trains” (Paris’ RER).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>string stop_name = 3;</code>
       * @param value The stopName to set.
       * @return This builder for chaining.
       */
      public Builder setStopName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stopName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the location. The stop_name should match the agency's rider-facing
       * name for the location as printed on a timetable, published online, or
       * represented on signage. For translations into other languages, use
       * translations.txt.
       * When the location is a boarding area (location_type=4), the stop_name
       * should contains the name of the boarding area as displayed by the agency.
       * It could be just one letter (like on some European intercity railway
       * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
       * of short trains” (Paris’ RER).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>string stop_name = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopName() {
        
        stopName_ = getDefaultInstance().getStopName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the location. The stop_name should match the agency's rider-facing
       * name for the location as printed on a timetable, published online, or
       * represented on signage. For translations into other languages, use
       * translations.txt.
       * When the location is a boarding area (location_type=4), the stop_name
       * should contains the name of the boarding area as displayed by the agency.
       * It could be just one letter (like on some European intercity railway
       * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
       * of short trains” (Paris’ RER).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>string stop_name = 3;</code>
       * @param value The bytes for stopName to set.
       * @return This builder for chaining.
       */
      public Builder setStopNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stopName_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object ttsStopName_ = "";
      /**
       * <pre>
       * Readable version of the stop_name. See "Text-to-speech field" in the Term
       * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
       * </pre>
       *
       * <code>string tts_stop_name = 4;</code>
       * @return The ttsStopName.
       */
      public java.lang.String getTtsStopName() {
        java.lang.Object ref = ttsStopName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          ttsStopName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Readable version of the stop_name. See "Text-to-speech field" in the Term
       * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
       * </pre>
       *
       * <code>string tts_stop_name = 4;</code>
       * @return The bytes for ttsStopName.
       */
      public com.google.protobuf.ByteString
          getTtsStopNameBytes() {
        java.lang.Object ref = ttsStopName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          ttsStopName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Readable version of the stop_name. See "Text-to-speech field" in the Term
       * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
       * </pre>
       *
       * <code>string tts_stop_name = 4;</code>
       * @param value The ttsStopName to set.
       * @return This builder for chaining.
       */
      public Builder setTtsStopName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        ttsStopName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Readable version of the stop_name. See "Text-to-speech field" in the Term
       * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
       * </pre>
       *
       * <code>string tts_stop_name = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearTtsStopName() {
        
        ttsStopName_ = getDefaultInstance().getTtsStopName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Readable version of the stop_name. See "Text-to-speech field" in the Term
       * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
       * </pre>
       *
       * <code>string tts_stop_name = 4;</code>
       * @param value The bytes for ttsStopName to set.
       * @return This builder for chaining.
       */
      public Builder setTtsStopNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        ttsStopName_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object stopDesc_ = "";
      /**
       * <pre>
       * Description of the location that provides useful, quality information.
       * Should not be a duplicate of stop_name.
       * </pre>
       *
       * <code>string stop_desc = 5;</code>
       * @return The stopDesc.
       */
      public java.lang.String getStopDesc() {
        java.lang.Object ref = stopDesc_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stopDesc_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Description of the location that provides useful, quality information.
       * Should not be a duplicate of stop_name.
       * </pre>
       *
       * <code>string stop_desc = 5;</code>
       * @return The bytes for stopDesc.
       */
      public com.google.protobuf.ByteString
          getStopDescBytes() {
        java.lang.Object ref = stopDesc_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopDesc_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Description of the location that provides useful, quality information.
       * Should not be a duplicate of stop_name.
       * </pre>
       *
       * <code>string stop_desc = 5;</code>
       * @param value The stopDesc to set.
       * @return This builder for chaining.
       */
      public Builder setStopDesc(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stopDesc_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of the location that provides useful, quality information.
       * Should not be a duplicate of stop_name.
       * </pre>
       *
       * <code>string stop_desc = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopDesc() {
        
        stopDesc_ = getDefaultInstance().getStopDesc();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of the location that provides useful, quality information.
       * Should not be a duplicate of stop_name.
       * </pre>
       *
       * <code>string stop_desc = 5;</code>
       * @param value The bytes for stopDesc to set.
       * @return This builder for chaining.
       */
      public Builder setStopDescBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stopDesc_ = value;
        onChanged();
        return this;
      }

      private double stopLat_ ;
      /**
       * <pre>
       * Latitude of the location.
       * For stops/platforms (location_type=0) and boarding area (location_type=4),
       * the coordinates must be the ones of the bus pole — if exists — and
       * otherwise of where the travelers are boarding the vehicle (on the sidewalk
       * or the platform, and not on the roadway or the track where the vehicle
       * stops).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>double stop_lat = 6;</code>
       * @return The stopLat.
       */
      @java.lang.Override
      public double getStopLat() {
        return stopLat_;
      }
      /**
       * <pre>
       * Latitude of the location.
       * For stops/platforms (location_type=0) and boarding area (location_type=4),
       * the coordinates must be the ones of the bus pole — if exists — and
       * otherwise of where the travelers are boarding the vehicle (on the sidewalk
       * or the platform, and not on the roadway or the track where the vehicle
       * stops).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>double stop_lat = 6;</code>
       * @param value The stopLat to set.
       * @return This builder for chaining.
       */
      public Builder setStopLat(double value) {
        
        stopLat_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Latitude of the location.
       * For stops/platforms (location_type=0) and boarding area (location_type=4),
       * the coordinates must be the ones of the bus pole — if exists — and
       * otherwise of where the travelers are boarding the vehicle (on the sidewalk
       * or the platform, and not on the roadway or the track where the vehicle
       * stops).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>double stop_lat = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopLat() {
        
        stopLat_ = 0D;
        onChanged();
        return this;
      }

      private double stopLon_ ;
      /**
       * <pre>
       * Longitude of the location.
       * For stops/platforms (location_type=0) and boarding area (location_type=4),
       * the coordinates must be the ones of the bus pole — if exists — and
       * otherwise of where the travelers are boarding the vehicle (on the sidewalk
       * or the platform, and not on the roadway or the track where the vehicle
       * stops).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>double stop_lon = 7;</code>
       * @return The stopLon.
       */
      @java.lang.Override
      public double getStopLon() {
        return stopLon_;
      }
      /**
       * <pre>
       * Longitude of the location.
       * For stops/platforms (location_type=0) and boarding area (location_type=4),
       * the coordinates must be the ones of the bus pole — if exists — and
       * otherwise of where the travelers are boarding the vehicle (on the sidewalk
       * or the platform, and not on the roadway or the track where the vehicle
       * stops).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>double stop_lon = 7;</code>
       * @param value The stopLon to set.
       * @return This builder for chaining.
       */
      public Builder setStopLon(double value) {
        
        stopLon_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Longitude of the location.
       * For stops/platforms (location_type=0) and boarding area (location_type=4),
       * the coordinates must be the ones of the bus pole — if exists — and
       * otherwise of where the travelers are boarding the vehicle (on the sidewalk
       * or the platform, and not on the roadway or the track where the vehicle
       * stops).
       * Conditionally Required:
       * - Required for locations which are stops (location_type=0), stations
       * (location_type=1) or entrances/exits (location_type=2).
       * - Optional for locations which are generic nodes (location_type=3) or
       * boarding areas (location_type=4).
       * </pre>
       *
       * <code>double stop_lon = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopLon() {
        
        stopLon_ = 0D;
        onChanged();
        return this;
      }

      private java.lang.Object zoneId_ = "";
      /**
       * <pre>
       * Identifies the fare zone for a stop. If this record represents a station or
       * station entrance, the zone_id is ignored.
       * Conditionally Required:
       * - Required if providing fare information using fare_rules.txt
       * - Optional otherwise.
       * </pre>
       *
       * <code>string zone_id = 8;</code>
       * @return The zoneId.
       */
      public java.lang.String getZoneId() {
        java.lang.Object ref = zoneId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          zoneId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies the fare zone for a stop. If this record represents a station or
       * station entrance, the zone_id is ignored.
       * Conditionally Required:
       * - Required if providing fare information using fare_rules.txt
       * - Optional otherwise.
       * </pre>
       *
       * <code>string zone_id = 8;</code>
       * @return The bytes for zoneId.
       */
      public com.google.protobuf.ByteString
          getZoneIdBytes() {
        java.lang.Object ref = zoneId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          zoneId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies the fare zone for a stop. If this record represents a station or
       * station entrance, the zone_id is ignored.
       * Conditionally Required:
       * - Required if providing fare information using fare_rules.txt
       * - Optional otherwise.
       * </pre>
       *
       * <code>string zone_id = 8;</code>
       * @param value The zoneId to set.
       * @return This builder for chaining.
       */
      public Builder setZoneId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        zoneId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the fare zone for a stop. If this record represents a station or
       * station entrance, the zone_id is ignored.
       * Conditionally Required:
       * - Required if providing fare information using fare_rules.txt
       * - Optional otherwise.
       * </pre>
       *
       * <code>string zone_id = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearZoneId() {
        
        zoneId_ = getDefaultInstance().getZoneId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the fare zone for a stop. If this record represents a station or
       * station entrance, the zone_id is ignored.
       * Conditionally Required:
       * - Required if providing fare information using fare_rules.txt
       * - Optional otherwise.
       * </pre>
       *
       * <code>string zone_id = 8;</code>
       * @param value The bytes for zoneId to set.
       * @return This builder for chaining.
       */
      public Builder setZoneIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        zoneId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object stopUrl_ = "";
      /**
       * <pre>
       * URL of a web page about the location. This should be different from the
       * agency.agency_url and the routes.route_url field values.
       * </pre>
       *
       * <code>string stop_url = 9;</code>
       * @return The stopUrl.
       */
      public java.lang.String getStopUrl() {
        java.lang.Object ref = stopUrl_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stopUrl_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * URL of a web page about the location. This should be different from the
       * agency.agency_url and the routes.route_url field values.
       * </pre>
       *
       * <code>string stop_url = 9;</code>
       * @return The bytes for stopUrl.
       */
      public com.google.protobuf.ByteString
          getStopUrlBytes() {
        java.lang.Object ref = stopUrl_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopUrl_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * URL of a web page about the location. This should be different from the
       * agency.agency_url and the routes.route_url field values.
       * </pre>
       *
       * <code>string stop_url = 9;</code>
       * @param value The stopUrl to set.
       * @return This builder for chaining.
       */
      public Builder setStopUrl(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stopUrl_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * URL of a web page about the location. This should be different from the
       * agency.agency_url and the routes.route_url field values.
       * </pre>
       *
       * <code>string stop_url = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopUrl() {
        
        stopUrl_ = getDefaultInstance().getStopUrl();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * URL of a web page about the location. This should be different from the
       * agency.agency_url and the routes.route_url field values.
       * </pre>
       *
       * <code>string stop_url = 9;</code>
       * @param value The bytes for stopUrl to set.
       * @return This builder for chaining.
       */
      public Builder setStopUrlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stopUrl_ = value;
        onChanged();
        return this;
      }

      private int locationType_ = 0;
      /**
       * <pre>
       * Location type.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.LocationType location_type = 10;</code>
       * @return The enum numeric value on the wire for locationType.
       */
      @java.lang.Override public int getLocationTypeValue() {
        return locationType_;
      }
      /**
       * <pre>
       * Location type.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.LocationType location_type = 10;</code>
       * @param value The enum numeric value on the wire for locationType to set.
       * @return This builder for chaining.
       */
      public Builder setLocationTypeValue(int value) {
        
        locationType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Location type.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.LocationType location_type = 10;</code>
       * @return The locationType.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Stop.LocationType getLocationType() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.Stop.LocationType result = transit_scheduled.GtfsSchedule.Stop.LocationType.valueOf(locationType_);
        return result == null ? transit_scheduled.GtfsSchedule.Stop.LocationType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Location type.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.LocationType location_type = 10;</code>
       * @param value The locationType to set.
       * @return This builder for chaining.
       */
      public Builder setLocationType(transit_scheduled.GtfsSchedule.Stop.LocationType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        locationType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Location type.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.LocationType location_type = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocationType() {
        
        locationType_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object parentStation_ = "";
      /**
       * <pre>
       * Defines hierarchy between the different locations defined in stops.txt. It
       * contains the ID of the parent location, as followed:
       * - Stop/platform (location_type=0): the parent_station field contains the ID
       * of a station.
       * - Station (location_type=1): this field must be empty.
       * - Entrance/exit (location_type=2) or generic node (location_type=3): the
       * parent_station field contains the ID of a station (location_type=1)
       * - Boarding Area (location_type=4): the parent_station field contains ID of
       * a platform.
       * Conditionally Required:
       * - Required for locations which are entrances (location_type=2), generic
       * nodes (location_type=3) or boarding areas (location_type=4).
       * - Optional for stops/platforms (location_type=0).
       * - Forbidden for stations (location_type=1).
       * </pre>
       *
       * <code>string parent_station = 11;</code>
       * @return The parentStation.
       */
      public java.lang.String getParentStation() {
        java.lang.Object ref = parentStation_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          parentStation_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Defines hierarchy between the different locations defined in stops.txt. It
       * contains the ID of the parent location, as followed:
       * - Stop/platform (location_type=0): the parent_station field contains the ID
       * of a station.
       * - Station (location_type=1): this field must be empty.
       * - Entrance/exit (location_type=2) or generic node (location_type=3): the
       * parent_station field contains the ID of a station (location_type=1)
       * - Boarding Area (location_type=4): the parent_station field contains ID of
       * a platform.
       * Conditionally Required:
       * - Required for locations which are entrances (location_type=2), generic
       * nodes (location_type=3) or boarding areas (location_type=4).
       * - Optional for stops/platforms (location_type=0).
       * - Forbidden for stations (location_type=1).
       * </pre>
       *
       * <code>string parent_station = 11;</code>
       * @return The bytes for parentStation.
       */
      public com.google.protobuf.ByteString
          getParentStationBytes() {
        java.lang.Object ref = parentStation_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          parentStation_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Defines hierarchy between the different locations defined in stops.txt. It
       * contains the ID of the parent location, as followed:
       * - Stop/platform (location_type=0): the parent_station field contains the ID
       * of a station.
       * - Station (location_type=1): this field must be empty.
       * - Entrance/exit (location_type=2) or generic node (location_type=3): the
       * parent_station field contains the ID of a station (location_type=1)
       * - Boarding Area (location_type=4): the parent_station field contains ID of
       * a platform.
       * Conditionally Required:
       * - Required for locations which are entrances (location_type=2), generic
       * nodes (location_type=3) or boarding areas (location_type=4).
       * - Optional for stops/platforms (location_type=0).
       * - Forbidden for stations (location_type=1).
       * </pre>
       *
       * <code>string parent_station = 11;</code>
       * @param value The parentStation to set.
       * @return This builder for chaining.
       */
      public Builder setParentStation(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        parentStation_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Defines hierarchy between the different locations defined in stops.txt. It
       * contains the ID of the parent location, as followed:
       * - Stop/platform (location_type=0): the parent_station field contains the ID
       * of a station.
       * - Station (location_type=1): this field must be empty.
       * - Entrance/exit (location_type=2) or generic node (location_type=3): the
       * parent_station field contains the ID of a station (location_type=1)
       * - Boarding Area (location_type=4): the parent_station field contains ID of
       * a platform.
       * Conditionally Required:
       * - Required for locations which are entrances (location_type=2), generic
       * nodes (location_type=3) or boarding areas (location_type=4).
       * - Optional for stops/platforms (location_type=0).
       * - Forbidden for stations (location_type=1).
       * </pre>
       *
       * <code>string parent_station = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearParentStation() {
        
        parentStation_ = getDefaultInstance().getParentStation();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Defines hierarchy between the different locations defined in stops.txt. It
       * contains the ID of the parent location, as followed:
       * - Stop/platform (location_type=0): the parent_station field contains the ID
       * of a station.
       * - Station (location_type=1): this field must be empty.
       * - Entrance/exit (location_type=2) or generic node (location_type=3): the
       * parent_station field contains the ID of a station (location_type=1)
       * - Boarding Area (location_type=4): the parent_station field contains ID of
       * a platform.
       * Conditionally Required:
       * - Required for locations which are entrances (location_type=2), generic
       * nodes (location_type=3) or boarding areas (location_type=4).
       * - Optional for stops/platforms (location_type=0).
       * - Forbidden for stations (location_type=1).
       * </pre>
       *
       * <code>string parent_station = 11;</code>
       * @param value The bytes for parentStation to set.
       * @return This builder for chaining.
       */
      public Builder setParentStationBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        parentStation_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object stopTimezone_ = "";
      /**
       * <pre>
       * Timezone of the location. If the location has a parent station, it inherits
       * the parent station’s timezone instead of applying its own. Stations and
       * parentless stops with empty stop_timezone inherit the timezone specified by
       * agency.agency_timezone. If stop_timezone values are provided, the times in
       * stop_times.txt should be entered as the time since midnight in the timezone
       * specified by agency.agency_timezone. This ensures that the time values in a
       * trip always increase over the course of a trip, regardless of which
       * timezones the trip crosses.
       * </pre>
       *
       * <code>string stop_timezone = 12;</code>
       * @return The stopTimezone.
       */
      public java.lang.String getStopTimezone() {
        java.lang.Object ref = stopTimezone_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stopTimezone_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Timezone of the location. If the location has a parent station, it inherits
       * the parent station’s timezone instead of applying its own. Stations and
       * parentless stops with empty stop_timezone inherit the timezone specified by
       * agency.agency_timezone. If stop_timezone values are provided, the times in
       * stop_times.txt should be entered as the time since midnight in the timezone
       * specified by agency.agency_timezone. This ensures that the time values in a
       * trip always increase over the course of a trip, regardless of which
       * timezones the trip crosses.
       * </pre>
       *
       * <code>string stop_timezone = 12;</code>
       * @return The bytes for stopTimezone.
       */
      public com.google.protobuf.ByteString
          getStopTimezoneBytes() {
        java.lang.Object ref = stopTimezone_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopTimezone_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Timezone of the location. If the location has a parent station, it inherits
       * the parent station’s timezone instead of applying its own. Stations and
       * parentless stops with empty stop_timezone inherit the timezone specified by
       * agency.agency_timezone. If stop_timezone values are provided, the times in
       * stop_times.txt should be entered as the time since midnight in the timezone
       * specified by agency.agency_timezone. This ensures that the time values in a
       * trip always increase over the course of a trip, regardless of which
       * timezones the trip crosses.
       * </pre>
       *
       * <code>string stop_timezone = 12;</code>
       * @param value The stopTimezone to set.
       * @return This builder for chaining.
       */
      public Builder setStopTimezone(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stopTimezone_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timezone of the location. If the location has a parent station, it inherits
       * the parent station’s timezone instead of applying its own. Stations and
       * parentless stops with empty stop_timezone inherit the timezone specified by
       * agency.agency_timezone. If stop_timezone values are provided, the times in
       * stop_times.txt should be entered as the time since midnight in the timezone
       * specified by agency.agency_timezone. This ensures that the time values in a
       * trip always increase over the course of a trip, regardless of which
       * timezones the trip crosses.
       * </pre>
       *
       * <code>string stop_timezone = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopTimezone() {
        
        stopTimezone_ = getDefaultInstance().getStopTimezone();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timezone of the location. If the location has a parent station, it inherits
       * the parent station’s timezone instead of applying its own. Stations and
       * parentless stops with empty stop_timezone inherit the timezone specified by
       * agency.agency_timezone. If stop_timezone values are provided, the times in
       * stop_times.txt should be entered as the time since midnight in the timezone
       * specified by agency.agency_timezone. This ensures that the time values in a
       * trip always increase over the course of a trip, regardless of which
       * timezones the trip crosses.
       * </pre>
       *
       * <code>string stop_timezone = 12;</code>
       * @param value The bytes for stopTimezone to set.
       * @return This builder for chaining.
       */
      public Builder setStopTimezoneBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stopTimezone_ = value;
        onChanged();
        return this;
      }

      private int wheelchairBoarding_ = 0;
      /**
       * <pre>
       * Indicates whether wheelchair boardings are possible from the location.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;</code>
       * @return The enum numeric value on the wire for wheelchairBoarding.
       */
      @java.lang.Override public int getWheelchairBoardingValue() {
        return wheelchairBoarding_;
      }
      /**
       * <pre>
       * Indicates whether wheelchair boardings are possible from the location.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;</code>
       * @param value The enum numeric value on the wire for wheelchairBoarding to set.
       * @return This builder for chaining.
       */
      public Builder setWheelchairBoardingValue(int value) {
        
        wheelchairBoarding_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates whether wheelchair boardings are possible from the location.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;</code>
       * @return The wheelchairBoarding.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding getWheelchairBoarding() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding result = transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding.valueOf(wheelchairBoarding_);
        return result == null ? transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates whether wheelchair boardings are possible from the location.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;</code>
       * @param value The wheelchairBoarding to set.
       * @return This builder for chaining.
       */
      public Builder setWheelchairBoarding(transit_scheduled.GtfsSchedule.Stop.WheelchairBoarding value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        wheelchairBoarding_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates whether wheelchair boardings are possible from the location.
       * </pre>
       *
       * <code>.transit_scheduled.Stop.WheelchairBoarding wheelchair_boarding = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearWheelchairBoarding() {
        
        wheelchairBoarding_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object levelId_ = "";
      /**
       * <pre>
       * Level of the location. The same level may be used by multiple unlinked
       * stations.
       * </pre>
       *
       * <code>string level_id = 14;</code>
       * @return The levelId.
       */
      public java.lang.String getLevelId() {
        java.lang.Object ref = levelId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          levelId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Level of the location. The same level may be used by multiple unlinked
       * stations.
       * </pre>
       *
       * <code>string level_id = 14;</code>
       * @return The bytes for levelId.
       */
      public com.google.protobuf.ByteString
          getLevelIdBytes() {
        java.lang.Object ref = levelId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          levelId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Level of the location. The same level may be used by multiple unlinked
       * stations.
       * </pre>
       *
       * <code>string level_id = 14;</code>
       * @param value The levelId to set.
       * @return This builder for chaining.
       */
      public Builder setLevelId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        levelId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Level of the location. The same level may be used by multiple unlinked
       * stations.
       * </pre>
       *
       * <code>string level_id = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearLevelId() {
        
        levelId_ = getDefaultInstance().getLevelId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Level of the location. The same level may be used by multiple unlinked
       * stations.
       * </pre>
       *
       * <code>string level_id = 14;</code>
       * @param value The bytes for levelId to set.
       * @return This builder for chaining.
       */
      public Builder setLevelIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        levelId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object platformCode_ = "";
      /**
       * <pre>
       * Platform identifier for a platform stop (a stop belonging to a station).
       * This should be just the platform identifier (eg. "G" or "3"). Words like
       * “platform” or "track" (or the feed’s language-specific equivalent) should
       * not be included. This allows feed consumers to more easily internationalize
       * and localize the platform identifier into other languages.
       * </pre>
       *
       * <code>string platform_code = 15;</code>
       * @return The platformCode.
       */
      public java.lang.String getPlatformCode() {
        java.lang.Object ref = platformCode_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          platformCode_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Platform identifier for a platform stop (a stop belonging to a station).
       * This should be just the platform identifier (eg. "G" or "3"). Words like
       * “platform” or "track" (or the feed’s language-specific equivalent) should
       * not be included. This allows feed consumers to more easily internationalize
       * and localize the platform identifier into other languages.
       * </pre>
       *
       * <code>string platform_code = 15;</code>
       * @return The bytes for platformCode.
       */
      public com.google.protobuf.ByteString
          getPlatformCodeBytes() {
        java.lang.Object ref = platformCode_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          platformCode_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Platform identifier for a platform stop (a stop belonging to a station).
       * This should be just the platform identifier (eg. "G" or "3"). Words like
       * “platform” or "track" (or the feed’s language-specific equivalent) should
       * not be included. This allows feed consumers to more easily internationalize
       * and localize the platform identifier into other languages.
       * </pre>
       *
       * <code>string platform_code = 15;</code>
       * @param value The platformCode to set.
       * @return This builder for chaining.
       */
      public Builder setPlatformCode(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        platformCode_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Platform identifier for a platform stop (a stop belonging to a station).
       * This should be just the platform identifier (eg. "G" or "3"). Words like
       * “platform” or "track" (or the feed’s language-specific equivalent) should
       * not be included. This allows feed consumers to more easily internationalize
       * and localize the platform identifier into other languages.
       * </pre>
       *
       * <code>string platform_code = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearPlatformCode() {
        
        platformCode_ = getDefaultInstance().getPlatformCode();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Platform identifier for a platform stop (a stop belonging to a station).
       * This should be just the platform identifier (eg. "G" or "3"). Words like
       * “platform” or "track" (or the feed’s language-specific equivalent) should
       * not be included. This allows feed consumers to more easily internationalize
       * and localize the platform identifier into other languages.
       * </pre>
       *
       * <code>string platform_code = 15;</code>
       * @param value The bytes for platformCode to set.
       * @return This builder for chaining.
       */
      public Builder setPlatformCodeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        platformCode_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:transit_scheduled.Stop)
    }

    // @@protoc_insertion_point(class_scope:transit_scheduled.Stop)
    private static final transit_scheduled.GtfsSchedule.Stop DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new transit_scheduled.GtfsSchedule.Stop();
    }

    public static transit_scheduled.GtfsSchedule.Stop getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Stop>
        PARSER = new com.google.protobuf.AbstractParser<Stop>() {
      @java.lang.Override
      public Stop parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Stop> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Stop> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public transit_scheduled.GtfsSchedule.Stop getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RouteOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_scheduled.Route)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Identifies a route.
     * Required
     * </pre>
     *
     * <code>string route_id = 1;</code>
     * @return The routeId.
     */
    java.lang.String getRouteId();
    /**
     * <pre>
     * Identifies a route.
     * Required
     * </pre>
     *
     * <code>string route_id = 1;</code>
     * @return The bytes for routeId.
     */
    com.google.protobuf.ByteString
        getRouteIdBytes();

    /**
     * <pre>
     * Agency for the specified route.
     * Conditionally Required:
     * - Required if multiple agencies are defined in agency.txt.
     * - Recommended otherwise.
     * </pre>
     *
     * <code>string agency_id = 2;</code>
     * @return The agencyId.
     */
    java.lang.String getAgencyId();
    /**
     * <pre>
     * Agency for the specified route.
     * Conditionally Required:
     * - Required if multiple agencies are defined in agency.txt.
     * - Recommended otherwise.
     * </pre>
     *
     * <code>string agency_id = 2;</code>
     * @return The bytes for agencyId.
     */
    com.google.protobuf.ByteString
        getAgencyIdBytes();

    /**
     * <pre>
     * Short name of a route. Often a short, abstract identifier (e.g., "32",
     * "100X", "Green") that riders use to identify a route. Both route_short_name
     * and route_long_name may be defined.
     * Conditionally Required:
     * - Required if routes.route_long_name is empty.
     * - Recommended if there is a brief service designation. This should be the
     * commonly-known passenger name of the service, and should be no longer than
     * 12 characters.
     * </pre>
     *
     * <code>string route_short_name = 3;</code>
     * @return The routeShortName.
     */
    java.lang.String getRouteShortName();
    /**
     * <pre>
     * Short name of a route. Often a short, abstract identifier (e.g., "32",
     * "100X", "Green") that riders use to identify a route. Both route_short_name
     * and route_long_name may be defined.
     * Conditionally Required:
     * - Required if routes.route_long_name is empty.
     * - Recommended if there is a brief service designation. This should be the
     * commonly-known passenger name of the service, and should be no longer than
     * 12 characters.
     * </pre>
     *
     * <code>string route_short_name = 3;</code>
     * @return The bytes for routeShortName.
     */
    com.google.protobuf.ByteString
        getRouteShortNameBytes();

    /**
     * <pre>
     * Full name of a route. This name is generally more descriptive than the
     * route_short_name and often includes the route's destination or stop. Both
     * route_short_name and route_long_name may be defined.
     * Conditionally Required:
     * - Required if routes.route_short_name is empty.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string route_long_name = 4;</code>
     * @return The routeLongName.
     */
    java.lang.String getRouteLongName();
    /**
     * <pre>
     * Full name of a route. This name is generally more descriptive than the
     * route_short_name and often includes the route's destination or stop. Both
     * route_short_name and route_long_name may be defined.
     * Conditionally Required:
     * - Required if routes.route_short_name is empty.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string route_long_name = 4;</code>
     * @return The bytes for routeLongName.
     */
    com.google.protobuf.ByteString
        getRouteLongNameBytes();

    /**
     * <pre>
     * Description of a route that provides useful, quality information. Should
     * not be a duplicate of route_short_name or route_long_name.
     * </pre>
     *
     * <code>string route_desc = 5;</code>
     * @return The routeDesc.
     */
    java.lang.String getRouteDesc();
    /**
     * <pre>
     * Description of a route that provides useful, quality information. Should
     * not be a duplicate of route_short_name or route_long_name.
     * </pre>
     *
     * <code>string route_desc = 5;</code>
     * @return The bytes for routeDesc.
     */
    com.google.protobuf.ByteString
        getRouteDescBytes();

    /**
     * <pre>
     * Indicates the type of transportation used on a route.
     * Required
     * </pre>
     *
     * <code>.transit_scheduled.Route.RouteType route_type = 6;</code>
     * @return The enum numeric value on the wire for routeType.
     */
    int getRouteTypeValue();
    /**
     * <pre>
     * Indicates the type of transportation used on a route.
     * Required
     * </pre>
     *
     * <code>.transit_scheduled.Route.RouteType route_type = 6;</code>
     * @return The routeType.
     */
    transit_scheduled.GtfsSchedule.Route.RouteType getRouteType();

    /**
     * <pre>
     * URL of a web page about the particular route. Should be different from the
     * agency.agency_url value.
     * </pre>
     *
     * <code>string route_url = 7;</code>
     * @return The routeUrl.
     */
    java.lang.String getRouteUrl();
    /**
     * <pre>
     * URL of a web page about the particular route. Should be different from the
     * agency.agency_url value.
     * </pre>
     *
     * <code>string route_url = 7;</code>
     * @return The bytes for routeUrl.
     */
    com.google.protobuf.ByteString
        getRouteUrlBytes();

    /**
     * <pre>
     * Route color designation that matches public facing material. Defaults to
     * white (FFFFFF) when omitted or left empty. The color difference between
     * route_color and route_text_color should provide sufficient contrast when
     * viewed on a black and white screen.
     * </pre>
     *
     * <code>string route_color = 8;</code>
     * @return The routeColor.
     */
    java.lang.String getRouteColor();
    /**
     * <pre>
     * Route color designation that matches public facing material. Defaults to
     * white (FFFFFF) when omitted or left empty. The color difference between
     * route_color and route_text_color should provide sufficient contrast when
     * viewed on a black and white screen.
     * </pre>
     *
     * <code>string route_color = 8;</code>
     * @return The bytes for routeColor.
     */
    com.google.protobuf.ByteString
        getRouteColorBytes();

    /**
     * <pre>
     * Legible color to use for text drawn against a background of route_color.
     * Defaults to black (000000) when omitted or left empty. The color difference
     * between route_color and route_text_color should provide sufficient contrast
     * when viewed on a black and white screen.
     * </pre>
     *
     * <code>string route_text_color = 9;</code>
     * @return The routeTextColor.
     */
    java.lang.String getRouteTextColor();
    /**
     * <pre>
     * Legible color to use for text drawn against a background of route_color.
     * Defaults to black (000000) when omitted or left empty. The color difference
     * between route_color and route_text_color should provide sufficient contrast
     * when viewed on a black and white screen.
     * </pre>
     *
     * <code>string route_text_color = 9;</code>
     * @return The bytes for routeTextColor.
     */
    com.google.protobuf.ByteString
        getRouteTextColorBytes();

    /**
     * <pre>
     * Orders the routes in a way which is ideal for presentation to customers.
     * Routes with smaller route_sort_order values should be displayed first.
     * </pre>
     *
     * <code>uint32 route_sort_order = 10;</code>
     * @return The routeSortOrder.
     */
    int getRouteSortOrder();

    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, on every trip of the
     * route.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 11;</code>
     * @return The enum numeric value on the wire for continuousPickup.
     */
    int getContinuousPickupValue();
    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, on every trip of the
     * route.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 11;</code>
     * @return The continuousPickup.
     */
    transit_scheduled.GtfsSchedule.ContinuousPickup getContinuousPickup();

    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, on every trip
     * of the route.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 12;</code>
     * @return The enum numeric value on the wire for continuousDropOff.
     */
    int getContinuousDropOffValue();
    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, on every trip
     * of the route.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 12;</code>
     * @return The continuousDropOff.
     */
    transit_scheduled.GtfsSchedule.ContinuousDropOff getContinuousDropOff();

    /**
     * <pre>
     * Identifies a group of routes. Multiple rows in routes.txt may have the same
     * network_id.
     * </pre>
     *
     * <code>string network_id = 13;</code>
     * @return The networkId.
     */
    java.lang.String getNetworkId();
    /**
     * <pre>
     * Identifies a group of routes. Multiple rows in routes.txt may have the same
     * network_id.
     * </pre>
     *
     * <code>string network_id = 13;</code>
     * @return The bytes for networkId.
     */
    com.google.protobuf.ByteString
        getNetworkIdBytes();
  }
  /**
   * <pre>
   * Transit routes. A route is a group of trips that are displayed to riders as a
   * single service.
   * </pre>
   *
   * Protobuf type {@code transit_scheduled.Route}
   */
  public static final class Route extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:transit_scheduled.Route)
      RouteOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Route.newBuilder() to construct.
    private Route(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Route() {
      routeId_ = "";
      agencyId_ = "";
      routeShortName_ = "";
      routeLongName_ = "";
      routeDesc_ = "";
      routeType_ = 0;
      routeUrl_ = "";
      routeColor_ = "";
      routeTextColor_ = "";
      continuousPickup_ = 0;
      continuousDropOff_ = 0;
      networkId_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Route();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Route_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Route_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              transit_scheduled.GtfsSchedule.Route.class, transit_scheduled.GtfsSchedule.Route.Builder.class);
    }

    /**
     * <pre>
     * Indicates the type of transportation used on a route. Valid options are:
     *   0 - Tram, Streetcar, Light rail. Any light rail or street level system
     *   within a metropolitan area.
     *   1 - Subway, Metro. Any underground rail system within a metropolitan
     *   area.
     *   2 - Rail. Used for intercity or long-distance travel.
     *   3 - Bus. Used for short- and long-distance bus routes.
     *   4 - Ferry. Used for short- and long-distance boat service.
     *   5 - Cable tram. Used for street-level rail cars where the cable runs
     *   beneath the vehicle (e.g., cable car in San Francisco).
     *   6 - Aerial lift, suspended cable car (e.g., gondola lift, aerial
     *   tramway). Cable transport where cabins, cars, gondolas or open chairs are
     *   suspended by means of one or more cables.
     *   7 - Funicular. Any rail system designed for steep inclines.
     *   11 - Trolleybus. Electric buses that draw power from overhead wires using
     *   poles.
     *   12 - Monorail. Railway in which the track consists of a single rail or a
     *   beam.
     * </pre>
     *
     * Protobuf enum {@code transit_scheduled.Route.RouteType}
     */
    public enum RouteType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL = 0;</code>
       */
      ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL(0),
      /**
       * <code>ROUTE_TYPE_SUBWAY_METRO = 1;</code>
       */
      ROUTE_TYPE_SUBWAY_METRO(1),
      /**
       * <code>ROUTE_TYPE_RAIL = 2;</code>
       */
      ROUTE_TYPE_RAIL(2),
      /**
       * <code>ROUTE_TYPE_BUS = 3;</code>
       */
      ROUTE_TYPE_BUS(3),
      /**
       * <code>ROUTE_TYPE_FERRY = 4;</code>
       */
      ROUTE_TYPE_FERRY(4),
      /**
       * <code>ROUTE_TYPE_CABLE_TRAM = 5;</code>
       */
      ROUTE_TYPE_CABLE_TRAM(5),
      /**
       * <code>ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABLE_CAR = 6;</code>
       */
      ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABLE_CAR(6),
      /**
       * <code>ROUTE_TYPE_FUNICULAR = 7;</code>
       */
      ROUTE_TYPE_FUNICULAR(7),
      /**
       * <code>ROUTE_TYPE_TROLLEYBUS = 11;</code>
       */
      ROUTE_TYPE_TROLLEYBUS(11),
      /**
       * <code>ROUTE_TYPE_MONORAIL = 12;</code>
       */
      ROUTE_TYPE_MONORAIL(12),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL = 0;</code>
       */
      public static final int ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL_VALUE = 0;
      /**
       * <code>ROUTE_TYPE_SUBWAY_METRO = 1;</code>
       */
      public static final int ROUTE_TYPE_SUBWAY_METRO_VALUE = 1;
      /**
       * <code>ROUTE_TYPE_RAIL = 2;</code>
       */
      public static final int ROUTE_TYPE_RAIL_VALUE = 2;
      /**
       * <code>ROUTE_TYPE_BUS = 3;</code>
       */
      public static final int ROUTE_TYPE_BUS_VALUE = 3;
      /**
       * <code>ROUTE_TYPE_FERRY = 4;</code>
       */
      public static final int ROUTE_TYPE_FERRY_VALUE = 4;
      /**
       * <code>ROUTE_TYPE_CABLE_TRAM = 5;</code>
       */
      public static final int ROUTE_TYPE_CABLE_TRAM_VALUE = 5;
      /**
       * <code>ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABLE_CAR = 6;</code>
       */
      public static final int ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABLE_CAR_VALUE = 6;
      /**
       * <code>ROUTE_TYPE_FUNICULAR = 7;</code>
       */
      public static final int ROUTE_TYPE_FUNICULAR_VALUE = 7;
      /**
       * <code>ROUTE_TYPE_TROLLEYBUS = 11;</code>
       */
      public static final int ROUTE_TYPE_TROLLEYBUS_VALUE = 11;
      /**
       * <code>ROUTE_TYPE_MONORAIL = 12;</code>
       */
      public static final int ROUTE_TYPE_MONORAIL_VALUE = 12;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static RouteType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static RouteType forNumber(int value) {
        switch (value) {
          case 0: return ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL;
          case 1: return ROUTE_TYPE_SUBWAY_METRO;
          case 2: return ROUTE_TYPE_RAIL;
          case 3: return ROUTE_TYPE_BUS;
          case 4: return ROUTE_TYPE_FERRY;
          case 5: return ROUTE_TYPE_CABLE_TRAM;
          case 6: return ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABLE_CAR;
          case 7: return ROUTE_TYPE_FUNICULAR;
          case 11: return ROUTE_TYPE_TROLLEYBUS;
          case 12: return ROUTE_TYPE_MONORAIL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<RouteType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          RouteType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<RouteType>() {
              public RouteType findValueByNumber(int number) {
                return RouteType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.Route.getDescriptor().getEnumTypes().get(0);
      }

      private static final RouteType[] VALUES = values();

      public static RouteType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private RouteType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_scheduled.Route.RouteType)
    }

    public static final int ROUTE_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object routeId_;
    /**
     * <pre>
     * Identifies a route.
     * Required
     * </pre>
     *
     * <code>string route_id = 1;</code>
     * @return The routeId.
     */
    @java.lang.Override
    public java.lang.String getRouteId() {
      java.lang.Object ref = routeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        routeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies a route.
     * Required
     * </pre>
     *
     * <code>string route_id = 1;</code>
     * @return The bytes for routeId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteIdBytes() {
      java.lang.Object ref = routeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENCY_ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object agencyId_;
    /**
     * <pre>
     * Agency for the specified route.
     * Conditionally Required:
     * - Required if multiple agencies are defined in agency.txt.
     * - Recommended otherwise.
     * </pre>
     *
     * <code>string agency_id = 2;</code>
     * @return The agencyId.
     */
    @java.lang.Override
    public java.lang.String getAgencyId() {
      java.lang.Object ref = agencyId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agencyId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Agency for the specified route.
     * Conditionally Required:
     * - Required if multiple agencies are defined in agency.txt.
     * - Recommended otherwise.
     * </pre>
     *
     * <code>string agency_id = 2;</code>
     * @return The bytes for agencyId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgencyIdBytes() {
      java.lang.Object ref = agencyId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agencyId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_SHORT_NAME_FIELD_NUMBER = 3;
    private volatile java.lang.Object routeShortName_;
    /**
     * <pre>
     * Short name of a route. Often a short, abstract identifier (e.g., "32",
     * "100X", "Green") that riders use to identify a route. Both route_short_name
     * and route_long_name may be defined.
     * Conditionally Required:
     * - Required if routes.route_long_name is empty.
     * - Recommended if there is a brief service designation. This should be the
     * commonly-known passenger name of the service, and should be no longer than
     * 12 characters.
     * </pre>
     *
     * <code>string route_short_name = 3;</code>
     * @return The routeShortName.
     */
    @java.lang.Override
    public java.lang.String getRouteShortName() {
      java.lang.Object ref = routeShortName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        routeShortName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Short name of a route. Often a short, abstract identifier (e.g., "32",
     * "100X", "Green") that riders use to identify a route. Both route_short_name
     * and route_long_name may be defined.
     * Conditionally Required:
     * - Required if routes.route_long_name is empty.
     * - Recommended if there is a brief service designation. This should be the
     * commonly-known passenger name of the service, and should be no longer than
     * 12 characters.
     * </pre>
     *
     * <code>string route_short_name = 3;</code>
     * @return The bytes for routeShortName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteShortNameBytes() {
      java.lang.Object ref = routeShortName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeShortName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_LONG_NAME_FIELD_NUMBER = 4;
    private volatile java.lang.Object routeLongName_;
    /**
     * <pre>
     * Full name of a route. This name is generally more descriptive than the
     * route_short_name and often includes the route's destination or stop. Both
     * route_short_name and route_long_name may be defined.
     * Conditionally Required:
     * - Required if routes.route_short_name is empty.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string route_long_name = 4;</code>
     * @return The routeLongName.
     */
    @java.lang.Override
    public java.lang.String getRouteLongName() {
      java.lang.Object ref = routeLongName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        routeLongName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Full name of a route. This name is generally more descriptive than the
     * route_short_name and often includes the route's destination or stop. Both
     * route_short_name and route_long_name may be defined.
     * Conditionally Required:
     * - Required if routes.route_short_name is empty.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string route_long_name = 4;</code>
     * @return The bytes for routeLongName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteLongNameBytes() {
      java.lang.Object ref = routeLongName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeLongName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_DESC_FIELD_NUMBER = 5;
    private volatile java.lang.Object routeDesc_;
    /**
     * <pre>
     * Description of a route that provides useful, quality information. Should
     * not be a duplicate of route_short_name or route_long_name.
     * </pre>
     *
     * <code>string route_desc = 5;</code>
     * @return The routeDesc.
     */
    @java.lang.Override
    public java.lang.String getRouteDesc() {
      java.lang.Object ref = routeDesc_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        routeDesc_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Description of a route that provides useful, quality information. Should
     * not be a duplicate of route_short_name or route_long_name.
     * </pre>
     *
     * <code>string route_desc = 5;</code>
     * @return The bytes for routeDesc.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteDescBytes() {
      java.lang.Object ref = routeDesc_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeDesc_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_TYPE_FIELD_NUMBER = 6;
    private int routeType_;
    /**
     * <pre>
     * Indicates the type of transportation used on a route.
     * Required
     * </pre>
     *
     * <code>.transit_scheduled.Route.RouteType route_type = 6;</code>
     * @return The enum numeric value on the wire for routeType.
     */
    @java.lang.Override public int getRouteTypeValue() {
      return routeType_;
    }
    /**
     * <pre>
     * Indicates the type of transportation used on a route.
     * Required
     * </pre>
     *
     * <code>.transit_scheduled.Route.RouteType route_type = 6;</code>
     * @return The routeType.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.Route.RouteType getRouteType() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.Route.RouteType result = transit_scheduled.GtfsSchedule.Route.RouteType.valueOf(routeType_);
      return result == null ? transit_scheduled.GtfsSchedule.Route.RouteType.UNRECOGNIZED : result;
    }

    public static final int ROUTE_URL_FIELD_NUMBER = 7;
    private volatile java.lang.Object routeUrl_;
    /**
     * <pre>
     * URL of a web page about the particular route. Should be different from the
     * agency.agency_url value.
     * </pre>
     *
     * <code>string route_url = 7;</code>
     * @return The routeUrl.
     */
    @java.lang.Override
    public java.lang.String getRouteUrl() {
      java.lang.Object ref = routeUrl_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        routeUrl_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * URL of a web page about the particular route. Should be different from the
     * agency.agency_url value.
     * </pre>
     *
     * <code>string route_url = 7;</code>
     * @return The bytes for routeUrl.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteUrlBytes() {
      java.lang.Object ref = routeUrl_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeUrl_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_COLOR_FIELD_NUMBER = 8;
    private volatile java.lang.Object routeColor_;
    /**
     * <pre>
     * Route color designation that matches public facing material. Defaults to
     * white (FFFFFF) when omitted or left empty. The color difference between
     * route_color and route_text_color should provide sufficient contrast when
     * viewed on a black and white screen.
     * </pre>
     *
     * <code>string route_color = 8;</code>
     * @return The routeColor.
     */
    @java.lang.Override
    public java.lang.String getRouteColor() {
      java.lang.Object ref = routeColor_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        routeColor_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Route color designation that matches public facing material. Defaults to
     * white (FFFFFF) when omitted or left empty. The color difference between
     * route_color and route_text_color should provide sufficient contrast when
     * viewed on a black and white screen.
     * </pre>
     *
     * <code>string route_color = 8;</code>
     * @return The bytes for routeColor.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteColorBytes() {
      java.lang.Object ref = routeColor_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeColor_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_TEXT_COLOR_FIELD_NUMBER = 9;
    private volatile java.lang.Object routeTextColor_;
    /**
     * <pre>
     * Legible color to use for text drawn against a background of route_color.
     * Defaults to black (000000) when omitted or left empty. The color difference
     * between route_color and route_text_color should provide sufficient contrast
     * when viewed on a black and white screen.
     * </pre>
     *
     * <code>string route_text_color = 9;</code>
     * @return The routeTextColor.
     */
    @java.lang.Override
    public java.lang.String getRouteTextColor() {
      java.lang.Object ref = routeTextColor_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        routeTextColor_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Legible color to use for text drawn against a background of route_color.
     * Defaults to black (000000) when omitted or left empty. The color difference
     * between route_color and route_text_color should provide sufficient contrast
     * when viewed on a black and white screen.
     * </pre>
     *
     * <code>string route_text_color = 9;</code>
     * @return The bytes for routeTextColor.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteTextColorBytes() {
      java.lang.Object ref = routeTextColor_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeTextColor_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROUTE_SORT_ORDER_FIELD_NUMBER = 10;
    private int routeSortOrder_;
    /**
     * <pre>
     * Orders the routes in a way which is ideal for presentation to customers.
     * Routes with smaller route_sort_order values should be displayed first.
     * </pre>
     *
     * <code>uint32 route_sort_order = 10;</code>
     * @return The routeSortOrder.
     */
    @java.lang.Override
    public int getRouteSortOrder() {
      return routeSortOrder_;
    }

    public static final int CONTINUOUS_PICKUP_FIELD_NUMBER = 11;
    private int continuousPickup_;
    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, on every trip of the
     * route.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 11;</code>
     * @return The enum numeric value on the wire for continuousPickup.
     */
    @java.lang.Override public int getContinuousPickupValue() {
      return continuousPickup_;
    }
    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, on every trip of the
     * route.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 11;</code>
     * @return The continuousPickup.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.ContinuousPickup getContinuousPickup() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.ContinuousPickup result = transit_scheduled.GtfsSchedule.ContinuousPickup.valueOf(continuousPickup_);
      return result == null ? transit_scheduled.GtfsSchedule.ContinuousPickup.UNRECOGNIZED : result;
    }

    public static final int CONTINUOUS_DROP_OFF_FIELD_NUMBER = 12;
    private int continuousDropOff_;
    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, on every trip
     * of the route.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 12;</code>
     * @return The enum numeric value on the wire for continuousDropOff.
     */
    @java.lang.Override public int getContinuousDropOffValue() {
      return continuousDropOff_;
    }
    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, on every trip
     * of the route.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 12;</code>
     * @return The continuousDropOff.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.ContinuousDropOff getContinuousDropOff() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.ContinuousDropOff result = transit_scheduled.GtfsSchedule.ContinuousDropOff.valueOf(continuousDropOff_);
      return result == null ? transit_scheduled.GtfsSchedule.ContinuousDropOff.UNRECOGNIZED : result;
    }

    public static final int NETWORK_ID_FIELD_NUMBER = 13;
    private volatile java.lang.Object networkId_;
    /**
     * <pre>
     * Identifies a group of routes. Multiple rows in routes.txt may have the same
     * network_id.
     * </pre>
     *
     * <code>string network_id = 13;</code>
     * @return The networkId.
     */
    @java.lang.Override
    public java.lang.String getNetworkId() {
      java.lang.Object ref = networkId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        networkId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies a group of routes. Multiple rows in routes.txt may have the same
     * network_id.
     * </pre>
     *
     * <code>string network_id = 13;</code>
     * @return The bytes for networkId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNetworkIdBytes() {
      java.lang.Object ref = networkId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        networkId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, routeId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, agencyId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeShortName_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, routeShortName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeLongName_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, routeLongName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeDesc_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, routeDesc_);
      }
      if (routeType_ != transit_scheduled.GtfsSchedule.Route.RouteType.ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL.getNumber()) {
        output.writeEnum(6, routeType_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeUrl_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, routeUrl_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeColor_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, routeColor_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeTextColor_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, routeTextColor_);
      }
      if (routeSortOrder_ != 0) {
        output.writeUInt32(10, routeSortOrder_);
      }
      if (continuousPickup_ != transit_scheduled.GtfsSchedule.ContinuousPickup.CONTINUOUS_PICKUP_STOPPING.getNumber()) {
        output.writeEnum(11, continuousPickup_);
      }
      if (continuousDropOff_ != transit_scheduled.GtfsSchedule.ContinuousDropOff.CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING.getNumber()) {
        output.writeEnum(12, continuousDropOff_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(networkId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 13, networkId_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, routeId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agencyId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, agencyId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeShortName_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, routeShortName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeLongName_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, routeLongName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeDesc_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, routeDesc_);
      }
      if (routeType_ != transit_scheduled.GtfsSchedule.Route.RouteType.ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, routeType_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeUrl_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, routeUrl_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeColor_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, routeColor_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeTextColor_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, routeTextColor_);
      }
      if (routeSortOrder_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(10, routeSortOrder_);
      }
      if (continuousPickup_ != transit_scheduled.GtfsSchedule.ContinuousPickup.CONTINUOUS_PICKUP_STOPPING.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(11, continuousPickup_);
      }
      if (continuousDropOff_ != transit_scheduled.GtfsSchedule.ContinuousDropOff.CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(12, continuousDropOff_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(networkId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(13, networkId_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof transit_scheduled.GtfsSchedule.Route)) {
        return super.equals(obj);
      }
      transit_scheduled.GtfsSchedule.Route other = (transit_scheduled.GtfsSchedule.Route) obj;

      if (!getRouteId()
          .equals(other.getRouteId())) return false;
      if (!getAgencyId()
          .equals(other.getAgencyId())) return false;
      if (!getRouteShortName()
          .equals(other.getRouteShortName())) return false;
      if (!getRouteLongName()
          .equals(other.getRouteLongName())) return false;
      if (!getRouteDesc()
          .equals(other.getRouteDesc())) return false;
      if (routeType_ != other.routeType_) return false;
      if (!getRouteUrl()
          .equals(other.getRouteUrl())) return false;
      if (!getRouteColor()
          .equals(other.getRouteColor())) return false;
      if (!getRouteTextColor()
          .equals(other.getRouteTextColor())) return false;
      if (getRouteSortOrder()
          != other.getRouteSortOrder()) return false;
      if (continuousPickup_ != other.continuousPickup_) return false;
      if (continuousDropOff_ != other.continuousDropOff_) return false;
      if (!getNetworkId()
          .equals(other.getNetworkId())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + ROUTE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getRouteId().hashCode();
      hash = (37 * hash) + AGENCY_ID_FIELD_NUMBER;
      hash = (53 * hash) + getAgencyId().hashCode();
      hash = (37 * hash) + ROUTE_SHORT_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getRouteShortName().hashCode();
      hash = (37 * hash) + ROUTE_LONG_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getRouteLongName().hashCode();
      hash = (37 * hash) + ROUTE_DESC_FIELD_NUMBER;
      hash = (53 * hash) + getRouteDesc().hashCode();
      hash = (37 * hash) + ROUTE_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + routeType_;
      hash = (37 * hash) + ROUTE_URL_FIELD_NUMBER;
      hash = (53 * hash) + getRouteUrl().hashCode();
      hash = (37 * hash) + ROUTE_COLOR_FIELD_NUMBER;
      hash = (53 * hash) + getRouteColor().hashCode();
      hash = (37 * hash) + ROUTE_TEXT_COLOR_FIELD_NUMBER;
      hash = (53 * hash) + getRouteTextColor().hashCode();
      hash = (37 * hash) + ROUTE_SORT_ORDER_FIELD_NUMBER;
      hash = (53 * hash) + getRouteSortOrder();
      hash = (37 * hash) + CONTINUOUS_PICKUP_FIELD_NUMBER;
      hash = (53 * hash) + continuousPickup_;
      hash = (37 * hash) + CONTINUOUS_DROP_OFF_FIELD_NUMBER;
      hash = (53 * hash) + continuousDropOff_;
      hash = (37 * hash) + NETWORK_ID_FIELD_NUMBER;
      hash = (53 * hash) + getNetworkId().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static transit_scheduled.GtfsSchedule.Route parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Route parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Route parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Route parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Route parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Route parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Route parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Route parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Route parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Route parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Route parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Route parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(transit_scheduled.GtfsSchedule.Route prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Transit routes. A route is a group of trips that are displayed to riders as a
     * single service.
     * </pre>
     *
     * Protobuf type {@code transit_scheduled.Route}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_scheduled.Route)
        transit_scheduled.GtfsSchedule.RouteOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Route_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Route_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                transit_scheduled.GtfsSchedule.Route.class, transit_scheduled.GtfsSchedule.Route.Builder.class);
      }

      // Construct using transit_scheduled.GtfsSchedule.Route.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        routeId_ = "";

        agencyId_ = "";

        routeShortName_ = "";

        routeLongName_ = "";

        routeDesc_ = "";

        routeType_ = 0;

        routeUrl_ = "";

        routeColor_ = "";

        routeTextColor_ = "";

        routeSortOrder_ = 0;

        continuousPickup_ = 0;

        continuousDropOff_ = 0;

        networkId_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Route_descriptor;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Route getDefaultInstanceForType() {
        return transit_scheduled.GtfsSchedule.Route.getDefaultInstance();
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Route build() {
        transit_scheduled.GtfsSchedule.Route result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Route buildPartial() {
        transit_scheduled.GtfsSchedule.Route result = new transit_scheduled.GtfsSchedule.Route(this);
        result.routeId_ = routeId_;
        result.agencyId_ = agencyId_;
        result.routeShortName_ = routeShortName_;
        result.routeLongName_ = routeLongName_;
        result.routeDesc_ = routeDesc_;
        result.routeType_ = routeType_;
        result.routeUrl_ = routeUrl_;
        result.routeColor_ = routeColor_;
        result.routeTextColor_ = routeTextColor_;
        result.routeSortOrder_ = routeSortOrder_;
        result.continuousPickup_ = continuousPickup_;
        result.continuousDropOff_ = continuousDropOff_;
        result.networkId_ = networkId_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof transit_scheduled.GtfsSchedule.Route) {
          return mergeFrom((transit_scheduled.GtfsSchedule.Route)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(transit_scheduled.GtfsSchedule.Route other) {
        if (other == transit_scheduled.GtfsSchedule.Route.getDefaultInstance()) return this;
        if (!other.getRouteId().isEmpty()) {
          routeId_ = other.routeId_;
          onChanged();
        }
        if (!other.getAgencyId().isEmpty()) {
          agencyId_ = other.agencyId_;
          onChanged();
        }
        if (!other.getRouteShortName().isEmpty()) {
          routeShortName_ = other.routeShortName_;
          onChanged();
        }
        if (!other.getRouteLongName().isEmpty()) {
          routeLongName_ = other.routeLongName_;
          onChanged();
        }
        if (!other.getRouteDesc().isEmpty()) {
          routeDesc_ = other.routeDesc_;
          onChanged();
        }
        if (other.routeType_ != 0) {
          setRouteTypeValue(other.getRouteTypeValue());
        }
        if (!other.getRouteUrl().isEmpty()) {
          routeUrl_ = other.routeUrl_;
          onChanged();
        }
        if (!other.getRouteColor().isEmpty()) {
          routeColor_ = other.routeColor_;
          onChanged();
        }
        if (!other.getRouteTextColor().isEmpty()) {
          routeTextColor_ = other.routeTextColor_;
          onChanged();
        }
        if (other.getRouteSortOrder() != 0) {
          setRouteSortOrder(other.getRouteSortOrder());
        }
        if (other.continuousPickup_ != 0) {
          setContinuousPickupValue(other.getContinuousPickupValue());
        }
        if (other.continuousDropOff_ != 0) {
          setContinuousDropOffValue(other.getContinuousDropOffValue());
        }
        if (!other.getNetworkId().isEmpty()) {
          networkId_ = other.networkId_;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                routeId_ = input.readStringRequireUtf8();

                break;
              } // case 10
              case 18: {
                agencyId_ = input.readStringRequireUtf8();

                break;
              } // case 18
              case 26: {
                routeShortName_ = input.readStringRequireUtf8();

                break;
              } // case 26
              case 34: {
                routeLongName_ = input.readStringRequireUtf8();

                break;
              } // case 34
              case 42: {
                routeDesc_ = input.readStringRequireUtf8();

                break;
              } // case 42
              case 48: {
                routeType_ = input.readEnum();

                break;
              } // case 48
              case 58: {
                routeUrl_ = input.readStringRequireUtf8();

                break;
              } // case 58
              case 66: {
                routeColor_ = input.readStringRequireUtf8();

                break;
              } // case 66
              case 74: {
                routeTextColor_ = input.readStringRequireUtf8();

                break;
              } // case 74
              case 80: {
                routeSortOrder_ = input.readUInt32();

                break;
              } // case 80
              case 88: {
                continuousPickup_ = input.readEnum();

                break;
              } // case 88
              case 96: {
                continuousDropOff_ = input.readEnum();

                break;
              } // case 96
              case 106: {
                networkId_ = input.readStringRequireUtf8();

                break;
              } // case 106
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private java.lang.Object routeId_ = "";
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @return The routeId.
       */
      public java.lang.String getRouteId() {
        java.lang.Object ref = routeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          routeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @return The bytes for routeId.
       */
      public com.google.protobuf.ByteString
          getRouteIdBytes() {
        java.lang.Object ref = routeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @param value The routeId to set.
       * @return This builder for chaining.
       */
      public Builder setRouteId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        routeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteId() {
        
        routeId_ = getDefaultInstance().getRouteId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @param value The bytes for routeId to set.
       * @return This builder for chaining.
       */
      public Builder setRouteIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        routeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object agencyId_ = "";
      /**
       * <pre>
       * Agency for the specified route.
       * Conditionally Required:
       * - Required if multiple agencies are defined in agency.txt.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 2;</code>
       * @return The agencyId.
       */
      public java.lang.String getAgencyId() {
        java.lang.Object ref = agencyId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agencyId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Agency for the specified route.
       * Conditionally Required:
       * - Required if multiple agencies are defined in agency.txt.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 2;</code>
       * @return The bytes for agencyId.
       */
      public com.google.protobuf.ByteString
          getAgencyIdBytes() {
        java.lang.Object ref = agencyId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agencyId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Agency for the specified route.
       * Conditionally Required:
       * - Required if multiple agencies are defined in agency.txt.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 2;</code>
       * @param value The agencyId to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agencyId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Agency for the specified route.
       * Conditionally Required:
       * - Required if multiple agencies are defined in agency.txt.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgencyId() {
        
        agencyId_ = getDefaultInstance().getAgencyId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Agency for the specified route.
       * Conditionally Required:
       * - Required if multiple agencies are defined in agency.txt.
       * - Recommended otherwise.
       * </pre>
       *
       * <code>string agency_id = 2;</code>
       * @param value The bytes for agencyId to set.
       * @return This builder for chaining.
       */
      public Builder setAgencyIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agencyId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object routeShortName_ = "";
      /**
       * <pre>
       * Short name of a route. Often a short, abstract identifier (e.g., "32",
       * "100X", "Green") that riders use to identify a route. Both route_short_name
       * and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_long_name is empty.
       * - Recommended if there is a brief service designation. This should be the
       * commonly-known passenger name of the service, and should be no longer than
       * 12 characters.
       * </pre>
       *
       * <code>string route_short_name = 3;</code>
       * @return The routeShortName.
       */
      public java.lang.String getRouteShortName() {
        java.lang.Object ref = routeShortName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          routeShortName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Short name of a route. Often a short, abstract identifier (e.g., "32",
       * "100X", "Green") that riders use to identify a route. Both route_short_name
       * and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_long_name is empty.
       * - Recommended if there is a brief service designation. This should be the
       * commonly-known passenger name of the service, and should be no longer than
       * 12 characters.
       * </pre>
       *
       * <code>string route_short_name = 3;</code>
       * @return The bytes for routeShortName.
       */
      public com.google.protobuf.ByteString
          getRouteShortNameBytes() {
        java.lang.Object ref = routeShortName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeShortName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Short name of a route. Often a short, abstract identifier (e.g., "32",
       * "100X", "Green") that riders use to identify a route. Both route_short_name
       * and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_long_name is empty.
       * - Recommended if there is a brief service designation. This should be the
       * commonly-known passenger name of the service, and should be no longer than
       * 12 characters.
       * </pre>
       *
       * <code>string route_short_name = 3;</code>
       * @param value The routeShortName to set.
       * @return This builder for chaining.
       */
      public Builder setRouteShortName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        routeShortName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Short name of a route. Often a short, abstract identifier (e.g., "32",
       * "100X", "Green") that riders use to identify a route. Both route_short_name
       * and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_long_name is empty.
       * - Recommended if there is a brief service designation. This should be the
       * commonly-known passenger name of the service, and should be no longer than
       * 12 characters.
       * </pre>
       *
       * <code>string route_short_name = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteShortName() {
        
        routeShortName_ = getDefaultInstance().getRouteShortName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Short name of a route. Often a short, abstract identifier (e.g., "32",
       * "100X", "Green") that riders use to identify a route. Both route_short_name
       * and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_long_name is empty.
       * - Recommended if there is a brief service designation. This should be the
       * commonly-known passenger name of the service, and should be no longer than
       * 12 characters.
       * </pre>
       *
       * <code>string route_short_name = 3;</code>
       * @param value The bytes for routeShortName to set.
       * @return This builder for chaining.
       */
      public Builder setRouteShortNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        routeShortName_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object routeLongName_ = "";
      /**
       * <pre>
       * Full name of a route. This name is generally more descriptive than the
       * route_short_name and often includes the route's destination or stop. Both
       * route_short_name and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_short_name is empty.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string route_long_name = 4;</code>
       * @return The routeLongName.
       */
      public java.lang.String getRouteLongName() {
        java.lang.Object ref = routeLongName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          routeLongName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Full name of a route. This name is generally more descriptive than the
       * route_short_name and often includes the route's destination or stop. Both
       * route_short_name and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_short_name is empty.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string route_long_name = 4;</code>
       * @return The bytes for routeLongName.
       */
      public com.google.protobuf.ByteString
          getRouteLongNameBytes() {
        java.lang.Object ref = routeLongName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeLongName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Full name of a route. This name is generally more descriptive than the
       * route_short_name and often includes the route's destination or stop. Both
       * route_short_name and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_short_name is empty.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string route_long_name = 4;</code>
       * @param value The routeLongName to set.
       * @return This builder for chaining.
       */
      public Builder setRouteLongName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        routeLongName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Full name of a route. This name is generally more descriptive than the
       * route_short_name and often includes the route's destination or stop. Both
       * route_short_name and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_short_name is empty.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string route_long_name = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteLongName() {
        
        routeLongName_ = getDefaultInstance().getRouteLongName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Full name of a route. This name is generally more descriptive than the
       * route_short_name and often includes the route's destination or stop. Both
       * route_short_name and route_long_name may be defined.
       * Conditionally Required:
       * - Required if routes.route_short_name is empty.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string route_long_name = 4;</code>
       * @param value The bytes for routeLongName to set.
       * @return This builder for chaining.
       */
      public Builder setRouteLongNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        routeLongName_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object routeDesc_ = "";
      /**
       * <pre>
       * Description of a route that provides useful, quality information. Should
       * not be a duplicate of route_short_name or route_long_name.
       * </pre>
       *
       * <code>string route_desc = 5;</code>
       * @return The routeDesc.
       */
      public java.lang.String getRouteDesc() {
        java.lang.Object ref = routeDesc_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          routeDesc_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Description of a route that provides useful, quality information. Should
       * not be a duplicate of route_short_name or route_long_name.
       * </pre>
       *
       * <code>string route_desc = 5;</code>
       * @return The bytes for routeDesc.
       */
      public com.google.protobuf.ByteString
          getRouteDescBytes() {
        java.lang.Object ref = routeDesc_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeDesc_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Description of a route that provides useful, quality information. Should
       * not be a duplicate of route_short_name or route_long_name.
       * </pre>
       *
       * <code>string route_desc = 5;</code>
       * @param value The routeDesc to set.
       * @return This builder for chaining.
       */
      public Builder setRouteDesc(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        routeDesc_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of a route that provides useful, quality information. Should
       * not be a duplicate of route_short_name or route_long_name.
       * </pre>
       *
       * <code>string route_desc = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteDesc() {
        
        routeDesc_ = getDefaultInstance().getRouteDesc();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Description of a route that provides useful, quality information. Should
       * not be a duplicate of route_short_name or route_long_name.
       * </pre>
       *
       * <code>string route_desc = 5;</code>
       * @param value The bytes for routeDesc to set.
       * @return This builder for chaining.
       */
      public Builder setRouteDescBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        routeDesc_ = value;
        onChanged();
        return this;
      }

      private int routeType_ = 0;
      /**
       * <pre>
       * Indicates the type of transportation used on a route.
       * Required
       * </pre>
       *
       * <code>.transit_scheduled.Route.RouteType route_type = 6;</code>
       * @return The enum numeric value on the wire for routeType.
       */
      @java.lang.Override public int getRouteTypeValue() {
        return routeType_;
      }
      /**
       * <pre>
       * Indicates the type of transportation used on a route.
       * Required
       * </pre>
       *
       * <code>.transit_scheduled.Route.RouteType route_type = 6;</code>
       * @param value The enum numeric value on the wire for routeType to set.
       * @return This builder for chaining.
       */
      public Builder setRouteTypeValue(int value) {
        
        routeType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates the type of transportation used on a route.
       * Required
       * </pre>
       *
       * <code>.transit_scheduled.Route.RouteType route_type = 6;</code>
       * @return The routeType.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Route.RouteType getRouteType() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.Route.RouteType result = transit_scheduled.GtfsSchedule.Route.RouteType.valueOf(routeType_);
        return result == null ? transit_scheduled.GtfsSchedule.Route.RouteType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates the type of transportation used on a route.
       * Required
       * </pre>
       *
       * <code>.transit_scheduled.Route.RouteType route_type = 6;</code>
       * @param value The routeType to set.
       * @return This builder for chaining.
       */
      public Builder setRouteType(transit_scheduled.GtfsSchedule.Route.RouteType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        routeType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates the type of transportation used on a route.
       * Required
       * </pre>
       *
       * <code>.transit_scheduled.Route.RouteType route_type = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteType() {
        
        routeType_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object routeUrl_ = "";
      /**
       * <pre>
       * URL of a web page about the particular route. Should be different from the
       * agency.agency_url value.
       * </pre>
       *
       * <code>string route_url = 7;</code>
       * @return The routeUrl.
       */
      public java.lang.String getRouteUrl() {
        java.lang.Object ref = routeUrl_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          routeUrl_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * URL of a web page about the particular route. Should be different from the
       * agency.agency_url value.
       * </pre>
       *
       * <code>string route_url = 7;</code>
       * @return The bytes for routeUrl.
       */
      public com.google.protobuf.ByteString
          getRouteUrlBytes() {
        java.lang.Object ref = routeUrl_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeUrl_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * URL of a web page about the particular route. Should be different from the
       * agency.agency_url value.
       * </pre>
       *
       * <code>string route_url = 7;</code>
       * @param value The routeUrl to set.
       * @return This builder for chaining.
       */
      public Builder setRouteUrl(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        routeUrl_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * URL of a web page about the particular route. Should be different from the
       * agency.agency_url value.
       * </pre>
       *
       * <code>string route_url = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteUrl() {
        
        routeUrl_ = getDefaultInstance().getRouteUrl();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * URL of a web page about the particular route. Should be different from the
       * agency.agency_url value.
       * </pre>
       *
       * <code>string route_url = 7;</code>
       * @param value The bytes for routeUrl to set.
       * @return This builder for chaining.
       */
      public Builder setRouteUrlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        routeUrl_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object routeColor_ = "";
      /**
       * <pre>
       * Route color designation that matches public facing material. Defaults to
       * white (FFFFFF) when omitted or left empty. The color difference between
       * route_color and route_text_color should provide sufficient contrast when
       * viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_color = 8;</code>
       * @return The routeColor.
       */
      public java.lang.String getRouteColor() {
        java.lang.Object ref = routeColor_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          routeColor_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Route color designation that matches public facing material. Defaults to
       * white (FFFFFF) when omitted or left empty. The color difference between
       * route_color and route_text_color should provide sufficient contrast when
       * viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_color = 8;</code>
       * @return The bytes for routeColor.
       */
      public com.google.protobuf.ByteString
          getRouteColorBytes() {
        java.lang.Object ref = routeColor_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeColor_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Route color designation that matches public facing material. Defaults to
       * white (FFFFFF) when omitted or left empty. The color difference between
       * route_color and route_text_color should provide sufficient contrast when
       * viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_color = 8;</code>
       * @param value The routeColor to set.
       * @return This builder for chaining.
       */
      public Builder setRouteColor(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        routeColor_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Route color designation that matches public facing material. Defaults to
       * white (FFFFFF) when omitted or left empty. The color difference between
       * route_color and route_text_color should provide sufficient contrast when
       * viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_color = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteColor() {
        
        routeColor_ = getDefaultInstance().getRouteColor();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Route color designation that matches public facing material. Defaults to
       * white (FFFFFF) when omitted or left empty. The color difference between
       * route_color and route_text_color should provide sufficient contrast when
       * viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_color = 8;</code>
       * @param value The bytes for routeColor to set.
       * @return This builder for chaining.
       */
      public Builder setRouteColorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        routeColor_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object routeTextColor_ = "";
      /**
       * <pre>
       * Legible color to use for text drawn against a background of route_color.
       * Defaults to black (000000) when omitted or left empty. The color difference
       * between route_color and route_text_color should provide sufficient contrast
       * when viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_text_color = 9;</code>
       * @return The routeTextColor.
       */
      public java.lang.String getRouteTextColor() {
        java.lang.Object ref = routeTextColor_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          routeTextColor_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Legible color to use for text drawn against a background of route_color.
       * Defaults to black (000000) when omitted or left empty. The color difference
       * between route_color and route_text_color should provide sufficient contrast
       * when viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_text_color = 9;</code>
       * @return The bytes for routeTextColor.
       */
      public com.google.protobuf.ByteString
          getRouteTextColorBytes() {
        java.lang.Object ref = routeTextColor_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeTextColor_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Legible color to use for text drawn against a background of route_color.
       * Defaults to black (000000) when omitted or left empty. The color difference
       * between route_color and route_text_color should provide sufficient contrast
       * when viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_text_color = 9;</code>
       * @param value The routeTextColor to set.
       * @return This builder for chaining.
       */
      public Builder setRouteTextColor(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        routeTextColor_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Legible color to use for text drawn against a background of route_color.
       * Defaults to black (000000) when omitted or left empty. The color difference
       * between route_color and route_text_color should provide sufficient contrast
       * when viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_text_color = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteTextColor() {
        
        routeTextColor_ = getDefaultInstance().getRouteTextColor();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Legible color to use for text drawn against a background of route_color.
       * Defaults to black (000000) when omitted or left empty. The color difference
       * between route_color and route_text_color should provide sufficient contrast
       * when viewed on a black and white screen.
       * </pre>
       *
       * <code>string route_text_color = 9;</code>
       * @param value The bytes for routeTextColor to set.
       * @return This builder for chaining.
       */
      public Builder setRouteTextColorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        routeTextColor_ = value;
        onChanged();
        return this;
      }

      private int routeSortOrder_ ;
      /**
       * <pre>
       * Orders the routes in a way which is ideal for presentation to customers.
       * Routes with smaller route_sort_order values should be displayed first.
       * </pre>
       *
       * <code>uint32 route_sort_order = 10;</code>
       * @return The routeSortOrder.
       */
      @java.lang.Override
      public int getRouteSortOrder() {
        return routeSortOrder_;
      }
      /**
       * <pre>
       * Orders the routes in a way which is ideal for presentation to customers.
       * Routes with smaller route_sort_order values should be displayed first.
       * </pre>
       *
       * <code>uint32 route_sort_order = 10;</code>
       * @param value The routeSortOrder to set.
       * @return This builder for chaining.
       */
      public Builder setRouteSortOrder(int value) {
        
        routeSortOrder_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Orders the routes in a way which is ideal for presentation to customers.
       * Routes with smaller route_sort_order values should be displayed first.
       * </pre>
       *
       * <code>uint32 route_sort_order = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteSortOrder() {
        
        routeSortOrder_ = 0;
        onChanged();
        return this;
      }

      private int continuousPickup_ = 0;
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, on every trip of the
       * route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 11;</code>
       * @return The enum numeric value on the wire for continuousPickup.
       */
      @java.lang.Override public int getContinuousPickupValue() {
        return continuousPickup_;
      }
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, on every trip of the
       * route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 11;</code>
       * @param value The enum numeric value on the wire for continuousPickup to set.
       * @return This builder for chaining.
       */
      public Builder setContinuousPickupValue(int value) {
        
        continuousPickup_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, on every trip of the
       * route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 11;</code>
       * @return The continuousPickup.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.ContinuousPickup getContinuousPickup() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.ContinuousPickup result = transit_scheduled.GtfsSchedule.ContinuousPickup.valueOf(continuousPickup_);
        return result == null ? transit_scheduled.GtfsSchedule.ContinuousPickup.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, on every trip of the
       * route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 11;</code>
       * @param value The continuousPickup to set.
       * @return This builder for chaining.
       */
      public Builder setContinuousPickup(transit_scheduled.GtfsSchedule.ContinuousPickup value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        continuousPickup_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, on every trip of the
       * route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearContinuousPickup() {
        
        continuousPickup_ = 0;
        onChanged();
        return this;
      }

      private int continuousDropOff_ = 0;
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, on every trip
       * of the route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 12;</code>
       * @return The enum numeric value on the wire for continuousDropOff.
       */
      @java.lang.Override public int getContinuousDropOffValue() {
        return continuousDropOff_;
      }
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, on every trip
       * of the route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 12;</code>
       * @param value The enum numeric value on the wire for continuousDropOff to set.
       * @return This builder for chaining.
       */
      public Builder setContinuousDropOffValue(int value) {
        
        continuousDropOff_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, on every trip
       * of the route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 12;</code>
       * @return The continuousDropOff.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.ContinuousDropOff getContinuousDropOff() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.ContinuousDropOff result = transit_scheduled.GtfsSchedule.ContinuousDropOff.valueOf(continuousDropOff_);
        return result == null ? transit_scheduled.GtfsSchedule.ContinuousDropOff.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, on every trip
       * of the route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 12;</code>
       * @param value The continuousDropOff to set.
       * @return This builder for chaining.
       */
      public Builder setContinuousDropOff(transit_scheduled.GtfsSchedule.ContinuousDropOff value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        continuousDropOff_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, on every trip
       * of the route.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearContinuousDropOff() {
        
        continuousDropOff_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object networkId_ = "";
      /**
       * <pre>
       * Identifies a group of routes. Multiple rows in routes.txt may have the same
       * network_id.
       * </pre>
       *
       * <code>string network_id = 13;</code>
       * @return The networkId.
       */
      public java.lang.String getNetworkId() {
        java.lang.Object ref = networkId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          networkId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies a group of routes. Multiple rows in routes.txt may have the same
       * network_id.
       * </pre>
       *
       * <code>string network_id = 13;</code>
       * @return The bytes for networkId.
       */
      public com.google.protobuf.ByteString
          getNetworkIdBytes() {
        java.lang.Object ref = networkId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          networkId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies a group of routes. Multiple rows in routes.txt may have the same
       * network_id.
       * </pre>
       *
       * <code>string network_id = 13;</code>
       * @param value The networkId to set.
       * @return This builder for chaining.
       */
      public Builder setNetworkId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        networkId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a group of routes. Multiple rows in routes.txt may have the same
       * network_id.
       * </pre>
       *
       * <code>string network_id = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearNetworkId() {
        
        networkId_ = getDefaultInstance().getNetworkId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a group of routes. Multiple rows in routes.txt may have the same
       * network_id.
       * </pre>
       *
       * <code>string network_id = 13;</code>
       * @param value The bytes for networkId to set.
       * @return This builder for chaining.
       */
      public Builder setNetworkIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        networkId_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:transit_scheduled.Route)
    }

    // @@protoc_insertion_point(class_scope:transit_scheduled.Route)
    private static final transit_scheduled.GtfsSchedule.Route DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new transit_scheduled.GtfsSchedule.Route();
    }

    public static transit_scheduled.GtfsSchedule.Route getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Route>
        PARSER = new com.google.protobuf.AbstractParser<Route>() {
      @java.lang.Override
      public Route parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Route> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Route> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public transit_scheduled.GtfsSchedule.Route getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TripOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_scheduled.Trip)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Identifies a route.
     * Required
     * </pre>
     *
     * <code>string route_id = 1;</code>
     * @return The routeId.
     */
    java.lang.String getRouteId();
    /**
     * <pre>
     * Identifies a route.
     * Required
     * </pre>
     *
     * <code>string route_id = 1;</code>
     * @return The bytes for routeId.
     */
    com.google.protobuf.ByteString
        getRouteIdBytes();

    /**
     * <pre>
     * Identifies a set of dates when service is available for one or more routes.
     * Required
     * </pre>
     *
     * <code>string service_id = 2;</code>
     * @return The serviceId.
     */
    java.lang.String getServiceId();
    /**
     * <pre>
     * Identifies a set of dates when service is available for one or more routes.
     * Required
     * </pre>
     *
     * <code>string service_id = 2;</code>
     * @return The bytes for serviceId.
     */
    com.google.protobuf.ByteString
        getServiceIdBytes();

    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 3;</code>
     * @return The tripId.
     */
    java.lang.String getTripId();
    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 3;</code>
     * @return The bytes for tripId.
     */
    com.google.protobuf.ByteString
        getTripIdBytes();

    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * Should be used to distinguish between different patterns of service on the
     * same route.
     * If the headsign changes during a trip, values for trip_headsign may be
     * overridden by defining values in stop_times.stop_headsign for specific
     * stop_times along the trip.
     * </pre>
     *
     * <code>string trip_headsign = 4;</code>
     * @return The tripHeadsign.
     */
    java.lang.String getTripHeadsign();
    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * Should be used to distinguish between different patterns of service on the
     * same route.
     * If the headsign changes during a trip, values for trip_headsign may be
     * overridden by defining values in stop_times.stop_headsign for specific
     * stop_times along the trip.
     * </pre>
     *
     * <code>string trip_headsign = 4;</code>
     * @return The bytes for tripHeadsign.
     */
    com.google.protobuf.ByteString
        getTripHeadsignBytes();

    /**
     * <pre>
     * Public facing text used to identify the trip to riders, for instance, to
     * identify train numbers for commuter rail trips. If riders do not commonly
     * rely on trip names, trip_short_name should be empty. A trip_short_name
     * value, if provided, should uniquely identify a trip within a service day;
     * it should not be used for destination names or limited/express
     * designations.
     * </pre>
     *
     * <code>string trip_short_name = 5;</code>
     * @return The tripShortName.
     */
    java.lang.String getTripShortName();
    /**
     * <pre>
     * Public facing text used to identify the trip to riders, for instance, to
     * identify train numbers for commuter rail trips. If riders do not commonly
     * rely on trip names, trip_short_name should be empty. A trip_short_name
     * value, if provided, should uniquely identify a trip within a service day;
     * it should not be used for destination names or limited/express
     * designations.
     * </pre>
     *
     * <code>string trip_short_name = 5;</code>
     * @return The bytes for tripShortName.
     */
    com.google.protobuf.ByteString
        getTripShortNameBytes();

    /**
     * <pre>
     * Indicates the direction of travel for a trip.
     * This field should not be used in routing; it provides a way to separate
     * trips by direction when publishing time tables.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.Direction direction_id = 6;</code>
     * @return The enum numeric value on the wire for directionId.
     */
    int getDirectionIdValue();
    /**
     * <pre>
     * Indicates the direction of travel for a trip.
     * This field should not be used in routing; it provides a way to separate
     * trips by direction when publishing time tables.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.Direction direction_id = 6;</code>
     * @return The directionId.
     */
    transit_scheduled.GtfsSchedule.Trip.Direction getDirectionId();

    /**
     * <pre>
     * Identifies the block to which the trip belongs. A block consists of a
     * single trip or many sequential trips made using the same vehicle, defined
     * by shared service days and block_id. A block_id may have trips with
     * different service days, making distinct blocks. See the example below. To
     * provide in-seat transfers information, transfers of transfer_type 4 should
     * be provided instead.
     * </pre>
     *
     * <code>string block_id = 7;</code>
     * @return The blockId.
     */
    java.lang.String getBlockId();
    /**
     * <pre>
     * Identifies the block to which the trip belongs. A block consists of a
     * single trip or many sequential trips made using the same vehicle, defined
     * by shared service days and block_id. A block_id may have trips with
     * different service days, making distinct blocks. See the example below. To
     * provide in-seat transfers information, transfers of transfer_type 4 should
     * be provided instead.
     * </pre>
     *
     * <code>string block_id = 7;</code>
     * @return The bytes for blockId.
     */
    com.google.protobuf.ByteString
        getBlockIdBytes();

    /**
     * <pre>
     * Identifies a geospatial shape describing the vehicle travel path for a
     * trip.
     * Conditionally Required:
     * - Required if the trip has a continuous pickup or drop-off behavior defined
     * either in routes.txt or in stop_times.txt.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string shape_id = 8;</code>
     * @return The shapeId.
     */
    java.lang.String getShapeId();
    /**
     * <pre>
     * Identifies a geospatial shape describing the vehicle travel path for a
     * trip.
     * Conditionally Required:
     * - Required if the trip has a continuous pickup or drop-off behavior defined
     * either in routes.txt or in stop_times.txt.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string shape_id = 8;</code>
     * @return The bytes for shapeId.
     */
    com.google.protobuf.ByteString
        getShapeIdBytes();

    /**
     * <pre>
     * Indicates wheelchair accessibility.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;</code>
     * @return The enum numeric value on the wire for wheelchairAccessible.
     */
    int getWheelchairAccessibleValue();
    /**
     * <pre>
     * Indicates wheelchair accessibility.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;</code>
     * @return The wheelchairAccessible.
     */
    transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility getWheelchairAccessible();

    /**
     * <pre>
     * Indicates whether bikes are allowed.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;</code>
     * @return The enum numeric value on the wire for bikesAllowed.
     */
    int getBikesAllowedValue();
    /**
     * <pre>
     * Indicates whether bikes are allowed.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;</code>
     * @return The bikesAllowed.
     */
    transit_scheduled.GtfsSchedule.Trip.BikeAllowance getBikesAllowed();
  }
  /**
   * <pre>
   * Trips for each route. A trip is a sequence of two or more stops that occur
   * during a specific time period.
   * </pre>
   *
   * Protobuf type {@code transit_scheduled.Trip}
   */
  public static final class Trip extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:transit_scheduled.Trip)
      TripOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Trip.newBuilder() to construct.
    private Trip(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Trip() {
      routeId_ = "";
      serviceId_ = "";
      tripId_ = "";
      tripHeadsign_ = "";
      tripShortName_ = "";
      directionId_ = 0;
      blockId_ = "";
      shapeId_ = "";
      wheelchairAccessible_ = 0;
      bikesAllowed_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Trip();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Trip_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Trip_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              transit_scheduled.GtfsSchedule.Trip.class, transit_scheduled.GtfsSchedule.Trip.Builder.class);
    }

    /**
     * <pre>
     * Indicates the direction of travel for a trip. This field should not be used
     * in routing; it provides a way to separate trips by direction when
     * publishing time tables. Valid options are:
     *   0 - Travel in one direction (e.g. outbound travel).
     *   1 - Travel in the opposite direction (e.g. inbound travel).
     * </pre>
     *
     * Protobuf enum {@code transit_scheduled.Trip.Direction}
     */
    public enum Direction
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>DIRECTION_ONE_DIRECTION = 0;</code>
       */
      DIRECTION_ONE_DIRECTION(0),
      /**
       * <code>DIRECTION_OPPOSITE = 1;</code>
       */
      DIRECTION_OPPOSITE(1),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>DIRECTION_ONE_DIRECTION = 0;</code>
       */
      public static final int DIRECTION_ONE_DIRECTION_VALUE = 0;
      /**
       * <code>DIRECTION_OPPOSITE = 1;</code>
       */
      public static final int DIRECTION_OPPOSITE_VALUE = 1;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Direction valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Direction forNumber(int value) {
        switch (value) {
          case 0: return DIRECTION_ONE_DIRECTION;
          case 1: return DIRECTION_OPPOSITE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Direction>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Direction> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Direction>() {
              public Direction findValueByNumber(int number) {
                return Direction.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.Trip.getDescriptor().getEnumTypes().get(0);
      }

      private static final Direction[] VALUES = values();

      public static Direction valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Direction(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_scheduled.Trip.Direction)
    }

    /**
     * <pre>
     * Indicates wheelchair accessibility. Valid options are:
     *   0 or empty - No accessibility information for the trip.
     *   1 - Vehicle being used on this particular trip can accommodate at least
     *   one rider in a wheelchair.
     *   2 - No riders in wheelchairs can be accommodated on this trip.
     * </pre>
     *
     * Protobuf enum {@code transit_scheduled.Trip.WheelchairAccessibility}
     */
    public enum WheelchairAccessibility
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>WHEELCHAIR_ACCESSIBILITY_NO_INFO = 0;</code>
       */
      WHEELCHAIR_ACCESSIBILITY_NO_INFO(0),
      /**
       * <code>WHEELCHAIR_ACCESSIBILITY_ACCESSIBLE = 1;</code>
       */
      WHEELCHAIR_ACCESSIBILITY_ACCESSIBLE(1),
      /**
       * <code>WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE = 2;</code>
       */
      WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE(2),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>WHEELCHAIR_ACCESSIBILITY_NO_INFO = 0;</code>
       */
      public static final int WHEELCHAIR_ACCESSIBILITY_NO_INFO_VALUE = 0;
      /**
       * <code>WHEELCHAIR_ACCESSIBILITY_ACCESSIBLE = 1;</code>
       */
      public static final int WHEELCHAIR_ACCESSIBILITY_ACCESSIBLE_VALUE = 1;
      /**
       * <code>WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE = 2;</code>
       */
      public static final int WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE_VALUE = 2;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static WheelchairAccessibility valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static WheelchairAccessibility forNumber(int value) {
        switch (value) {
          case 0: return WHEELCHAIR_ACCESSIBILITY_NO_INFO;
          case 1: return WHEELCHAIR_ACCESSIBILITY_ACCESSIBLE;
          case 2: return WHEELCHAIR_ACCESSIBILITY_NOT_ACCESSIBLE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<WheelchairAccessibility>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          WheelchairAccessibility> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<WheelchairAccessibility>() {
              public WheelchairAccessibility findValueByNumber(int number) {
                return WheelchairAccessibility.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.Trip.getDescriptor().getEnumTypes().get(1);
      }

      private static final WheelchairAccessibility[] VALUES = values();

      public static WheelchairAccessibility valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private WheelchairAccessibility(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_scheduled.Trip.WheelchairAccessibility)
    }

    /**
     * <pre>
     * Indicates whether bikes are allowed. Valid options are:
     *   0 or empty - No bike information for the trip.
     *   1 - Vehicle being used on this particular trip can accommodate at least
     *   one bicycle.
     *   2 - No bicycles are allowed on this trip.
     * </pre>
     *
     * Protobuf enum {@code transit_scheduled.Trip.BikeAllowance}
     */
    public enum BikeAllowance
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>BIKE_ALLOWANCE_NO_INFO = 0;</code>
       */
      BIKE_ALLOWANCE_NO_INFO(0),
      /**
       * <code>BIKE_ALLOWANCE_ALLOWED = 1;</code>
       */
      BIKE_ALLOWANCE_ALLOWED(1),
      /**
       * <code>BIKE_ALLOWANCE_NOT_ALLOWED = 2;</code>
       */
      BIKE_ALLOWANCE_NOT_ALLOWED(2),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>BIKE_ALLOWANCE_NO_INFO = 0;</code>
       */
      public static final int BIKE_ALLOWANCE_NO_INFO_VALUE = 0;
      /**
       * <code>BIKE_ALLOWANCE_ALLOWED = 1;</code>
       */
      public static final int BIKE_ALLOWANCE_ALLOWED_VALUE = 1;
      /**
       * <code>BIKE_ALLOWANCE_NOT_ALLOWED = 2;</code>
       */
      public static final int BIKE_ALLOWANCE_NOT_ALLOWED_VALUE = 2;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static BikeAllowance valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static BikeAllowance forNumber(int value) {
        switch (value) {
          case 0: return BIKE_ALLOWANCE_NO_INFO;
          case 1: return BIKE_ALLOWANCE_ALLOWED;
          case 2: return BIKE_ALLOWANCE_NOT_ALLOWED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<BikeAllowance>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          BikeAllowance> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<BikeAllowance>() {
              public BikeAllowance findValueByNumber(int number) {
                return BikeAllowance.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.Trip.getDescriptor().getEnumTypes().get(2);
      }

      private static final BikeAllowance[] VALUES = values();

      public static BikeAllowance valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private BikeAllowance(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_scheduled.Trip.BikeAllowance)
    }

    public static final int ROUTE_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object routeId_;
    /**
     * <pre>
     * Identifies a route.
     * Required
     * </pre>
     *
     * <code>string route_id = 1;</code>
     * @return The routeId.
     */
    @java.lang.Override
    public java.lang.String getRouteId() {
      java.lang.Object ref = routeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        routeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies a route.
     * Required
     * </pre>
     *
     * <code>string route_id = 1;</code>
     * @return The bytes for routeId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRouteIdBytes() {
      java.lang.Object ref = routeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        routeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVICE_ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object serviceId_;
    /**
     * <pre>
     * Identifies a set of dates when service is available for one or more routes.
     * Required
     * </pre>
     *
     * <code>string service_id = 2;</code>
     * @return The serviceId.
     */
    @java.lang.Override
    public java.lang.String getServiceId() {
      java.lang.Object ref = serviceId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serviceId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies a set of dates when service is available for one or more routes.
     * Required
     * </pre>
     *
     * <code>string service_id = 2;</code>
     * @return The bytes for serviceId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServiceIdBytes() {
      java.lang.Object ref = serviceId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serviceId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TRIP_ID_FIELD_NUMBER = 3;
    private volatile java.lang.Object tripId_;
    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 3;</code>
     * @return The tripId.
     */
    @java.lang.Override
    public java.lang.String getTripId() {
      java.lang.Object ref = tripId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        tripId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 3;</code>
     * @return The bytes for tripId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTripIdBytes() {
      java.lang.Object ref = tripId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        tripId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TRIP_HEADSIGN_FIELD_NUMBER = 4;
    private volatile java.lang.Object tripHeadsign_;
    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * Should be used to distinguish between different patterns of service on the
     * same route.
     * If the headsign changes during a trip, values for trip_headsign may be
     * overridden by defining values in stop_times.stop_headsign for specific
     * stop_times along the trip.
     * </pre>
     *
     * <code>string trip_headsign = 4;</code>
     * @return The tripHeadsign.
     */
    @java.lang.Override
    public java.lang.String getTripHeadsign() {
      java.lang.Object ref = tripHeadsign_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        tripHeadsign_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * Should be used to distinguish between different patterns of service on the
     * same route.
     * If the headsign changes during a trip, values for trip_headsign may be
     * overridden by defining values in stop_times.stop_headsign for specific
     * stop_times along the trip.
     * </pre>
     *
     * <code>string trip_headsign = 4;</code>
     * @return The bytes for tripHeadsign.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTripHeadsignBytes() {
      java.lang.Object ref = tripHeadsign_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        tripHeadsign_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TRIP_SHORT_NAME_FIELD_NUMBER = 5;
    private volatile java.lang.Object tripShortName_;
    /**
     * <pre>
     * Public facing text used to identify the trip to riders, for instance, to
     * identify train numbers for commuter rail trips. If riders do not commonly
     * rely on trip names, trip_short_name should be empty. A trip_short_name
     * value, if provided, should uniquely identify a trip within a service day;
     * it should not be used for destination names or limited/express
     * designations.
     * </pre>
     *
     * <code>string trip_short_name = 5;</code>
     * @return The tripShortName.
     */
    @java.lang.Override
    public java.lang.String getTripShortName() {
      java.lang.Object ref = tripShortName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        tripShortName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Public facing text used to identify the trip to riders, for instance, to
     * identify train numbers for commuter rail trips. If riders do not commonly
     * rely on trip names, trip_short_name should be empty. A trip_short_name
     * value, if provided, should uniquely identify a trip within a service day;
     * it should not be used for destination names or limited/express
     * designations.
     * </pre>
     *
     * <code>string trip_short_name = 5;</code>
     * @return The bytes for tripShortName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTripShortNameBytes() {
      java.lang.Object ref = tripShortName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        tripShortName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DIRECTION_ID_FIELD_NUMBER = 6;
    private int directionId_;
    /**
     * <pre>
     * Indicates the direction of travel for a trip.
     * This field should not be used in routing; it provides a way to separate
     * trips by direction when publishing time tables.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.Direction direction_id = 6;</code>
     * @return The enum numeric value on the wire for directionId.
     */
    @java.lang.Override public int getDirectionIdValue() {
      return directionId_;
    }
    /**
     * <pre>
     * Indicates the direction of travel for a trip.
     * This field should not be used in routing; it provides a way to separate
     * trips by direction when publishing time tables.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.Direction direction_id = 6;</code>
     * @return The directionId.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.Trip.Direction getDirectionId() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.Trip.Direction result = transit_scheduled.GtfsSchedule.Trip.Direction.valueOf(directionId_);
      return result == null ? transit_scheduled.GtfsSchedule.Trip.Direction.UNRECOGNIZED : result;
    }

    public static final int BLOCK_ID_FIELD_NUMBER = 7;
    private volatile java.lang.Object blockId_;
    /**
     * <pre>
     * Identifies the block to which the trip belongs. A block consists of a
     * single trip or many sequential trips made using the same vehicle, defined
     * by shared service days and block_id. A block_id may have trips with
     * different service days, making distinct blocks. See the example below. To
     * provide in-seat transfers information, transfers of transfer_type 4 should
     * be provided instead.
     * </pre>
     *
     * <code>string block_id = 7;</code>
     * @return The blockId.
     */
    @java.lang.Override
    public java.lang.String getBlockId() {
      java.lang.Object ref = blockId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        blockId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies the block to which the trip belongs. A block consists of a
     * single trip or many sequential trips made using the same vehicle, defined
     * by shared service days and block_id. A block_id may have trips with
     * different service days, making distinct blocks. See the example below. To
     * provide in-seat transfers information, transfers of transfer_type 4 should
     * be provided instead.
     * </pre>
     *
     * <code>string block_id = 7;</code>
     * @return The bytes for blockId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getBlockIdBytes() {
      java.lang.Object ref = blockId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        blockId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SHAPE_ID_FIELD_NUMBER = 8;
    private volatile java.lang.Object shapeId_;
    /**
     * <pre>
     * Identifies a geospatial shape describing the vehicle travel path for a
     * trip.
     * Conditionally Required:
     * - Required if the trip has a continuous pickup or drop-off behavior defined
     * either in routes.txt or in stop_times.txt.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string shape_id = 8;</code>
     * @return The shapeId.
     */
    @java.lang.Override
    public java.lang.String getShapeId() {
      java.lang.Object ref = shapeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        shapeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies a geospatial shape describing the vehicle travel path for a
     * trip.
     * Conditionally Required:
     * - Required if the trip has a continuous pickup or drop-off behavior defined
     * either in routes.txt or in stop_times.txt.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string shape_id = 8;</code>
     * @return The bytes for shapeId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getShapeIdBytes() {
      java.lang.Object ref = shapeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        shapeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WHEELCHAIR_ACCESSIBLE_FIELD_NUMBER = 9;
    private int wheelchairAccessible_;
    /**
     * <pre>
     * Indicates wheelchair accessibility.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;</code>
     * @return The enum numeric value on the wire for wheelchairAccessible.
     */
    @java.lang.Override public int getWheelchairAccessibleValue() {
      return wheelchairAccessible_;
    }
    /**
     * <pre>
     * Indicates wheelchair accessibility.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;</code>
     * @return The wheelchairAccessible.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility getWheelchairAccessible() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility result = transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility.valueOf(wheelchairAccessible_);
      return result == null ? transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility.UNRECOGNIZED : result;
    }

    public static final int BIKES_ALLOWED_FIELD_NUMBER = 10;
    private int bikesAllowed_;
    /**
     * <pre>
     * Indicates whether bikes are allowed.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;</code>
     * @return The enum numeric value on the wire for bikesAllowed.
     */
    @java.lang.Override public int getBikesAllowedValue() {
      return bikesAllowed_;
    }
    /**
     * <pre>
     * Indicates whether bikes are allowed.
     * </pre>
     *
     * <code>.transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;</code>
     * @return The bikesAllowed.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.Trip.BikeAllowance getBikesAllowed() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.Trip.BikeAllowance result = transit_scheduled.GtfsSchedule.Trip.BikeAllowance.valueOf(bikesAllowed_);
      return result == null ? transit_scheduled.GtfsSchedule.Trip.BikeAllowance.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, routeId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serviceId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, serviceId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, tripId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripHeadsign_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, tripHeadsign_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripShortName_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, tripShortName_);
      }
      if (directionId_ != transit_scheduled.GtfsSchedule.Trip.Direction.DIRECTION_ONE_DIRECTION.getNumber()) {
        output.writeEnum(6, directionId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(blockId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, blockId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(shapeId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, shapeId_);
      }
      if (wheelchairAccessible_ != transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility.WHEELCHAIR_ACCESSIBILITY_NO_INFO.getNumber()) {
        output.writeEnum(9, wheelchairAccessible_);
      }
      if (bikesAllowed_ != transit_scheduled.GtfsSchedule.Trip.BikeAllowance.BIKE_ALLOWANCE_NO_INFO.getNumber()) {
        output.writeEnum(10, bikesAllowed_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(routeId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, routeId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serviceId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, serviceId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, tripId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripHeadsign_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, tripHeadsign_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripShortName_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, tripShortName_);
      }
      if (directionId_ != transit_scheduled.GtfsSchedule.Trip.Direction.DIRECTION_ONE_DIRECTION.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, directionId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(blockId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, blockId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(shapeId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, shapeId_);
      }
      if (wheelchairAccessible_ != transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility.WHEELCHAIR_ACCESSIBILITY_NO_INFO.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(9, wheelchairAccessible_);
      }
      if (bikesAllowed_ != transit_scheduled.GtfsSchedule.Trip.BikeAllowance.BIKE_ALLOWANCE_NO_INFO.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, bikesAllowed_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof transit_scheduled.GtfsSchedule.Trip)) {
        return super.equals(obj);
      }
      transit_scheduled.GtfsSchedule.Trip other = (transit_scheduled.GtfsSchedule.Trip) obj;

      if (!getRouteId()
          .equals(other.getRouteId())) return false;
      if (!getServiceId()
          .equals(other.getServiceId())) return false;
      if (!getTripId()
          .equals(other.getTripId())) return false;
      if (!getTripHeadsign()
          .equals(other.getTripHeadsign())) return false;
      if (!getTripShortName()
          .equals(other.getTripShortName())) return false;
      if (directionId_ != other.directionId_) return false;
      if (!getBlockId()
          .equals(other.getBlockId())) return false;
      if (!getShapeId()
          .equals(other.getShapeId())) return false;
      if (wheelchairAccessible_ != other.wheelchairAccessible_) return false;
      if (bikesAllowed_ != other.bikesAllowed_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + ROUTE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getRouteId().hashCode();
      hash = (37 * hash) + SERVICE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getServiceId().hashCode();
      hash = (37 * hash) + TRIP_ID_FIELD_NUMBER;
      hash = (53 * hash) + getTripId().hashCode();
      hash = (37 * hash) + TRIP_HEADSIGN_FIELD_NUMBER;
      hash = (53 * hash) + getTripHeadsign().hashCode();
      hash = (37 * hash) + TRIP_SHORT_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getTripShortName().hashCode();
      hash = (37 * hash) + DIRECTION_ID_FIELD_NUMBER;
      hash = (53 * hash) + directionId_;
      hash = (37 * hash) + BLOCK_ID_FIELD_NUMBER;
      hash = (53 * hash) + getBlockId().hashCode();
      hash = (37 * hash) + SHAPE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getShapeId().hashCode();
      hash = (37 * hash) + WHEELCHAIR_ACCESSIBLE_FIELD_NUMBER;
      hash = (53 * hash) + wheelchairAccessible_;
      hash = (37 * hash) + BIKES_ALLOWED_FIELD_NUMBER;
      hash = (53 * hash) + bikesAllowed_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static transit_scheduled.GtfsSchedule.Trip parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.Trip parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(transit_scheduled.GtfsSchedule.Trip prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Trips for each route. A trip is a sequence of two or more stops that occur
     * during a specific time period.
     * </pre>
     *
     * Protobuf type {@code transit_scheduled.Trip}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_scheduled.Trip)
        transit_scheduled.GtfsSchedule.TripOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Trip_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Trip_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                transit_scheduled.GtfsSchedule.Trip.class, transit_scheduled.GtfsSchedule.Trip.Builder.class);
      }

      // Construct using transit_scheduled.GtfsSchedule.Trip.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        routeId_ = "";

        serviceId_ = "";

        tripId_ = "";

        tripHeadsign_ = "";

        tripShortName_ = "";

        directionId_ = 0;

        blockId_ = "";

        shapeId_ = "";

        wheelchairAccessible_ = 0;

        bikesAllowed_ = 0;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_Trip_descriptor;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Trip getDefaultInstanceForType() {
        return transit_scheduled.GtfsSchedule.Trip.getDefaultInstance();
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Trip build() {
        transit_scheduled.GtfsSchedule.Trip result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Trip buildPartial() {
        transit_scheduled.GtfsSchedule.Trip result = new transit_scheduled.GtfsSchedule.Trip(this);
        result.routeId_ = routeId_;
        result.serviceId_ = serviceId_;
        result.tripId_ = tripId_;
        result.tripHeadsign_ = tripHeadsign_;
        result.tripShortName_ = tripShortName_;
        result.directionId_ = directionId_;
        result.blockId_ = blockId_;
        result.shapeId_ = shapeId_;
        result.wheelchairAccessible_ = wheelchairAccessible_;
        result.bikesAllowed_ = bikesAllowed_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof transit_scheduled.GtfsSchedule.Trip) {
          return mergeFrom((transit_scheduled.GtfsSchedule.Trip)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(transit_scheduled.GtfsSchedule.Trip other) {
        if (other == transit_scheduled.GtfsSchedule.Trip.getDefaultInstance()) return this;
        if (!other.getRouteId().isEmpty()) {
          routeId_ = other.routeId_;
          onChanged();
        }
        if (!other.getServiceId().isEmpty()) {
          serviceId_ = other.serviceId_;
          onChanged();
        }
        if (!other.getTripId().isEmpty()) {
          tripId_ = other.tripId_;
          onChanged();
        }
        if (!other.getTripHeadsign().isEmpty()) {
          tripHeadsign_ = other.tripHeadsign_;
          onChanged();
        }
        if (!other.getTripShortName().isEmpty()) {
          tripShortName_ = other.tripShortName_;
          onChanged();
        }
        if (other.directionId_ != 0) {
          setDirectionIdValue(other.getDirectionIdValue());
        }
        if (!other.getBlockId().isEmpty()) {
          blockId_ = other.blockId_;
          onChanged();
        }
        if (!other.getShapeId().isEmpty()) {
          shapeId_ = other.shapeId_;
          onChanged();
        }
        if (other.wheelchairAccessible_ != 0) {
          setWheelchairAccessibleValue(other.getWheelchairAccessibleValue());
        }
        if (other.bikesAllowed_ != 0) {
          setBikesAllowedValue(other.getBikesAllowedValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                routeId_ = input.readStringRequireUtf8();

                break;
              } // case 10
              case 18: {
                serviceId_ = input.readStringRequireUtf8();

                break;
              } // case 18
              case 26: {
                tripId_ = input.readStringRequireUtf8();

                break;
              } // case 26
              case 34: {
                tripHeadsign_ = input.readStringRequireUtf8();

                break;
              } // case 34
              case 42: {
                tripShortName_ = input.readStringRequireUtf8();

                break;
              } // case 42
              case 48: {
                directionId_ = input.readEnum();

                break;
              } // case 48
              case 58: {
                blockId_ = input.readStringRequireUtf8();

                break;
              } // case 58
              case 66: {
                shapeId_ = input.readStringRequireUtf8();

                break;
              } // case 66
              case 72: {
                wheelchairAccessible_ = input.readEnum();

                break;
              } // case 72
              case 80: {
                bikesAllowed_ = input.readEnum();

                break;
              } // case 80
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private java.lang.Object routeId_ = "";
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @return The routeId.
       */
      public java.lang.String getRouteId() {
        java.lang.Object ref = routeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          routeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @return The bytes for routeId.
       */
      public com.google.protobuf.ByteString
          getRouteIdBytes() {
        java.lang.Object ref = routeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          routeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @param value The routeId to set.
       * @return This builder for chaining.
       */
      public Builder setRouteId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        routeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRouteId() {
        
        routeId_ = getDefaultInstance().getRouteId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a route.
       * Required
       * </pre>
       *
       * <code>string route_id = 1;</code>
       * @param value The bytes for routeId to set.
       * @return This builder for chaining.
       */
      public Builder setRouteIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        routeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object serviceId_ = "";
      /**
       * <pre>
       * Identifies a set of dates when service is available for one or more routes.
       * Required
       * </pre>
       *
       * <code>string service_id = 2;</code>
       * @return The serviceId.
       */
      public java.lang.String getServiceId() {
        java.lang.Object ref = serviceId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          serviceId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies a set of dates when service is available for one or more routes.
       * Required
       * </pre>
       *
       * <code>string service_id = 2;</code>
       * @return The bytes for serviceId.
       */
      public com.google.protobuf.ByteString
          getServiceIdBytes() {
        java.lang.Object ref = serviceId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serviceId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies a set of dates when service is available for one or more routes.
       * Required
       * </pre>
       *
       * <code>string service_id = 2;</code>
       * @param value The serviceId to set.
       * @return This builder for chaining.
       */
      public Builder setServiceId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        serviceId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a set of dates when service is available for one or more routes.
       * Required
       * </pre>
       *
       * <code>string service_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearServiceId() {
        
        serviceId_ = getDefaultInstance().getServiceId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a set of dates when service is available for one or more routes.
       * Required
       * </pre>
       *
       * <code>string service_id = 2;</code>
       * @param value The bytes for serviceId to set.
       * @return This builder for chaining.
       */
      public Builder setServiceIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        serviceId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object tripId_ = "";
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 3;</code>
       * @return The tripId.
       */
      public java.lang.String getTripId() {
        java.lang.Object ref = tripId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          tripId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 3;</code>
       * @return The bytes for tripId.
       */
      public com.google.protobuf.ByteString
          getTripIdBytes() {
        java.lang.Object ref = tripId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tripId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 3;</code>
       * @param value The tripId to set.
       * @return This builder for chaining.
       */
      public Builder setTripId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        tripId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTripId() {
        
        tripId_ = getDefaultInstance().getTripId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 3;</code>
       * @param value The bytes for tripId to set.
       * @return This builder for chaining.
       */
      public Builder setTripIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        tripId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object tripHeadsign_ = "";
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * Should be used to distinguish between different patterns of service on the
       * same route.
       * If the headsign changes during a trip, values for trip_headsign may be
       * overridden by defining values in stop_times.stop_headsign for specific
       * stop_times along the trip.
       * </pre>
       *
       * <code>string trip_headsign = 4;</code>
       * @return The tripHeadsign.
       */
      public java.lang.String getTripHeadsign() {
        java.lang.Object ref = tripHeadsign_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          tripHeadsign_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * Should be used to distinguish between different patterns of service on the
       * same route.
       * If the headsign changes during a trip, values for trip_headsign may be
       * overridden by defining values in stop_times.stop_headsign for specific
       * stop_times along the trip.
       * </pre>
       *
       * <code>string trip_headsign = 4;</code>
       * @return The bytes for tripHeadsign.
       */
      public com.google.protobuf.ByteString
          getTripHeadsignBytes() {
        java.lang.Object ref = tripHeadsign_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tripHeadsign_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * Should be used to distinguish between different patterns of service on the
       * same route.
       * If the headsign changes during a trip, values for trip_headsign may be
       * overridden by defining values in stop_times.stop_headsign for specific
       * stop_times along the trip.
       * </pre>
       *
       * <code>string trip_headsign = 4;</code>
       * @param value The tripHeadsign to set.
       * @return This builder for chaining.
       */
      public Builder setTripHeadsign(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        tripHeadsign_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * Should be used to distinguish between different patterns of service on the
       * same route.
       * If the headsign changes during a trip, values for trip_headsign may be
       * overridden by defining values in stop_times.stop_headsign for specific
       * stop_times along the trip.
       * </pre>
       *
       * <code>string trip_headsign = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearTripHeadsign() {
        
        tripHeadsign_ = getDefaultInstance().getTripHeadsign();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * Should be used to distinguish between different patterns of service on the
       * same route.
       * If the headsign changes during a trip, values for trip_headsign may be
       * overridden by defining values in stop_times.stop_headsign for specific
       * stop_times along the trip.
       * </pre>
       *
       * <code>string trip_headsign = 4;</code>
       * @param value The bytes for tripHeadsign to set.
       * @return This builder for chaining.
       */
      public Builder setTripHeadsignBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        tripHeadsign_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object tripShortName_ = "";
      /**
       * <pre>
       * Public facing text used to identify the trip to riders, for instance, to
       * identify train numbers for commuter rail trips. If riders do not commonly
       * rely on trip names, trip_short_name should be empty. A trip_short_name
       * value, if provided, should uniquely identify a trip within a service day;
       * it should not be used for destination names or limited/express
       * designations.
       * </pre>
       *
       * <code>string trip_short_name = 5;</code>
       * @return The tripShortName.
       */
      public java.lang.String getTripShortName() {
        java.lang.Object ref = tripShortName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          tripShortName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Public facing text used to identify the trip to riders, for instance, to
       * identify train numbers for commuter rail trips. If riders do not commonly
       * rely on trip names, trip_short_name should be empty. A trip_short_name
       * value, if provided, should uniquely identify a trip within a service day;
       * it should not be used for destination names or limited/express
       * designations.
       * </pre>
       *
       * <code>string trip_short_name = 5;</code>
       * @return The bytes for tripShortName.
       */
      public com.google.protobuf.ByteString
          getTripShortNameBytes() {
        java.lang.Object ref = tripShortName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tripShortName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Public facing text used to identify the trip to riders, for instance, to
       * identify train numbers for commuter rail trips. If riders do not commonly
       * rely on trip names, trip_short_name should be empty. A trip_short_name
       * value, if provided, should uniquely identify a trip within a service day;
       * it should not be used for destination names or limited/express
       * designations.
       * </pre>
       *
       * <code>string trip_short_name = 5;</code>
       * @param value The tripShortName to set.
       * @return This builder for chaining.
       */
      public Builder setTripShortName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        tripShortName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Public facing text used to identify the trip to riders, for instance, to
       * identify train numbers for commuter rail trips. If riders do not commonly
       * rely on trip names, trip_short_name should be empty. A trip_short_name
       * value, if provided, should uniquely identify a trip within a service day;
       * it should not be used for destination names or limited/express
       * designations.
       * </pre>
       *
       * <code>string trip_short_name = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearTripShortName() {
        
        tripShortName_ = getDefaultInstance().getTripShortName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Public facing text used to identify the trip to riders, for instance, to
       * identify train numbers for commuter rail trips. If riders do not commonly
       * rely on trip names, trip_short_name should be empty. A trip_short_name
       * value, if provided, should uniquely identify a trip within a service day;
       * it should not be used for destination names or limited/express
       * designations.
       * </pre>
       *
       * <code>string trip_short_name = 5;</code>
       * @param value The bytes for tripShortName to set.
       * @return This builder for chaining.
       */
      public Builder setTripShortNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        tripShortName_ = value;
        onChanged();
        return this;
      }

      private int directionId_ = 0;
      /**
       * <pre>
       * Indicates the direction of travel for a trip.
       * This field should not be used in routing; it provides a way to separate
       * trips by direction when publishing time tables.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.Direction direction_id = 6;</code>
       * @return The enum numeric value on the wire for directionId.
       */
      @java.lang.Override public int getDirectionIdValue() {
        return directionId_;
      }
      /**
       * <pre>
       * Indicates the direction of travel for a trip.
       * This field should not be used in routing; it provides a way to separate
       * trips by direction when publishing time tables.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.Direction direction_id = 6;</code>
       * @param value The enum numeric value on the wire for directionId to set.
       * @return This builder for chaining.
       */
      public Builder setDirectionIdValue(int value) {
        
        directionId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates the direction of travel for a trip.
       * This field should not be used in routing; it provides a way to separate
       * trips by direction when publishing time tables.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.Direction direction_id = 6;</code>
       * @return The directionId.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Trip.Direction getDirectionId() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.Trip.Direction result = transit_scheduled.GtfsSchedule.Trip.Direction.valueOf(directionId_);
        return result == null ? transit_scheduled.GtfsSchedule.Trip.Direction.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates the direction of travel for a trip.
       * This field should not be used in routing; it provides a way to separate
       * trips by direction when publishing time tables.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.Direction direction_id = 6;</code>
       * @param value The directionId to set.
       * @return This builder for chaining.
       */
      public Builder setDirectionId(transit_scheduled.GtfsSchedule.Trip.Direction value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        directionId_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates the direction of travel for a trip.
       * This field should not be used in routing; it provides a way to separate
       * trips by direction when publishing time tables.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.Direction direction_id = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDirectionId() {
        
        directionId_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object blockId_ = "";
      /**
       * <pre>
       * Identifies the block to which the trip belongs. A block consists of a
       * single trip or many sequential trips made using the same vehicle, defined
       * by shared service days and block_id. A block_id may have trips with
       * different service days, making distinct blocks. See the example below. To
       * provide in-seat transfers information, transfers of transfer_type 4 should
       * be provided instead.
       * </pre>
       *
       * <code>string block_id = 7;</code>
       * @return The blockId.
       */
      public java.lang.String getBlockId() {
        java.lang.Object ref = blockId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          blockId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies the block to which the trip belongs. A block consists of a
       * single trip or many sequential trips made using the same vehicle, defined
       * by shared service days and block_id. A block_id may have trips with
       * different service days, making distinct blocks. See the example below. To
       * provide in-seat transfers information, transfers of transfer_type 4 should
       * be provided instead.
       * </pre>
       *
       * <code>string block_id = 7;</code>
       * @return The bytes for blockId.
       */
      public com.google.protobuf.ByteString
          getBlockIdBytes() {
        java.lang.Object ref = blockId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          blockId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies the block to which the trip belongs. A block consists of a
       * single trip or many sequential trips made using the same vehicle, defined
       * by shared service days and block_id. A block_id may have trips with
       * different service days, making distinct blocks. See the example below. To
       * provide in-seat transfers information, transfers of transfer_type 4 should
       * be provided instead.
       * </pre>
       *
       * <code>string block_id = 7;</code>
       * @param value The blockId to set.
       * @return This builder for chaining.
       */
      public Builder setBlockId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        blockId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the block to which the trip belongs. A block consists of a
       * single trip or many sequential trips made using the same vehicle, defined
       * by shared service days and block_id. A block_id may have trips with
       * different service days, making distinct blocks. See the example below. To
       * provide in-seat transfers information, transfers of transfer_type 4 should
       * be provided instead.
       * </pre>
       *
       * <code>string block_id = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockId() {
        
        blockId_ = getDefaultInstance().getBlockId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the block to which the trip belongs. A block consists of a
       * single trip or many sequential trips made using the same vehicle, defined
       * by shared service days and block_id. A block_id may have trips with
       * different service days, making distinct blocks. See the example below. To
       * provide in-seat transfers information, transfers of transfer_type 4 should
       * be provided instead.
       * </pre>
       *
       * <code>string block_id = 7;</code>
       * @param value The bytes for blockId to set.
       * @return This builder for chaining.
       */
      public Builder setBlockIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        blockId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object shapeId_ = "";
      /**
       * <pre>
       * Identifies a geospatial shape describing the vehicle travel path for a
       * trip.
       * Conditionally Required:
       * - Required if the trip has a continuous pickup or drop-off behavior defined
       * either in routes.txt or in stop_times.txt.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string shape_id = 8;</code>
       * @return The shapeId.
       */
      public java.lang.String getShapeId() {
        java.lang.Object ref = shapeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          shapeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies a geospatial shape describing the vehicle travel path for a
       * trip.
       * Conditionally Required:
       * - Required if the trip has a continuous pickup or drop-off behavior defined
       * either in routes.txt or in stop_times.txt.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string shape_id = 8;</code>
       * @return The bytes for shapeId.
       */
      public com.google.protobuf.ByteString
          getShapeIdBytes() {
        java.lang.Object ref = shapeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          shapeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies a geospatial shape describing the vehicle travel path for a
       * trip.
       * Conditionally Required:
       * - Required if the trip has a continuous pickup or drop-off behavior defined
       * either in routes.txt or in stop_times.txt.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string shape_id = 8;</code>
       * @param value The shapeId to set.
       * @return This builder for chaining.
       */
      public Builder setShapeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        shapeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a geospatial shape describing the vehicle travel path for a
       * trip.
       * Conditionally Required:
       * - Required if the trip has a continuous pickup or drop-off behavior defined
       * either in routes.txt or in stop_times.txt.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string shape_id = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearShapeId() {
        
        shapeId_ = getDefaultInstance().getShapeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a geospatial shape describing the vehicle travel path for a
       * trip.
       * Conditionally Required:
       * - Required if the trip has a continuous pickup or drop-off behavior defined
       * either in routes.txt or in stop_times.txt.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string shape_id = 8;</code>
       * @param value The bytes for shapeId to set.
       * @return This builder for chaining.
       */
      public Builder setShapeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        shapeId_ = value;
        onChanged();
        return this;
      }

      private int wheelchairAccessible_ = 0;
      /**
       * <pre>
       * Indicates wheelchair accessibility.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;</code>
       * @return The enum numeric value on the wire for wheelchairAccessible.
       */
      @java.lang.Override public int getWheelchairAccessibleValue() {
        return wheelchairAccessible_;
      }
      /**
       * <pre>
       * Indicates wheelchair accessibility.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;</code>
       * @param value The enum numeric value on the wire for wheelchairAccessible to set.
       * @return This builder for chaining.
       */
      public Builder setWheelchairAccessibleValue(int value) {
        
        wheelchairAccessible_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates wheelchair accessibility.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;</code>
       * @return The wheelchairAccessible.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility getWheelchairAccessible() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility result = transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility.valueOf(wheelchairAccessible_);
        return result == null ? transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates wheelchair accessibility.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;</code>
       * @param value The wheelchairAccessible to set.
       * @return This builder for chaining.
       */
      public Builder setWheelchairAccessible(transit_scheduled.GtfsSchedule.Trip.WheelchairAccessibility value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        wheelchairAccessible_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates wheelchair accessibility.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.WheelchairAccessibility wheelchair_accessible = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearWheelchairAccessible() {
        
        wheelchairAccessible_ = 0;
        onChanged();
        return this;
      }

      private int bikesAllowed_ = 0;
      /**
       * <pre>
       * Indicates whether bikes are allowed.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;</code>
       * @return The enum numeric value on the wire for bikesAllowed.
       */
      @java.lang.Override public int getBikesAllowedValue() {
        return bikesAllowed_;
      }
      /**
       * <pre>
       * Indicates whether bikes are allowed.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;</code>
       * @param value The enum numeric value on the wire for bikesAllowed to set.
       * @return This builder for chaining.
       */
      public Builder setBikesAllowedValue(int value) {
        
        bikesAllowed_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates whether bikes are allowed.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;</code>
       * @return The bikesAllowed.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.Trip.BikeAllowance getBikesAllowed() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.Trip.BikeAllowance result = transit_scheduled.GtfsSchedule.Trip.BikeAllowance.valueOf(bikesAllowed_);
        return result == null ? transit_scheduled.GtfsSchedule.Trip.BikeAllowance.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates whether bikes are allowed.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;</code>
       * @param value The bikesAllowed to set.
       * @return This builder for chaining.
       */
      public Builder setBikesAllowed(transit_scheduled.GtfsSchedule.Trip.BikeAllowance value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        bikesAllowed_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates whether bikes are allowed.
       * </pre>
       *
       * <code>.transit_scheduled.Trip.BikeAllowance bikes_allowed = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearBikesAllowed() {
        
        bikesAllowed_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:transit_scheduled.Trip)
    }

    // @@protoc_insertion_point(class_scope:transit_scheduled.Trip)
    private static final transit_scheduled.GtfsSchedule.Trip DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new transit_scheduled.GtfsSchedule.Trip();
    }

    public static transit_scheduled.GtfsSchedule.Trip getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Trip>
        PARSER = new com.google.protobuf.AbstractParser<Trip>() {
      @java.lang.Override
      public Trip parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Trip> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Trip> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public transit_scheduled.GtfsSchedule.Trip getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StopTimeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:transit_scheduled.StopTime)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 1;</code>
     * @return The tripId.
     */
    java.lang.String getTripId();
    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 1;</code>
     * @return The bytes for tripId.
     */
    com.google.protobuf.ByteString
        getTripIdBytes();

    /**
     * <pre>
     * Arrival time at the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for the first and last stop in a trip (defined by
     * stop_times.stop_sequence).
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string arrival_time = 2;</code>
     * @return The arrivalTime.
     */
    java.lang.String getArrivalTime();
    /**
     * <pre>
     * Arrival time at the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for the first and last stop in a trip (defined by
     * stop_times.stop_sequence).
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string arrival_time = 2;</code>
     * @return The bytes for arrivalTime.
     */
    com.google.protobuf.ByteString
        getArrivalTimeBytes();

    /**
     * <pre>
     * Departure time from the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string departure_time = 3;</code>
     * @return The departureTime.
     */
    java.lang.String getDepartureTime();
    /**
     * <pre>
     * Departure time from the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string departure_time = 3;</code>
     * @return The bytes for departureTime.
     */
    com.google.protobuf.ByteString
        getDepartureTimeBytes();

    /**
     * <pre>
     * Identifies the serviced stop. All stops serviced during a trip must have a
     * record in stop_times.txt. Referenced locations must be stops/platforms,
     * i.e. their stops.location_type value must be 0 or empty. A stop may be
     * serviced multiple times in the same trip, and multiple trips and routes may
     * service the same stop.
     * Required
     * </pre>
     *
     * <code>string stop_id = 4;</code>
     * @return The stopId.
     */
    java.lang.String getStopId();
    /**
     * <pre>
     * Identifies the serviced stop. All stops serviced during a trip must have a
     * record in stop_times.txt. Referenced locations must be stops/platforms,
     * i.e. their stops.location_type value must be 0 or empty. A stop may be
     * serviced multiple times in the same trip, and multiple trips and routes may
     * service the same stop.
     * Required
     * </pre>
     *
     * <code>string stop_id = 4;</code>
     * @return The bytes for stopId.
     */
    com.google.protobuf.ByteString
        getStopIdBytes();

    /**
     * <pre>
     * Order of stops for a particular trip. The values must increase along the
     * trip but do not need to be consecutive.
     * Required
     * </pre>
     *
     * <code>uint32 stop_sequence = 5;</code>
     * @return The stopSequence.
     */
    int getStopSequence();

    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * This field overrides the default trips.trip_headsign when the headsign
     * changes between stops. If the headsign is displayed for an entire trip,
     * trips.trip_headsign should be used instead.
     * A stop_headsign value specified for one stop_time does not apply to
     * subsequent stop_times in the same trip. If you want to override the
     * trip_headsign for multiple stop_times in the same trip, the stop_headsign
     * value must be repeated in each stop_time row.
     * </pre>
     *
     * <code>string stop_headsign = 6;</code>
     * @return The stopHeadsign.
     */
    java.lang.String getStopHeadsign();
    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * This field overrides the default trips.trip_headsign when the headsign
     * changes between stops. If the headsign is displayed for an entire trip,
     * trips.trip_headsign should be used instead.
     * A stop_headsign value specified for one stop_time does not apply to
     * subsequent stop_times in the same trip. If you want to override the
     * trip_headsign for multiple stop_times in the same trip, the stop_headsign
     * value must be repeated in each stop_time row.
     * </pre>
     *
     * <code>string stop_headsign = 6;</code>
     * @return The bytes for stopHeadsign.
     */
    com.google.protobuf.ByteString
        getStopHeadsignBytes();

    /**
     * <pre>
     * Indicates pickup method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
     * @return The enum numeric value on the wire for pickupType.
     */
    int getPickupTypeValue();
    /**
     * <pre>
     * Indicates pickup method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
     * @return The pickupType.
     */
    transit_scheduled.GtfsSchedule.StopTime.PickupType getPickupType();

    /**
     * <pre>
     * Indicates drop off method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
     * @return The enum numeric value on the wire for dropOffType.
     */
    int getDropOffTypeValue();
    /**
     * <pre>
     * Indicates drop off method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
     * @return The dropOffType.
     */
    transit_scheduled.GtfsSchedule.StopTime.DropOffType getDropOffType();

    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, from this stop_time
     * to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous pickup behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous pickup behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
     * @return The enum numeric value on the wire for continuousPickup.
     */
    int getContinuousPickupValue();
    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, from this stop_time
     * to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous pickup behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous pickup behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
     * @return The continuousPickup.
     */
    transit_scheduled.GtfsSchedule.ContinuousPickup getContinuousPickup();

    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, from this
     * stop_time to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous drop-off behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous drop-off behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
     * @return The enum numeric value on the wire for continuousDropOff.
     */
    int getContinuousDropOffValue();
    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, from this
     * stop_time to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous drop-off behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous drop-off behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
     * @return The continuousDropOff.
     */
    transit_scheduled.GtfsSchedule.ContinuousDropOff getContinuousDropOff();

    /**
     * <pre>
     * Actual distance traveled along the associated shape, from the first stop to
     * the stop specified in this record. This field specifies how much of the
     * shape to draw between any two stops during a trip. Must be in the same
     * units used in shapes.txt. Values used for shape_dist_traveled must increase
     * along with stop_sequence; they must not be used to show reverse travel
     * along a route.
     * Recommended for routes that have looping or inlining (the vehicle crosses
     * or travels over the same portion of alignment in one trip). See
     * shapes.shape_dist_traveled.
     * </pre>
     *
     * <code>float shape_dist_traveled = 11;</code>
     * @return The shapeDistTraveled.
     */
    float getShapeDistTraveled();

    /**
     * <pre>
     * Indicates if arrival and departure times for a stop are strictly adhered to
     * by the vehicle or if they are instead approximate and/or interpolated
     * times. This field allows a GTFS producer to provide interpolated
     * stop-times, while indicating that the times are approximate.
     * </pre>
     *
     * <code>uint32 timepoint = 12;</code>
     * @return The timepoint.
     */
    int getTimepoint();
  }
  /**
   * <pre>
   * Times that a vehicle arrives at and departs from stops for each trip.
   * </pre>
   *
   * Protobuf type {@code transit_scheduled.StopTime}
   */
  public static final class StopTime extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:transit_scheduled.StopTime)
      StopTimeOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use StopTime.newBuilder() to construct.
    private StopTime(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private StopTime() {
      tripId_ = "";
      arrivalTime_ = "";
      departureTime_ = "";
      stopId_ = "";
      stopHeadsign_ = "";
      pickupType_ = 0;
      dropOffType_ = 0;
      continuousPickup_ = 0;
      continuousDropOff_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new StopTime();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_StopTime_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_StopTime_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              transit_scheduled.GtfsSchedule.StopTime.class, transit_scheduled.GtfsSchedule.StopTime.Builder.class);
    }

    /**
     * <pre>
     * Indicates pickup method. Valid options are:
     *   0 or empty - Regularly scheduled pickup.
     *   1 - No pickup available.
     *   2 - Must phone agency to arrange pickup.
     *   3 - Must coordinate with driver to arrange pickup.
     * </pre>
     *
     * Protobuf enum {@code transit_scheduled.StopTime.PickupType}
     */
    public enum PickupType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>PICKUP_TYPE_REGULARLY_SCHEDULED = 0;</code>
       */
      PICKUP_TYPE_REGULARLY_SCHEDULED(0),
      /**
       * <code>PICKUP_TYPE_NONE_AVAILABLE = 1;</code>
       */
      PICKUP_TYPE_NONE_AVAILABLE(1),
      /**
       * <code>PICKUP_TYPE_MUST_PHONE_AGENCY = 2;</code>
       */
      PICKUP_TYPE_MUST_PHONE_AGENCY(2),
      /**
       * <code>PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER = 3;</code>
       */
      PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER(3),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>PICKUP_TYPE_REGULARLY_SCHEDULED = 0;</code>
       */
      public static final int PICKUP_TYPE_REGULARLY_SCHEDULED_VALUE = 0;
      /**
       * <code>PICKUP_TYPE_NONE_AVAILABLE = 1;</code>
       */
      public static final int PICKUP_TYPE_NONE_AVAILABLE_VALUE = 1;
      /**
       * <code>PICKUP_TYPE_MUST_PHONE_AGENCY = 2;</code>
       */
      public static final int PICKUP_TYPE_MUST_PHONE_AGENCY_VALUE = 2;
      /**
       * <code>PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER = 3;</code>
       */
      public static final int PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER_VALUE = 3;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PickupType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static PickupType forNumber(int value) {
        switch (value) {
          case 0: return PICKUP_TYPE_REGULARLY_SCHEDULED;
          case 1: return PICKUP_TYPE_NONE_AVAILABLE;
          case 2: return PICKUP_TYPE_MUST_PHONE_AGENCY;
          case 3: return PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PickupType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PickupType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PickupType>() {
              public PickupType findValueByNumber(int number) {
                return PickupType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.StopTime.getDescriptor().getEnumTypes().get(0);
      }

      private static final PickupType[] VALUES = values();

      public static PickupType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private PickupType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_scheduled.StopTime.PickupType)
    }

    /**
     * <pre>
     * Indicates drop off method. Valid options are:
     *   0 or empty - Regularly scheduled drop off.
     *   1 - No drop off available.
     *   2 - Must phone agency to arrange drop off.
     *   3 - Must coordinate with driver to arrange drop off.
     * </pre>
     *
     * Protobuf enum {@code transit_scheduled.StopTime.DropOffType}
     */
    public enum DropOffType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>DROP_OFF_TYPE_REGULARLY_SCHEDULED = 0;</code>
       */
      DROP_OFF_TYPE_REGULARLY_SCHEDULED(0),
      /**
       * <code>DROP_OFF_TYPE_NONE_AVAILABLE = 1;</code>
       */
      DROP_OFF_TYPE_NONE_AVAILABLE(1),
      /**
       * <code>DROP_OFF_TYPE_MUST_PHONE_AGENCY = 2;</code>
       */
      DROP_OFF_TYPE_MUST_PHONE_AGENCY(2),
      /**
       * <code>DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER = 3;</code>
       */
      DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER(3),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>DROP_OFF_TYPE_REGULARLY_SCHEDULED = 0;</code>
       */
      public static final int DROP_OFF_TYPE_REGULARLY_SCHEDULED_VALUE = 0;
      /**
       * <code>DROP_OFF_TYPE_NONE_AVAILABLE = 1;</code>
       */
      public static final int DROP_OFF_TYPE_NONE_AVAILABLE_VALUE = 1;
      /**
       * <code>DROP_OFF_TYPE_MUST_PHONE_AGENCY = 2;</code>
       */
      public static final int DROP_OFF_TYPE_MUST_PHONE_AGENCY_VALUE = 2;
      /**
       * <code>DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER = 3;</code>
       */
      public static final int DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER_VALUE = 3;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static DropOffType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static DropOffType forNumber(int value) {
        switch (value) {
          case 0: return DROP_OFF_TYPE_REGULARLY_SCHEDULED;
          case 1: return DROP_OFF_TYPE_NONE_AVAILABLE;
          case 2: return DROP_OFF_TYPE_MUST_PHONE_AGENCY;
          case 3: return DROP_OFF_TYPE_MUST_COORDINATE_WITH_DRIVER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<DropOffType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          DropOffType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<DropOffType>() {
              public DropOffType findValueByNumber(int number) {
                return DropOffType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.StopTime.getDescriptor().getEnumTypes().get(1);
      }

      private static final DropOffType[] VALUES = values();

      public static DropOffType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private DropOffType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_scheduled.StopTime.DropOffType)
    }

    /**
     * <pre>
     * Indicates if arrival and departure times for a stop are strictly adhered to
     * by the vehicle or if they are instead approximate and/or interpolated
     * times. This field allows a GTFS producer to provide interpolated
     * stop-times, while indicating that the times are approximate.
     * Valid options are:
     *   0 - Times are considered approximate.
     *   1 or empty - Times are considered exact.
     * </pre>
     *
     * Protobuf enum {@code transit_scheduled.StopTime.TimePoint}
     */
    public enum TimePoint
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>TIME_POINT_APPROXIMATE = 0;</code>
       */
      TIME_POINT_APPROXIMATE(0),
      /**
       * <code>TIME_POINT_EXACT = 1;</code>
       */
      TIME_POINT_EXACT(1),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>TIME_POINT_APPROXIMATE = 0;</code>
       */
      public static final int TIME_POINT_APPROXIMATE_VALUE = 0;
      /**
       * <code>TIME_POINT_EXACT = 1;</code>
       */
      public static final int TIME_POINT_EXACT_VALUE = 1;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TimePoint valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static TimePoint forNumber(int value) {
        switch (value) {
          case 0: return TIME_POINT_APPROXIMATE;
          case 1: return TIME_POINT_EXACT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<TimePoint>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          TimePoint> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<TimePoint>() {
              public TimePoint findValueByNumber(int number) {
                return TimePoint.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.StopTime.getDescriptor().getEnumTypes().get(2);
      }

      private static final TimePoint[] VALUES = values();

      public static TimePoint valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private TimePoint(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_scheduled.StopTime.TimePoint)
    }

    public static final int TRIP_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object tripId_;
    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 1;</code>
     * @return The tripId.
     */
    @java.lang.Override
    public java.lang.String getTripId() {
      java.lang.Object ref = tripId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        tripId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 1;</code>
     * @return The bytes for tripId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTripIdBytes() {
      java.lang.Object ref = tripId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        tripId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ARRIVAL_TIME_FIELD_NUMBER = 2;
    private volatile java.lang.Object arrivalTime_;
    /**
     * <pre>
     * Arrival time at the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for the first and last stop in a trip (defined by
     * stop_times.stop_sequence).
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string arrival_time = 2;</code>
     * @return The arrivalTime.
     */
    @java.lang.Override
    public java.lang.String getArrivalTime() {
      java.lang.Object ref = arrivalTime_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        arrivalTime_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Arrival time at the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for the first and last stop in a trip (defined by
     * stop_times.stop_sequence).
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string arrival_time = 2;</code>
     * @return The bytes for arrivalTime.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getArrivalTimeBytes() {
      java.lang.Object ref = arrivalTime_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        arrivalTime_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEPARTURE_TIME_FIELD_NUMBER = 3;
    private volatile java.lang.Object departureTime_;
    /**
     * <pre>
     * Departure time from the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string departure_time = 3;</code>
     * @return The departureTime.
     */
    @java.lang.Override
    public java.lang.String getDepartureTime() {
      java.lang.Object ref = departureTime_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        departureTime_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Departure time from the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string departure_time = 3;</code>
     * @return The bytes for departureTime.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDepartureTimeBytes() {
      java.lang.Object ref = departureTime_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        departureTime_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_ID_FIELD_NUMBER = 4;
    private volatile java.lang.Object stopId_;
    /**
     * <pre>
     * Identifies the serviced stop. All stops serviced during a trip must have a
     * record in stop_times.txt. Referenced locations must be stops/platforms,
     * i.e. their stops.location_type value must be 0 or empty. A stop may be
     * serviced multiple times in the same trip, and multiple trips and routes may
     * service the same stop.
     * Required
     * </pre>
     *
     * <code>string stop_id = 4;</code>
     * @return The stopId.
     */
    @java.lang.Override
    public java.lang.String getStopId() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stopId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identifies the serviced stop. All stops serviced during a trip must have a
     * record in stop_times.txt. Referenced locations must be stops/platforms,
     * i.e. their stops.location_type value must be 0 or empty. A stop may be
     * serviced multiple times in the same trip, and multiple trips and routes may
     * service the same stop.
     * Required
     * </pre>
     *
     * <code>string stop_id = 4;</code>
     * @return The bytes for stopId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopIdBytes() {
      java.lang.Object ref = stopId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STOP_SEQUENCE_FIELD_NUMBER = 5;
    private int stopSequence_;
    /**
     * <pre>
     * Order of stops for a particular trip. The values must increase along the
     * trip but do not need to be consecutive.
     * Required
     * </pre>
     *
     * <code>uint32 stop_sequence = 5;</code>
     * @return The stopSequence.
     */
    @java.lang.Override
    public int getStopSequence() {
      return stopSequence_;
    }

    public static final int STOP_HEADSIGN_FIELD_NUMBER = 6;
    private volatile java.lang.Object stopHeadsign_;
    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * This field overrides the default trips.trip_headsign when the headsign
     * changes between stops. If the headsign is displayed for an entire trip,
     * trips.trip_headsign should be used instead.
     * A stop_headsign value specified for one stop_time does not apply to
     * subsequent stop_times in the same trip. If you want to override the
     * trip_headsign for multiple stop_times in the same trip, the stop_headsign
     * value must be repeated in each stop_time row.
     * </pre>
     *
     * <code>string stop_headsign = 6;</code>
     * @return The stopHeadsign.
     */
    @java.lang.Override
    public java.lang.String getStopHeadsign() {
      java.lang.Object ref = stopHeadsign_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stopHeadsign_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * This field overrides the default trips.trip_headsign when the headsign
     * changes between stops. If the headsign is displayed for an entire trip,
     * trips.trip_headsign should be used instead.
     * A stop_headsign value specified for one stop_time does not apply to
     * subsequent stop_times in the same trip. If you want to override the
     * trip_headsign for multiple stop_times in the same trip, the stop_headsign
     * value must be repeated in each stop_time row.
     * </pre>
     *
     * <code>string stop_headsign = 6;</code>
     * @return The bytes for stopHeadsign.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getStopHeadsignBytes() {
      java.lang.Object ref = stopHeadsign_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stopHeadsign_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PICKUP_TYPE_FIELD_NUMBER = 7;
    private int pickupType_;
    /**
     * <pre>
     * Indicates pickup method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
     * @return The enum numeric value on the wire for pickupType.
     */
    @java.lang.Override public int getPickupTypeValue() {
      return pickupType_;
    }
    /**
     * <pre>
     * Indicates pickup method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
     * @return The pickupType.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.StopTime.PickupType getPickupType() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.StopTime.PickupType result = transit_scheduled.GtfsSchedule.StopTime.PickupType.valueOf(pickupType_);
      return result == null ? transit_scheduled.GtfsSchedule.StopTime.PickupType.UNRECOGNIZED : result;
    }

    public static final int DROP_OFF_TYPE_FIELD_NUMBER = 8;
    private int dropOffType_;
    /**
     * <pre>
     * Indicates drop off method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
     * @return The enum numeric value on the wire for dropOffType.
     */
    @java.lang.Override public int getDropOffTypeValue() {
      return dropOffType_;
    }
    /**
     * <pre>
     * Indicates drop off method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
     * @return The dropOffType.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.StopTime.DropOffType getDropOffType() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.StopTime.DropOffType result = transit_scheduled.GtfsSchedule.StopTime.DropOffType.valueOf(dropOffType_);
      return result == null ? transit_scheduled.GtfsSchedule.StopTime.DropOffType.UNRECOGNIZED : result;
    }

    public static final int CONTINUOUS_PICKUP_FIELD_NUMBER = 9;
    private int continuousPickup_;
    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, from this stop_time
     * to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous pickup behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous pickup behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
     * @return The enum numeric value on the wire for continuousPickup.
     */
    @java.lang.Override public int getContinuousPickupValue() {
      return continuousPickup_;
    }
    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, from this stop_time
     * to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous pickup behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous pickup behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
     * @return The continuousPickup.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.ContinuousPickup getContinuousPickup() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.ContinuousPickup result = transit_scheduled.GtfsSchedule.ContinuousPickup.valueOf(continuousPickup_);
      return result == null ? transit_scheduled.GtfsSchedule.ContinuousPickup.UNRECOGNIZED : result;
    }

    public static final int CONTINUOUS_DROP_OFF_FIELD_NUMBER = 10;
    private int continuousDropOff_;
    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, from this
     * stop_time to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous drop-off behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous drop-off behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
     * @return The enum numeric value on the wire for continuousDropOff.
     */
    @java.lang.Override public int getContinuousDropOffValue() {
      return continuousDropOff_;
    }
    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, from this
     * stop_time to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous drop-off behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous drop-off behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
     * @return The continuousDropOff.
     */
    @java.lang.Override public transit_scheduled.GtfsSchedule.ContinuousDropOff getContinuousDropOff() {
      @SuppressWarnings("deprecation")
      transit_scheduled.GtfsSchedule.ContinuousDropOff result = transit_scheduled.GtfsSchedule.ContinuousDropOff.valueOf(continuousDropOff_);
      return result == null ? transit_scheduled.GtfsSchedule.ContinuousDropOff.UNRECOGNIZED : result;
    }

    public static final int SHAPE_DIST_TRAVELED_FIELD_NUMBER = 11;
    private float shapeDistTraveled_;
    /**
     * <pre>
     * Actual distance traveled along the associated shape, from the first stop to
     * the stop specified in this record. This field specifies how much of the
     * shape to draw between any two stops during a trip. Must be in the same
     * units used in shapes.txt. Values used for shape_dist_traveled must increase
     * along with stop_sequence; they must not be used to show reverse travel
     * along a route.
     * Recommended for routes that have looping or inlining (the vehicle crosses
     * or travels over the same portion of alignment in one trip). See
     * shapes.shape_dist_traveled.
     * </pre>
     *
     * <code>float shape_dist_traveled = 11;</code>
     * @return The shapeDistTraveled.
     */
    @java.lang.Override
    public float getShapeDistTraveled() {
      return shapeDistTraveled_;
    }

    public static final int TIMEPOINT_FIELD_NUMBER = 12;
    private int timepoint_;
    /**
     * <pre>
     * Indicates if arrival and departure times for a stop are strictly adhered to
     * by the vehicle or if they are instead approximate and/or interpolated
     * times. This field allows a GTFS producer to provide interpolated
     * stop-times, while indicating that the times are approximate.
     * </pre>
     *
     * <code>uint32 timepoint = 12;</code>
     * @return The timepoint.
     */
    @java.lang.Override
    public int getTimepoint() {
      return timepoint_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, tripId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(arrivalTime_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, arrivalTime_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(departureTime_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, departureTime_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopId_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, stopId_);
      }
      if (stopSequence_ != 0) {
        output.writeUInt32(5, stopSequence_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopHeadsign_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, stopHeadsign_);
      }
      if (pickupType_ != transit_scheduled.GtfsSchedule.StopTime.PickupType.PICKUP_TYPE_REGULARLY_SCHEDULED.getNumber()) {
        output.writeEnum(7, pickupType_);
      }
      if (dropOffType_ != transit_scheduled.GtfsSchedule.StopTime.DropOffType.DROP_OFF_TYPE_REGULARLY_SCHEDULED.getNumber()) {
        output.writeEnum(8, dropOffType_);
      }
      if (continuousPickup_ != transit_scheduled.GtfsSchedule.ContinuousPickup.CONTINUOUS_PICKUP_STOPPING.getNumber()) {
        output.writeEnum(9, continuousPickup_);
      }
      if (continuousDropOff_ != transit_scheduled.GtfsSchedule.ContinuousDropOff.CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING.getNumber()) {
        output.writeEnum(10, continuousDropOff_);
      }
      if (java.lang.Float.floatToRawIntBits(shapeDistTraveled_) != 0) {
        output.writeFloat(11, shapeDistTraveled_);
      }
      if (timepoint_ != 0) {
        output.writeUInt32(12, timepoint_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, tripId_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(arrivalTime_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, arrivalTime_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(departureTime_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, departureTime_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopId_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, stopId_);
      }
      if (stopSequence_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, stopSequence_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(stopHeadsign_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, stopHeadsign_);
      }
      if (pickupType_ != transit_scheduled.GtfsSchedule.StopTime.PickupType.PICKUP_TYPE_REGULARLY_SCHEDULED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(7, pickupType_);
      }
      if (dropOffType_ != transit_scheduled.GtfsSchedule.StopTime.DropOffType.DROP_OFF_TYPE_REGULARLY_SCHEDULED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(8, dropOffType_);
      }
      if (continuousPickup_ != transit_scheduled.GtfsSchedule.ContinuousPickup.CONTINUOUS_PICKUP_STOPPING.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(9, continuousPickup_);
      }
      if (continuousDropOff_ != transit_scheduled.GtfsSchedule.ContinuousDropOff.CONTINUOUS_DROP_OFF_CONTINUOUS_STOPPING.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, continuousDropOff_);
      }
      if (java.lang.Float.floatToRawIntBits(shapeDistTraveled_) != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(11, shapeDistTraveled_);
      }
      if (timepoint_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(12, timepoint_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof transit_scheduled.GtfsSchedule.StopTime)) {
        return super.equals(obj);
      }
      transit_scheduled.GtfsSchedule.StopTime other = (transit_scheduled.GtfsSchedule.StopTime) obj;

      if (!getTripId()
          .equals(other.getTripId())) return false;
      if (!getArrivalTime()
          .equals(other.getArrivalTime())) return false;
      if (!getDepartureTime()
          .equals(other.getDepartureTime())) return false;
      if (!getStopId()
          .equals(other.getStopId())) return false;
      if (getStopSequence()
          != other.getStopSequence()) return false;
      if (!getStopHeadsign()
          .equals(other.getStopHeadsign())) return false;
      if (pickupType_ != other.pickupType_) return false;
      if (dropOffType_ != other.dropOffType_) return false;
      if (continuousPickup_ != other.continuousPickup_) return false;
      if (continuousDropOff_ != other.continuousDropOff_) return false;
      if (java.lang.Float.floatToIntBits(getShapeDistTraveled())
          != java.lang.Float.floatToIntBits(
              other.getShapeDistTraveled())) return false;
      if (getTimepoint()
          != other.getTimepoint()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TRIP_ID_FIELD_NUMBER;
      hash = (53 * hash) + getTripId().hashCode();
      hash = (37 * hash) + ARRIVAL_TIME_FIELD_NUMBER;
      hash = (53 * hash) + getArrivalTime().hashCode();
      hash = (37 * hash) + DEPARTURE_TIME_FIELD_NUMBER;
      hash = (53 * hash) + getDepartureTime().hashCode();
      hash = (37 * hash) + STOP_ID_FIELD_NUMBER;
      hash = (53 * hash) + getStopId().hashCode();
      hash = (37 * hash) + STOP_SEQUENCE_FIELD_NUMBER;
      hash = (53 * hash) + getStopSequence();
      hash = (37 * hash) + STOP_HEADSIGN_FIELD_NUMBER;
      hash = (53 * hash) + getStopHeadsign().hashCode();
      hash = (37 * hash) + PICKUP_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + pickupType_;
      hash = (37 * hash) + DROP_OFF_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + dropOffType_;
      hash = (37 * hash) + CONTINUOUS_PICKUP_FIELD_NUMBER;
      hash = (53 * hash) + continuousPickup_;
      hash = (37 * hash) + CONTINUOUS_DROP_OFF_FIELD_NUMBER;
      hash = (53 * hash) + continuousDropOff_;
      hash = (37 * hash) + SHAPE_DIST_TRAVELED_FIELD_NUMBER;
      hash = (53 * hash) + java.lang.Float.floatToIntBits(
          getShapeDistTraveled());
      hash = (37 * hash) + TIMEPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getTimepoint();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static transit_scheduled.GtfsSchedule.StopTime parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(transit_scheduled.GtfsSchedule.StopTime prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Times that a vehicle arrives at and departs from stops for each trip.
     * </pre>
     *
     * Protobuf type {@code transit_scheduled.StopTime}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:transit_scheduled.StopTime)
        transit_scheduled.GtfsSchedule.StopTimeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_StopTime_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_StopTime_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                transit_scheduled.GtfsSchedule.StopTime.class, transit_scheduled.GtfsSchedule.StopTime.Builder.class);
      }

      // Construct using transit_scheduled.GtfsSchedule.StopTime.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        tripId_ = "";

        arrivalTime_ = "";

        departureTime_ = "";

        stopId_ = "";

        stopSequence_ = 0;

        stopHeadsign_ = "";

        pickupType_ = 0;

        dropOffType_ = 0;

        continuousPickup_ = 0;

        continuousDropOff_ = 0;

        shapeDistTraveled_ = 0F;

        timepoint_ = 0;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return transit_scheduled.GtfsSchedule.internal_static_transit_scheduled_StopTime_descriptor;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.StopTime getDefaultInstanceForType() {
        return transit_scheduled.GtfsSchedule.StopTime.getDefaultInstance();
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.StopTime build() {
        transit_scheduled.GtfsSchedule.StopTime result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public transit_scheduled.GtfsSchedule.StopTime buildPartial() {
        transit_scheduled.GtfsSchedule.StopTime result = new transit_scheduled.GtfsSchedule.StopTime(this);
        result.tripId_ = tripId_;
        result.arrivalTime_ = arrivalTime_;
        result.departureTime_ = departureTime_;
        result.stopId_ = stopId_;
        result.stopSequence_ = stopSequence_;
        result.stopHeadsign_ = stopHeadsign_;
        result.pickupType_ = pickupType_;
        result.dropOffType_ = dropOffType_;
        result.continuousPickup_ = continuousPickup_;
        result.continuousDropOff_ = continuousDropOff_;
        result.shapeDistTraveled_ = shapeDistTraveled_;
        result.timepoint_ = timepoint_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof transit_scheduled.GtfsSchedule.StopTime) {
          return mergeFrom((transit_scheduled.GtfsSchedule.StopTime)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(transit_scheduled.GtfsSchedule.StopTime other) {
        if (other == transit_scheduled.GtfsSchedule.StopTime.getDefaultInstance()) return this;
        if (!other.getTripId().isEmpty()) {
          tripId_ = other.tripId_;
          onChanged();
        }
        if (!other.getArrivalTime().isEmpty()) {
          arrivalTime_ = other.arrivalTime_;
          onChanged();
        }
        if (!other.getDepartureTime().isEmpty()) {
          departureTime_ = other.departureTime_;
          onChanged();
        }
        if (!other.getStopId().isEmpty()) {
          stopId_ = other.stopId_;
          onChanged();
        }
        if (other.getStopSequence() != 0) {
          setStopSequence(other.getStopSequence());
        }
        if (!other.getStopHeadsign().isEmpty()) {
          stopHeadsign_ = other.stopHeadsign_;
          onChanged();
        }
        if (other.pickupType_ != 0) {
          setPickupTypeValue(other.getPickupTypeValue());
        }
        if (other.dropOffType_ != 0) {
          setDropOffTypeValue(other.getDropOffTypeValue());
        }
        if (other.continuousPickup_ != 0) {
          setContinuousPickupValue(other.getContinuousPickupValue());
        }
        if (other.continuousDropOff_ != 0) {
          setContinuousDropOffValue(other.getContinuousDropOffValue());
        }
        if (other.getShapeDistTraveled() != 0F) {
          setShapeDistTraveled(other.getShapeDistTraveled());
        }
        if (other.getTimepoint() != 0) {
          setTimepoint(other.getTimepoint());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                tripId_ = input.readStringRequireUtf8();

                break;
              } // case 10
              case 18: {
                arrivalTime_ = input.readStringRequireUtf8();

                break;
              } // case 18
              case 26: {
                departureTime_ = input.readStringRequireUtf8();

                break;
              } // case 26
              case 34: {
                stopId_ = input.readStringRequireUtf8();

                break;
              } // case 34
              case 40: {
                stopSequence_ = input.readUInt32();

                break;
              } // case 40
              case 50: {
                stopHeadsign_ = input.readStringRequireUtf8();

                break;
              } // case 50
              case 56: {
                pickupType_ = input.readEnum();

                break;
              } // case 56
              case 64: {
                dropOffType_ = input.readEnum();

                break;
              } // case 64
              case 72: {
                continuousPickup_ = input.readEnum();

                break;
              } // case 72
              case 80: {
                continuousDropOff_ = input.readEnum();

                break;
              } // case 80
              case 93: {
                shapeDistTraveled_ = input.readFloat();

                break;
              } // case 93
              case 96: {
                timepoint_ = input.readUInt32();

                break;
              } // case 96
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private java.lang.Object tripId_ = "";
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 1;</code>
       * @return The tripId.
       */
      public java.lang.String getTripId() {
        java.lang.Object ref = tripId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          tripId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 1;</code>
       * @return The bytes for tripId.
       */
      public com.google.protobuf.ByteString
          getTripIdBytes() {
        java.lang.Object ref = tripId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tripId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 1;</code>
       * @param value The tripId to set.
       * @return This builder for chaining.
       */
      public Builder setTripId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        tripId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTripId() {
        
        tripId_ = getDefaultInstance().getTripId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies a trip.
       * Required
       * </pre>
       *
       * <code>string trip_id = 1;</code>
       * @param value The bytes for tripId to set.
       * @return This builder for chaining.
       */
      public Builder setTripIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        tripId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object arrivalTime_ = "";
      /**
       * <pre>
       * Arrival time at the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for the first and last stop in a trip (defined by
       * stop_times.stop_sequence).
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string arrival_time = 2;</code>
       * @return The arrivalTime.
       */
      public java.lang.String getArrivalTime() {
        java.lang.Object ref = arrivalTime_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          arrivalTime_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Arrival time at the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for the first and last stop in a trip (defined by
       * stop_times.stop_sequence).
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string arrival_time = 2;</code>
       * @return The bytes for arrivalTime.
       */
      public com.google.protobuf.ByteString
          getArrivalTimeBytes() {
        java.lang.Object ref = arrivalTime_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          arrivalTime_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Arrival time at the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for the first and last stop in a trip (defined by
       * stop_times.stop_sequence).
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string arrival_time = 2;</code>
       * @param value The arrivalTime to set.
       * @return This builder for chaining.
       */
      public Builder setArrivalTime(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        arrivalTime_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Arrival time at the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for the first and last stop in a trip (defined by
       * stop_times.stop_sequence).
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string arrival_time = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearArrivalTime() {
        
        arrivalTime_ = getDefaultInstance().getArrivalTime();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Arrival time at the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for the first and last stop in a trip (defined by
       * stop_times.stop_sequence).
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string arrival_time = 2;</code>
       * @param value The bytes for arrivalTime to set.
       * @return This builder for chaining.
       */
      public Builder setArrivalTimeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        arrivalTime_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object departureTime_ = "";
      /**
       * <pre>
       * Departure time from the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string departure_time = 3;</code>
       * @return The departureTime.
       */
      public java.lang.String getDepartureTime() {
        java.lang.Object ref = departureTime_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          departureTime_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Departure time from the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string departure_time = 3;</code>
       * @return The bytes for departureTime.
       */
      public com.google.protobuf.ByteString
          getDepartureTimeBytes() {
        java.lang.Object ref = departureTime_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          departureTime_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Departure time from the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string departure_time = 3;</code>
       * @param value The departureTime to set.
       * @return This builder for chaining.
       */
      public Builder setDepartureTime(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        departureTime_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Departure time from the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string departure_time = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDepartureTime() {
        
        departureTime_ = getDefaultInstance().getDepartureTime();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Departure time from the stop (defined by stop_times.stop_id) for a specific
       * trip (defined by stop_times.trip_id) in the time zone specified by
       * agency.agency_timezone, not stops.stop_timezone.
       * If there are not separate times for arrival and departure at a stop,
       * arrival_time and departure_time should be the same.
       * For times occurring after midnight on the service day, enter the time as a
       * value greater than 24:00:00 in HH:MM:SS.
       * If exact arrival and departure times (timepoint=1 or empty) are not
       * available, estimated or interpolated arrival and departure times
       * (timepoint=0) should be provided.
       * Conditionally Required:
       * - Required for timepoint=1.
       * - Optional otherwise.
       * </pre>
       *
       * <code>string departure_time = 3;</code>
       * @param value The bytes for departureTime to set.
       * @return This builder for chaining.
       */
      public Builder setDepartureTimeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        departureTime_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object stopId_ = "";
      /**
       * <pre>
       * Identifies the serviced stop. All stops serviced during a trip must have a
       * record in stop_times.txt. Referenced locations must be stops/platforms,
       * i.e. their stops.location_type value must be 0 or empty. A stop may be
       * serviced multiple times in the same trip, and multiple trips and routes may
       * service the same stop.
       * Required
       * </pre>
       *
       * <code>string stop_id = 4;</code>
       * @return The stopId.
       */
      public java.lang.String getStopId() {
        java.lang.Object ref = stopId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stopId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies the serviced stop. All stops serviced during a trip must have a
       * record in stop_times.txt. Referenced locations must be stops/platforms,
       * i.e. their stops.location_type value must be 0 or empty. A stop may be
       * serviced multiple times in the same trip, and multiple trips and routes may
       * service the same stop.
       * Required
       * </pre>
       *
       * <code>string stop_id = 4;</code>
       * @return The bytes for stopId.
       */
      public com.google.protobuf.ByteString
          getStopIdBytes() {
        java.lang.Object ref = stopId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies the serviced stop. All stops serviced during a trip must have a
       * record in stop_times.txt. Referenced locations must be stops/platforms,
       * i.e. their stops.location_type value must be 0 or empty. A stop may be
       * serviced multiple times in the same trip, and multiple trips and routes may
       * service the same stop.
       * Required
       * </pre>
       *
       * <code>string stop_id = 4;</code>
       * @param value The stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stopId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the serviced stop. All stops serviced during a trip must have a
       * record in stop_times.txt. Referenced locations must be stops/platforms,
       * i.e. their stops.location_type value must be 0 or empty. A stop may be
       * serviced multiple times in the same trip, and multiple trips and routes may
       * service the same stop.
       * Required
       * </pre>
       *
       * <code>string stop_id = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopId() {
        
        stopId_ = getDefaultInstance().getStopId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the serviced stop. All stops serviced during a trip must have a
       * record in stop_times.txt. Referenced locations must be stops/platforms,
       * i.e. their stops.location_type value must be 0 or empty. A stop may be
       * serviced multiple times in the same trip, and multiple trips and routes may
       * service the same stop.
       * Required
       * </pre>
       *
       * <code>string stop_id = 4;</code>
       * @param value The bytes for stopId to set.
       * @return This builder for chaining.
       */
      public Builder setStopIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stopId_ = value;
        onChanged();
        return this;
      }

      private int stopSequence_ ;
      /**
       * <pre>
       * Order of stops for a particular trip. The values must increase along the
       * trip but do not need to be consecutive.
       * Required
       * </pre>
       *
       * <code>uint32 stop_sequence = 5;</code>
       * @return The stopSequence.
       */
      @java.lang.Override
      public int getStopSequence() {
        return stopSequence_;
      }
      /**
       * <pre>
       * Order of stops for a particular trip. The values must increase along the
       * trip but do not need to be consecutive.
       * Required
       * </pre>
       *
       * <code>uint32 stop_sequence = 5;</code>
       * @param value The stopSequence to set.
       * @return This builder for chaining.
       */
      public Builder setStopSequence(int value) {
        
        stopSequence_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Order of stops for a particular trip. The values must increase along the
       * trip but do not need to be consecutive.
       * Required
       * </pre>
       *
       * <code>uint32 stop_sequence = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopSequence() {
        
        stopSequence_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object stopHeadsign_ = "";
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * This field overrides the default trips.trip_headsign when the headsign
       * changes between stops. If the headsign is displayed for an entire trip,
       * trips.trip_headsign should be used instead.
       * A stop_headsign value specified for one stop_time does not apply to
       * subsequent stop_times in the same trip. If you want to override the
       * trip_headsign for multiple stop_times in the same trip, the stop_headsign
       * value must be repeated in each stop_time row.
       * </pre>
       *
       * <code>string stop_headsign = 6;</code>
       * @return The stopHeadsign.
       */
      public java.lang.String getStopHeadsign() {
        java.lang.Object ref = stopHeadsign_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stopHeadsign_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * This field overrides the default trips.trip_headsign when the headsign
       * changes between stops. If the headsign is displayed for an entire trip,
       * trips.trip_headsign should be used instead.
       * A stop_headsign value specified for one stop_time does not apply to
       * subsequent stop_times in the same trip. If you want to override the
       * trip_headsign for multiple stop_times in the same trip, the stop_headsign
       * value must be repeated in each stop_time row.
       * </pre>
       *
       * <code>string stop_headsign = 6;</code>
       * @return The bytes for stopHeadsign.
       */
      public com.google.protobuf.ByteString
          getStopHeadsignBytes() {
        java.lang.Object ref = stopHeadsign_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stopHeadsign_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * This field overrides the default trips.trip_headsign when the headsign
       * changes between stops. If the headsign is displayed for an entire trip,
       * trips.trip_headsign should be used instead.
       * A stop_headsign value specified for one stop_time does not apply to
       * subsequent stop_times in the same trip. If you want to override the
       * trip_headsign for multiple stop_times in the same trip, the stop_headsign
       * value must be repeated in each stop_time row.
       * </pre>
       *
       * <code>string stop_headsign = 6;</code>
       * @param value The stopHeadsign to set.
       * @return This builder for chaining.
       */
      public Builder setStopHeadsign(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stopHeadsign_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * This field overrides the default trips.trip_headsign when the headsign
       * changes between stops. If the headsign is displayed for an entire trip,
       * trips.trip_headsign should be used instead.
       * A stop_headsign value specified for one stop_time does not apply to
       * subsequent stop_times in the same trip. If you want to override the
       * trip_headsign for multiple stop_times in the same trip, the stop_headsign
       * value must be repeated in each stop_time row.
       * </pre>
       *
       * <code>string stop_headsign = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopHeadsign() {
        
        stopHeadsign_ = getDefaultInstance().getStopHeadsign();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text that appears on signage identifying the trip's destination to riders.
       * This field overrides the default trips.trip_headsign when the headsign
       * changes between stops. If the headsign is displayed for an entire trip,
       * trips.trip_headsign should be used instead.
       * A stop_headsign value specified for one stop_time does not apply to
       * subsequent stop_times in the same trip. If you want to override the
       * trip_headsign for multiple stop_times in the same trip, the stop_headsign
       * value must be repeated in each stop_time row.
       * </pre>
       *
       * <code>string stop_headsign = 6;</code>
       * @param value The bytes for stopHeadsign to set.
       * @return This builder for chaining.
       */
      public Builder setStopHeadsignBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stopHeadsign_ = value;
        onChanged();
        return this;
      }

      private int pickupType_ = 0;
      /**
       * <pre>
       * Indicates pickup method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
       * @return The enum numeric value on the wire for pickupType.
       */
      @java.lang.Override public int getPickupTypeValue() {
        return pickupType_;
      }
      /**
       * <pre>
       * Indicates pickup method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
       * @param value The enum numeric value on the wire for pickupType to set.
       * @return This builder for chaining.
       */
      public Builder setPickupTypeValue(int value) {
        
        pickupType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates pickup method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
       * @return The pickupType.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.StopTime.PickupType getPickupType() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.StopTime.PickupType result = transit_scheduled.GtfsSchedule.StopTime.PickupType.valueOf(pickupType_);
        return result == null ? transit_scheduled.GtfsSchedule.StopTime.PickupType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates pickup method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
       * @param value The pickupType to set.
       * @return This builder for chaining.
       */
      public Builder setPickupType(transit_scheduled.GtfsSchedule.StopTime.PickupType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        pickupType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates pickup method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearPickupType() {
        
        pickupType_ = 0;
        onChanged();
        return this;
      }

      private int dropOffType_ = 0;
      /**
       * <pre>
       * Indicates drop off method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
       * @return The enum numeric value on the wire for dropOffType.
       */
      @java.lang.Override public int getDropOffTypeValue() {
        return dropOffType_;
      }
      /**
       * <pre>
       * Indicates drop off method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
       * @param value The enum numeric value on the wire for dropOffType to set.
       * @return This builder for chaining.
       */
      public Builder setDropOffTypeValue(int value) {
        
        dropOffType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates drop off method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
       * @return The dropOffType.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.StopTime.DropOffType getDropOffType() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.StopTime.DropOffType result = transit_scheduled.GtfsSchedule.StopTime.DropOffType.valueOf(dropOffType_);
        return result == null ? transit_scheduled.GtfsSchedule.StopTime.DropOffType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates drop off method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
       * @param value The dropOffType to set.
       * @return This builder for chaining.
       */
      public Builder setDropOffType(transit_scheduled.GtfsSchedule.StopTime.DropOffType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        dropOffType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates drop off method.
       * </pre>
       *
       * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearDropOffType() {
        
        dropOffType_ = 0;
        onChanged();
        return this;
      }

      private int continuousPickup_ = 0;
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, from this stop_time
       * to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous pickup behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous pickup behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
       * @return The enum numeric value on the wire for continuousPickup.
       */
      @java.lang.Override public int getContinuousPickupValue() {
        return continuousPickup_;
      }
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, from this stop_time
       * to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous pickup behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous pickup behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
       * @param value The enum numeric value on the wire for continuousPickup to set.
       * @return This builder for chaining.
       */
      public Builder setContinuousPickupValue(int value) {
        
        continuousPickup_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, from this stop_time
       * to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous pickup behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous pickup behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
       * @return The continuousPickup.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.ContinuousPickup getContinuousPickup() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.ContinuousPickup result = transit_scheduled.GtfsSchedule.ContinuousPickup.valueOf(continuousPickup_);
        return result == null ? transit_scheduled.GtfsSchedule.ContinuousPickup.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, from this stop_time
       * to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous pickup behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous pickup behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
       * @param value The continuousPickup to set.
       * @return This builder for chaining.
       */
      public Builder setContinuousPickup(transit_scheduled.GtfsSchedule.ContinuousPickup value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        continuousPickup_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates that the rider can board the transit vehicle at any point along
       * the vehicle’s travel path as described by shapes.txt, from this stop_time
       * to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous pickup behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous pickup behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearContinuousPickup() {
        
        continuousPickup_ = 0;
        onChanged();
        return this;
      }

      private int continuousDropOff_ = 0;
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, from this
       * stop_time to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous drop-off behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous drop-off behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
       * @return The enum numeric value on the wire for continuousDropOff.
       */
      @java.lang.Override public int getContinuousDropOffValue() {
        return continuousDropOff_;
      }
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, from this
       * stop_time to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous drop-off behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous drop-off behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
       * @param value The enum numeric value on the wire for continuousDropOff to set.
       * @return This builder for chaining.
       */
      public Builder setContinuousDropOffValue(int value) {
        
        continuousDropOff_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, from this
       * stop_time to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous drop-off behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous drop-off behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
       * @return The continuousDropOff.
       */
      @java.lang.Override
      public transit_scheduled.GtfsSchedule.ContinuousDropOff getContinuousDropOff() {
        @SuppressWarnings("deprecation")
        transit_scheduled.GtfsSchedule.ContinuousDropOff result = transit_scheduled.GtfsSchedule.ContinuousDropOff.valueOf(continuousDropOff_);
        return result == null ? transit_scheduled.GtfsSchedule.ContinuousDropOff.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, from this
       * stop_time to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous drop-off behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous drop-off behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
       * @param value The continuousDropOff to set.
       * @return This builder for chaining.
       */
      public Builder setContinuousDropOff(transit_scheduled.GtfsSchedule.ContinuousDropOff value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        continuousDropOff_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates that the rider can alight from the transit vehicle at any point
       * along the vehicle’s travel path as described by shapes.txt, from this
       * stop_time to the next stop_time in the trip’s stop_sequence.
       * If this field is populated, it overrides any continuous drop-off behavior
       * defined in routes.txt. If this field is empty, the stop_time inherits any
       * continuous drop-off behavior defined in routes.txt.
       * </pre>
       *
       * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearContinuousDropOff() {
        
        continuousDropOff_ = 0;
        onChanged();
        return this;
      }

      private float shapeDistTraveled_ ;
      /**
       * <pre>
       * Actual distance traveled along the associated shape, from the first stop to
       * the stop specified in this record. This field specifies how much of the
       * shape to draw between any two stops during a trip. Must be in the same
       * units used in shapes.txt. Values used for shape_dist_traveled must increase
       * along with stop_sequence; they must not be used to show reverse travel
       * along a route.
       * Recommended for routes that have looping or inlining (the vehicle crosses
       * or travels over the same portion of alignment in one trip). See
       * shapes.shape_dist_traveled.
       * </pre>
       *
       * <code>float shape_dist_traveled = 11;</code>
       * @return The shapeDistTraveled.
       */
      @java.lang.Override
      public float getShapeDistTraveled() {
        return shapeDistTraveled_;
      }
      /**
       * <pre>
       * Actual distance traveled along the associated shape, from the first stop to
       * the stop specified in this record. This field specifies how much of the
       * shape to draw between any two stops during a trip. Must be in the same
       * units used in shapes.txt. Values used for shape_dist_traveled must increase
       * along with stop_sequence; they must not be used to show reverse travel
       * along a route.
       * Recommended for routes that have looping or inlining (the vehicle crosses
       * or travels over the same portion of alignment in one trip). See
       * shapes.shape_dist_traveled.
       * </pre>
       *
       * <code>float shape_dist_traveled = 11;</code>
       * @param value The shapeDistTraveled to set.
       * @return This builder for chaining.
       */
      public Builder setShapeDistTraveled(float value) {
        
        shapeDistTraveled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Actual distance traveled along the associated shape, from the first stop to
       * the stop specified in this record. This field specifies how much of the
       * shape to draw between any two stops during a trip. Must be in the same
       * units used in shapes.txt. Values used for shape_dist_traveled must increase
       * along with stop_sequence; they must not be used to show reverse travel
       * along a route.
       * Recommended for routes that have looping or inlining (the vehicle crosses
       * or travels over the same portion of alignment in one trip). See
       * shapes.shape_dist_traveled.
       * </pre>
       *
       * <code>float shape_dist_traveled = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearShapeDistTraveled() {
        
        shapeDistTraveled_ = 0F;
        onChanged();
        return this;
      }

      private int timepoint_ ;
      /**
       * <pre>
       * Indicates if arrival and departure times for a stop are strictly adhered to
       * by the vehicle or if they are instead approximate and/or interpolated
       * times. This field allows a GTFS producer to provide interpolated
       * stop-times, while indicating that the times are approximate.
       * </pre>
       *
       * <code>uint32 timepoint = 12;</code>
       * @return The timepoint.
       */
      @java.lang.Override
      public int getTimepoint() {
        return timepoint_;
      }
      /**
       * <pre>
       * Indicates if arrival and departure times for a stop are strictly adhered to
       * by the vehicle or if they are instead approximate and/or interpolated
       * times. This field allows a GTFS producer to provide interpolated
       * stop-times, while indicating that the times are approximate.
       * </pre>
       *
       * <code>uint32 timepoint = 12;</code>
       * @param value The timepoint to set.
       * @return This builder for chaining.
       */
      public Builder setTimepoint(int value) {
        
        timepoint_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates if arrival and departure times for a stop are strictly adhered to
       * by the vehicle or if they are instead approximate and/or interpolated
       * times. This field allows a GTFS producer to provide interpolated
       * stop-times, while indicating that the times are approximate.
       * </pre>
       *
       * <code>uint32 timepoint = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimepoint() {
        
        timepoint_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:transit_scheduled.StopTime)
    }

    // @@protoc_insertion_point(class_scope:transit_scheduled.StopTime)
    private static final transit_scheduled.GtfsSchedule.StopTime DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new transit_scheduled.GtfsSchedule.StopTime();
    }

    public static transit_scheduled.GtfsSchedule.StopTime getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StopTime>
        PARSER = new com.google.protobuf.AbstractParser<StopTime>() {
      @java.lang.Override
      public StopTime parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StopTime> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StopTime> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public transit_scheduled.GtfsSchedule.StopTime getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_scheduled_Agency_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_transit_scheduled_Agency_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_scheduled_Stop_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_transit_scheduled_Stop_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_scheduled_Route_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_transit_scheduled_Route_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_scheduled_Trip_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_transit_scheduled_Trip_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_transit_scheduled_StopTime_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_transit_scheduled_StopTime_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\035protos/v1/gtfs-schedule.proto\022\021transit" +
      "_scheduled\"\267\001\n\006Agency\022\021\n\tagency_id\030\001 \001(\t" +
      "\022\023\n\013agency_name\030\002 \001(\t\022\022\n\nagency_url\030\003 \001(" +
      "\t\022\027\n\017agency_timezone\030\004 \001(\t\022\023\n\013agency_lan" +
      "g\030\005 \001(\t\022\024\n\014agency_phone\030\006 \001(\t\022\027\n\017agency_" +
      "fare_url\030\007 \001(\t\022\024\n\014agency_email\030\010 \001(\t\"\261\005\n" +
      "\004Stop\022\017\n\007stop_id\030\001 \001(\t\022\021\n\tstop_code\030\002 \001(" +
      "\t\022\021\n\tstop_name\030\003 \001(\t\022\025\n\rtts_stop_name\030\004 " +
      "\001(\t\022\021\n\tstop_desc\030\005 \001(\t\022\020\n\010stop_lat\030\006 \001(\001" +
      "\022\020\n\010stop_lon\030\007 \001(\001\022\017\n\007zone_id\030\010 \001(\t\022\020\n\010s" +
      "top_url\030\t \001(\t\022;\n\rlocation_type\030\n \001(\0162$.t" +
      "ransit_scheduled.Stop.LocationType\022\026\n\016pa" +
      "rent_station\030\013 \001(\t\022\025\n\rstop_timezone\030\014 \001(" +
      "\t\022G\n\023wheelchair_boarding\030\r \001(\0162*.transit" +
      "_scheduled.Stop.WheelchairBoarding\022\020\n\010le" +
      "vel_id\030\016 \001(\t\022\025\n\rplatform_code\030\017 \001(\t\"\243\001\n\014" +
      "LocationType\022\026\n\022LOCATION_TYPE_STOP\020\000\022\031\n\025" +
      "LOCATION_TYPE_STATION\020\001\022\037\n\033LOCATION_TYPE" +
      "_ENTRANCE_EXIT\020\002\022\036\n\032LOCATION_TYPE_GENERI" +
      "C_NODE\020\003\022\037\n\033LOCATION_TYPE_BOARDING_AREA\020" +
      "\004\"}\n\022WheelchairBoarding\022\037\n\033WHEELCHAIR_BO" +
      "ARDING_NO_INFO\020\000\022 \n\034WHEELCHAIR_BOARDING_" +
      "POSSIBLE\020\001\022$\n WHEELCHAIR_BOARDING_NOT_PO" +
      "SSIBLE\020\002\"\312\005\n\005Route\022\020\n\010route_id\030\001 \001(\t\022\021\n\t" +
      "agency_id\030\002 \001(\t\022\030\n\020route_short_name\030\003 \001(" +
      "\t\022\027\n\017route_long_name\030\004 \001(\t\022\022\n\nroute_desc" +
      "\030\005 \001(\t\0226\n\nroute_type\030\006 \001(\0162\".transit_sch" +
      "eduled.Route.RouteType\022\021\n\troute_url\030\007 \001(" +
      "\t\022\023\n\013route_color\030\010 \001(\t\022\030\n\020route_text_col" +
      "or\030\t \001(\t\022\030\n\020route_sort_order\030\n \001(\r\022>\n\021co" +
      "ntinuous_pickup\030\013 \001(\0162#.transit_schedule" +
      "d.ContinuousPickup\022A\n\023continuous_drop_of" +
      "f\030\014 \001(\0162$.transit_scheduled.ContinuousDr" +
      "opOff\022\022\n\nnetwork_id\030\r \001(\t\"\251\002\n\tRouteType\022" +
      "\'\n#ROUTE_TYPE_TRAM_STREETCAR_LIGHTRAIL\020\000" +
      "\022\033\n\027ROUTE_TYPE_SUBWAY_METRO\020\001\022\023\n\017ROUTE_T" +
      "YPE_RAIL\020\002\022\022\n\016ROUTE_TYPE_BUS\020\003\022\024\n\020ROUTE_" +
      "TYPE_FERRY\020\004\022\031\n\025ROUTE_TYPE_CABLE_TRAM\020\005\022" +
      ".\n*ROUTE_TYPE_AERIAL_LIFT_SUSPENDED_CABL" +
      "E_CAR\020\006\022\030\n\024ROUTE_TYPE_FUNICULAR\020\007\022\031\n\025ROU" +
      "TE_TYPE_TROLLEYBUS\020\013\022\027\n\023ROUTE_TYPE_MONOR" +
      "AIL\020\014\"\233\005\n\004Trip\022\020\n\010route_id\030\001 \001(\t\022\022\n\nserv" +
      "ice_id\030\002 \001(\t\022\017\n\007trip_id\030\003 \001(\t\022\025\n\rtrip_he" +
      "adsign\030\004 \001(\t\022\027\n\017trip_short_name\030\005 \001(\t\0227\n" +
      "\014direction_id\030\006 \001(\0162!.transit_scheduled." +
      "Trip.Direction\022\020\n\010block_id\030\007 \001(\t\022\020\n\010shap" +
      "e_id\030\010 \001(\t\022N\n\025wheelchair_accessible\030\t \001(" +
      "\0162/.transit_scheduled.Trip.WheelchairAcc" +
      "essibility\022<\n\rbikes_allowed\030\n \001(\0162%.tran" +
      "sit_scheduled.Trip.BikeAllowance\"@\n\tDire" +
      "ction\022\033\n\027DIRECTION_ONE_DIRECTION\020\000\022\026\n\022DI" +
      "RECTION_OPPOSITE\020\001\"\225\001\n\027WheelchairAccessi" +
      "bility\022$\n WHEELCHAIR_ACCESSIBILITY_NO_IN" +
      "FO\020\000\022\'\n#WHEELCHAIR_ACCESSIBILITY_ACCESSI" +
      "BLE\020\001\022+\n\'WHEELCHAIR_ACCESSIBILITY_NOT_AC" +
      "CESSIBLE\020\002\"g\n\rBikeAllowance\022\032\n\026BIKE_ALLO" +
      "WANCE_NO_INFO\020\000\022\032\n\026BIKE_ALLOWANCE_ALLOWE" +
      "D\020\001\022\036\n\032BIKE_ALLOWANCE_NOT_ALLOWED\020\002\"\310\006\n\010" +
      "StopTime\022\017\n\007trip_id\030\001 \001(\t\022\024\n\014arrival_tim" +
      "e\030\002 \001(\t\022\026\n\016departure_time\030\003 \001(\t\022\017\n\007stop_" +
      "id\030\004 \001(\t\022\025\n\rstop_sequence\030\005 \001(\r\022\025\n\rstop_" +
      "headsign\030\006 \001(\t\022;\n\013pickup_type\030\007 \001(\0162&.tr" +
      "ansit_scheduled.StopTime.PickupType\022>\n\rd" +
      "rop_off_type\030\010 \001(\0162\'.transit_scheduled.S" +
      "topTime.DropOffType\022>\n\021continuous_pickup" +
      "\030\t \001(\0162#.transit_scheduled.ContinuousPic" +
      "kup\022A\n\023continuous_drop_off\030\n \001(\0162$.trans" +
      "it_scheduled.ContinuousDropOff\022\033\n\023shape_" +
      "dist_traveled\030\013 \001(\002\022\021\n\ttimepoint\030\014 \001(\r\"\241" +
      "\001\n\nPickupType\022#\n\037PICKUP_TYPE_REGULARLY_S" +
      "CHEDULED\020\000\022\036\n\032PICKUP_TYPE_NONE_AVAILABLE" +
      "\020\001\022!\n\035PICKUP_TYPE_MUST_PHONE_AGENCY\020\002\022+\n" +
      "\'PICKUP_TYPE_MUST_COORDINATE_WITH_DRIVER" +
      "\020\003\"\252\001\n\013DropOffType\022%\n!DROP_OFF_TYPE_REGU" +
      "LARLY_SCHEDULED\020\000\022 \n\034DROP_OFF_TYPE_NONE_" +
      "AVAILABLE\020\001\022#\n\037DROP_OFF_TYPE_MUST_PHONE_" +
      "AGENCY\020\002\022-\n)DROP_OFF_TYPE_MUST_COORDINAT" +
      "E_WITH_DRIVER\020\003\"=\n\tTimePoint\022\032\n\026TIME_POI" +
      "NT_APPROXIMATE\020\000\022\024\n\020TIME_POINT_EXACT\020\001*\274" +
      "\001\n\020ContinuousPickup\022\036\n\032CONTINUOUS_PICKUP" +
      "_STOPPING\020\000\022,\n(CONTINUOUS_PICKUP_NO_CONT" +
      "INUOUS_STOPPING\020\001\022\'\n#CONTINUOUS_PICKUP_M" +
      "UST_PHONE_AGENCY\020\002\0221\n-CONTINUOUS_PICKUP_" +
      "MUST_COORDINATE_WITH_DRIVER\020\003*\320\001\n\021Contin" +
      "uousDropOff\022+\n\'CONTINUOUS_DROP_OFF_CONTI" +
      "NUOUS_STOPPING\020\000\022.\n*CONTINUOUS_DROP_OFF_" +
      "NO_CONTINUOUS_STOPPING\020\001\022)\n%CONTINUOUS_D" +
      "ROP_OFF_MUST_PHONE_AGENCY\020\002\0223\n/CONTINUOU" +
      "S_DROP_OFF_MUST_COORDINATE_WITH_DRIVER\020\003" +
      "b\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_transit_scheduled_Agency_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_transit_scheduled_Agency_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_transit_scheduled_Agency_descriptor,
        new java.lang.String[] { "AgencyId", "AgencyName", "AgencyUrl", "AgencyTimezone", "AgencyLang", "AgencyPhone", "AgencyFareUrl", "AgencyEmail", });
    internal_static_transit_scheduled_Stop_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_transit_scheduled_Stop_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_transit_scheduled_Stop_descriptor,
        new java.lang.String[] { "StopId", "StopCode", "StopName", "TtsStopName", "StopDesc", "StopLat", "StopLon", "ZoneId", "StopUrl", "LocationType", "ParentStation", "StopTimezone", "WheelchairBoarding", "LevelId", "PlatformCode", });
    internal_static_transit_scheduled_Route_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_transit_scheduled_Route_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_transit_scheduled_Route_descriptor,
        new java.lang.String[] { "RouteId", "AgencyId", "RouteShortName", "RouteLongName", "RouteDesc", "RouteType", "RouteUrl", "RouteColor", "RouteTextColor", "RouteSortOrder", "ContinuousPickup", "ContinuousDropOff", "NetworkId", });
    internal_static_transit_scheduled_Trip_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_transit_scheduled_Trip_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_transit_scheduled_Trip_descriptor,
        new java.lang.String[] { "RouteId", "ServiceId", "TripId", "TripHeadsign", "TripShortName", "DirectionId", "BlockId", "ShapeId", "WheelchairAccessible", "BikesAllowed", });
    internal_static_transit_scheduled_StopTime_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_transit_scheduled_StopTime_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_transit_scheduled_StopTime_descriptor,
        new java.lang.String[] { "TripId", "ArrivalTime", "DepartureTime", "StopId", "StopSequence", "StopHeadsign", "PickupType", "DropOffType", "ContinuousPickup", "ContinuousDropOff", "ShapeDistTraveled", "Timepoint", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
