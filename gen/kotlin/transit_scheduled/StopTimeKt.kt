//Generated by the protocol buffer compiler. DO NOT EDIT!
// source: protos/v1/gtfs-schedule.proto

package transit_scheduled;

@kotlin.jvm.JvmName("-initializestopTime")
public inline fun stopTime(block: transit_scheduled.StopTimeKt.Dsl.() -> kotlin.Unit): transit_scheduled.GtfsSchedule.StopTime =
  transit_scheduled.StopTimeKt.Dsl._create(transit_scheduled.GtfsSchedule.StopTime.newBuilder()).apply { block() }._build()
public object StopTimeKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: transit_scheduled.GtfsSchedule.StopTime.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: transit_scheduled.GtfsSchedule.StopTime.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): transit_scheduled.GtfsSchedule.StopTime = _builder.build()

    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 1;</code>
     */
    public var tripId: kotlin.String
      @JvmName("getTripId")
      get() = _builder.getTripId()
      @JvmName("setTripId")
      set(value) {
        _builder.setTripId(value)
      }
    /**
     * <pre>
     * Identifies a trip.
     * Required
     * </pre>
     *
     * <code>string trip_id = 1;</code>
     */
    public fun clearTripId() {
      _builder.clearTripId()
    }

    /**
     * <pre>
     * Arrival time at the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for the first and last stop in a trip (defined by
     * stop_times.stop_sequence).
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string arrival_time = 2;</code>
     */
    public var arrivalTime: kotlin.String
      @JvmName("getArrivalTime")
      get() = _builder.getArrivalTime()
      @JvmName("setArrivalTime")
      set(value) {
        _builder.setArrivalTime(value)
      }
    /**
     * <pre>
     * Arrival time at the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for the first and last stop in a trip (defined by
     * stop_times.stop_sequence).
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string arrival_time = 2;</code>
     */
    public fun clearArrivalTime() {
      _builder.clearArrivalTime()
    }

    /**
     * <pre>
     * Departure time from the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string departure_time = 3;</code>
     */
    public var departureTime: kotlin.String
      @JvmName("getDepartureTime")
      get() = _builder.getDepartureTime()
      @JvmName("setDepartureTime")
      set(value) {
        _builder.setDepartureTime(value)
      }
    /**
     * <pre>
     * Departure time from the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for timepoint=1.
     * - Optional otherwise.
     * </pre>
     *
     * <code>string departure_time = 3;</code>
     */
    public fun clearDepartureTime() {
      _builder.clearDepartureTime()
    }

    /**
     * <pre>
     * Identifies the serviced stop. All stops serviced during a trip must have a
     * record in stop_times.txt. Referenced locations must be stops/platforms,
     * i.e. their stops.location_type value must be 0 or empty. A stop may be
     * serviced multiple times in the same trip, and multiple trips and routes may
     * service the same stop.
     * Required
     * </pre>
     *
     * <code>string stop_id = 4;</code>
     */
    public var stopId: kotlin.String
      @JvmName("getStopId")
      get() = _builder.getStopId()
      @JvmName("setStopId")
      set(value) {
        _builder.setStopId(value)
      }
    /**
     * <pre>
     * Identifies the serviced stop. All stops serviced during a trip must have a
     * record in stop_times.txt. Referenced locations must be stops/platforms,
     * i.e. their stops.location_type value must be 0 or empty. A stop may be
     * serviced multiple times in the same trip, and multiple trips and routes may
     * service the same stop.
     * Required
     * </pre>
     *
     * <code>string stop_id = 4;</code>
     */
    public fun clearStopId() {
      _builder.clearStopId()
    }

    /**
     * <pre>
     * Order of stops for a particular trip. The values must increase along the
     * trip but do not need to be consecutive.
     * Required
     * </pre>
     *
     * <code>uint32 stop_sequence = 5;</code>
     */
    public var stopSequence: kotlin.Int
      @JvmName("getStopSequence")
      get() = _builder.getStopSequence()
      @JvmName("setStopSequence")
      set(value) {
        _builder.setStopSequence(value)
      }
    /**
     * <pre>
     * Order of stops for a particular trip. The values must increase along the
     * trip but do not need to be consecutive.
     * Required
     * </pre>
     *
     * <code>uint32 stop_sequence = 5;</code>
     */
    public fun clearStopSequence() {
      _builder.clearStopSequence()
    }

    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * This field overrides the default trips.trip_headsign when the headsign
     * changes between stops. If the headsign is displayed for an entire trip,
     * trips.trip_headsign should be used instead.
     * A stop_headsign value specified for one stop_time does not apply to
     * subsequent stop_times in the same trip. If you want to override the
     * trip_headsign for multiple stop_times in the same trip, the stop_headsign
     * value must be repeated in each stop_time row.
     * </pre>
     *
     * <code>string stop_headsign = 6;</code>
     */
    public var stopHeadsign: kotlin.String
      @JvmName("getStopHeadsign")
      get() = _builder.getStopHeadsign()
      @JvmName("setStopHeadsign")
      set(value) {
        _builder.setStopHeadsign(value)
      }
    /**
     * <pre>
     * Text that appears on signage identifying the trip's destination to riders.
     * This field overrides the default trips.trip_headsign when the headsign
     * changes between stops. If the headsign is displayed for an entire trip,
     * trips.trip_headsign should be used instead.
     * A stop_headsign value specified for one stop_time does not apply to
     * subsequent stop_times in the same trip. If you want to override the
     * trip_headsign for multiple stop_times in the same trip, the stop_headsign
     * value must be repeated in each stop_time row.
     * </pre>
     *
     * <code>string stop_headsign = 6;</code>
     */
    public fun clearStopHeadsign() {
      _builder.clearStopHeadsign()
    }

    /**
     * <pre>
     * Indicates pickup method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
     */
    public var pickupType: transit_scheduled.GtfsSchedule.StopTime.PickupType
      @JvmName("getPickupType")
      get() = _builder.getPickupType()
      @JvmName("setPickupType")
      set(value) {
        _builder.setPickupType(value)
      }
    /**
     * <pre>
     * Indicates pickup method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
     */
    public fun clearPickupType() {
      _builder.clearPickupType()
    }

    /**
     * <pre>
     * Indicates drop off method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
     */
    public var dropOffType: transit_scheduled.GtfsSchedule.StopTime.DropOffType
      @JvmName("getDropOffType")
      get() = _builder.getDropOffType()
      @JvmName("setDropOffType")
      set(value) {
        _builder.setDropOffType(value)
      }
    /**
     * <pre>
     * Indicates drop off method.
     * </pre>
     *
     * <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
     */
    public fun clearDropOffType() {
      _builder.clearDropOffType()
    }

    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, from this stop_time
     * to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous pickup behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous pickup behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
     */
    public var continuousPickup: transit_scheduled.GtfsSchedule.ContinuousPickup
      @JvmName("getContinuousPickup")
      get() = _builder.getContinuousPickup()
      @JvmName("setContinuousPickup")
      set(value) {
        _builder.setContinuousPickup(value)
      }
    /**
     * <pre>
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, from this stop_time
     * to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous pickup behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous pickup behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
     */
    public fun clearContinuousPickup() {
      _builder.clearContinuousPickup()
    }

    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, from this
     * stop_time to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous drop-off behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous drop-off behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
     */
    public var continuousDropOff: transit_scheduled.GtfsSchedule.ContinuousDropOff
      @JvmName("getContinuousDropOff")
      get() = _builder.getContinuousDropOff()
      @JvmName("setContinuousDropOff")
      set(value) {
        _builder.setContinuousDropOff(value)
      }
    /**
     * <pre>
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, from this
     * stop_time to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous drop-off behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous drop-off behavior defined in routes.txt.
     * </pre>
     *
     * <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
     */
    public fun clearContinuousDropOff() {
      _builder.clearContinuousDropOff()
    }

    /**
     * <pre>
     * Actual distance traveled along the associated shape, from the first stop to
     * the stop specified in this record. This field specifies how much of the
     * shape to draw between any two stops during a trip. Must be in the same
     * units used in shapes.txt. Values used for shape_dist_traveled must increase
     * along with stop_sequence; they must not be used to show reverse travel
     * along a route.
     * Recommended for routes that have looping or inlining (the vehicle crosses
     * or travels over the same portion of alignment in one trip). See
     * shapes.shape_dist_traveled.
     * </pre>
     *
     * <code>float shape_dist_traveled = 11;</code>
     */
    public var shapeDistTraveled: kotlin.Float
      @JvmName("getShapeDistTraveled")
      get() = _builder.getShapeDistTraveled()
      @JvmName("setShapeDistTraveled")
      set(value) {
        _builder.setShapeDistTraveled(value)
      }
    /**
     * <pre>
     * Actual distance traveled along the associated shape, from the first stop to
     * the stop specified in this record. This field specifies how much of the
     * shape to draw between any two stops during a trip. Must be in the same
     * units used in shapes.txt. Values used for shape_dist_traveled must increase
     * along with stop_sequence; they must not be used to show reverse travel
     * along a route.
     * Recommended for routes that have looping or inlining (the vehicle crosses
     * or travels over the same portion of alignment in one trip). See
     * shapes.shape_dist_traveled.
     * </pre>
     *
     * <code>float shape_dist_traveled = 11;</code>
     */
    public fun clearShapeDistTraveled() {
      _builder.clearShapeDistTraveled()
    }

    /**
     * <pre>
     * Indicates if arrival and departure times for a stop are strictly adhered to
     * by the vehicle or if they are instead approximate and/or interpolated
     * times. This field allows a GTFS producer to provide interpolated
     * stop-times, while indicating that the times are approximate.
     * </pre>
     *
     * <code>uint32 timepoint = 12;</code>
     */
    public var timepoint: kotlin.Int
      @JvmName("getTimepoint")
      get() = _builder.getTimepoint()
      @JvmName("setTimepoint")
      set(value) {
        _builder.setTimepoint(value)
      }
    /**
     * <pre>
     * Indicates if arrival and departure times for a stop are strictly adhered to
     * by the vehicle or if they are instead approximate and/or interpolated
     * times. This field allows a GTFS producer to provide interpolated
     * stop-times, while indicating that the times are approximate.
     * </pre>
     *
     * <code>uint32 timepoint = 12;</code>
     */
    public fun clearTimepoint() {
      _builder.clearTimepoint()
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun transit_scheduled.GtfsSchedule.StopTime.copy(block: transit_scheduled.StopTimeKt.Dsl.() -> kotlin.Unit): transit_scheduled.GtfsSchedule.StopTime =
  transit_scheduled.StopTimeKt.Dsl._create(this.toBuilder()).apply { block() }._build()

