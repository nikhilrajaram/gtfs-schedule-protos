// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/v1/gtfs-schedule.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30004
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30004 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum ContinuousPickup

/**
 * Indicates that the rider can board the transit vehicle at any point along the
 * vehicle’s travel path as described by shapes.txt.
 * Valid options are:
 *   0 - Continuous stopping pickup.
 *   1 or empty - No continuous stopping pickup.
 *   2 - Must phone agency to arrange continuous stopping pickup.
 *   3 - Must coordinate with driver to arrange continuous stopping pickup.
 **/
typedef GPB_ENUM(ContinuousPickup) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  ContinuousPickup_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  ContinuousPickup_ContinuousPickupStopping = 0,
  ContinuousPickup_ContinuousPickupNoContinuousStopping = 1,
  ContinuousPickup_ContinuousPickupMustPhoneAgency = 2,
  ContinuousPickup_ContinuousPickupMustCoordinateWithDriver = 3,
};

GPBEnumDescriptor *ContinuousPickup_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL ContinuousPickup_IsValidValue(int32_t value);

#pragma mark - Enum ContinuousDropOff

/**
 * Indicates that the rider can alight from the transit vehicle at any point
 * along the vehicle’s travel path as described by shapes.txt, on every trip
 * of the route.
 **/
typedef GPB_ENUM(ContinuousDropOff) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  ContinuousDropOff_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  ContinuousDropOff_ContinuousDropOffContinuousStopping = 0,
  ContinuousDropOff_ContinuousDropOffNoContinuousStopping = 1,
  ContinuousDropOff_ContinuousDropOffMustPhoneAgency = 2,
  ContinuousDropOff_ContinuousDropOffMustCoordinateWithDriver = 3,
};

GPBEnumDescriptor *ContinuousDropOff_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL ContinuousDropOff_IsValidValue(int32_t value);

#pragma mark - Enum Stop_LocationType

/**
 * Location type. Valid options are:
 *   0 (or blank) - Stop (or Platform). A location where passengers board or
 *   disembark from a transit vehicle. Is called a platform when defined
 *   within a parent_station.
 *   1 - Station. A physical structure or area that contains one or more
 *   platform.
 *   2 - Entrance/Exit. A location where passengers can enter or exit a
 *   station from the street. If an entrance/exit belongs to multiple
 *   stations, it may be linked by pathways to both, but the data provider
 *   must pick one of them as parent.
 *   3 - Generic Node. A location within a station, not matching any other
 *   location_type, that may be used to link together pathways define in
 *   pathways.txt.
 *   4 - Boarding Area. A specific location on a platform, where passengers
 *   can board and/or alight vehicles.
 **/
typedef GPB_ENUM(Stop_LocationType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Stop_LocationType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Stop_LocationType_LocationTypeStop = 0,
  Stop_LocationType_LocationTypeStation = 1,
  Stop_LocationType_LocationTypeEntranceExit = 2,
  Stop_LocationType_LocationTypeGenericNode = 3,
  Stop_LocationType_LocationTypeBoardingArea = 4,
};

GPBEnumDescriptor *Stop_LocationType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Stop_LocationType_IsValidValue(int32_t value);

#pragma mark - Enum Stop_WheelchairBoarding

/**
 * Indicates whether wheelchair boardings are possible from the location.
 * Valid options are:
 *   For parentless stops:
 *     0 or empty - No accessibility information for the stop.
 *     1 - Some vehicles at this stop can be boarded by a rider in a
 *     wheelchair.
 *     2 - Wheelchair boarding is not possible at this stop.
 *   For child stops:
 *     0 or empty - Stop will inherit its wheelchair_boarding behavior from
 *     the parent station, if specified in the parent.
 *     1 - There exists some accessible path from outside the station to the
 *     specific stop/platform.
 *     2 - There exists no accessible path from outside the station to the
 *     specific stop/platform.
 *   For station entrances/exits:
 *     0 or empty - Station entrance will inherit its wheelchair_boarding
 *     behavior from the parent station, if specified for the parent.
 *     1 - Station entrance is wheelchair accessible.
 *     2 - No accessible path from station entrance to stops/platforms.
 **/
typedef GPB_ENUM(Stop_WheelchairBoarding) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Stop_WheelchairBoarding_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Stop_WheelchairBoarding_WheelchairBoardingNoInfo = 0,
  Stop_WheelchairBoarding_WheelchairBoardingPossible = 1,
  Stop_WheelchairBoarding_WheelchairBoardingNotPossible = 2,
};

GPBEnumDescriptor *Stop_WheelchairBoarding_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Stop_WheelchairBoarding_IsValidValue(int32_t value);

#pragma mark - Enum Route_RouteType

/**
 * Indicates the type of transportation used on a route. Valid options are:
 *   0 - Tram, Streetcar, Light rail. Any light rail or street level system
 *   within a metropolitan area.
 *   1 - Subway, Metro. Any underground rail system within a metropolitan
 *   area.
 *   2 - Rail. Used for intercity or long-distance travel.
 *   3 - Bus. Used for short- and long-distance bus routes.
 *   4 - Ferry. Used for short- and long-distance boat service.
 *   5 - Cable tram. Used for street-level rail cars where the cable runs
 *   beneath the vehicle (e.g., cable car in San Francisco).
 *   6 - Aerial lift, suspended cable car (e.g., gondola lift, aerial
 *   tramway). Cable transport where cabins, cars, gondolas or open chairs are
 *   suspended by means of one or more cables.
 *   7 - Funicular. Any rail system designed for steep inclines.
 *   11 - Trolleybus. Electric buses that draw power from overhead wires using
 *   poles.
 *   12 - Monorail. Railway in which the track consists of a single rail or a
 *   beam.
 **/
typedef GPB_ENUM(Route_RouteType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Route_RouteType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Route_RouteType_RouteTypeTramStreetcarLightrail = 0,
  Route_RouteType_RouteTypeSubwayMetro = 1,
  Route_RouteType_RouteTypeRail = 2,
  Route_RouteType_RouteTypeBus = 3,
  Route_RouteType_RouteTypeFerry = 4,
  Route_RouteType_RouteTypeCableTram = 5,
  Route_RouteType_RouteTypeAerialLiftSuspendedCableCar = 6,
  Route_RouteType_RouteTypeFunicular = 7,
  Route_RouteType_RouteTypeTrolleybus = 11,
  Route_RouteType_RouteTypeMonorail = 12,
};

GPBEnumDescriptor *Route_RouteType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Route_RouteType_IsValidValue(int32_t value);

#pragma mark - Enum Trip_Direction

/**
 * Indicates the direction of travel for a trip. This field should not be used
 * in routing; it provides a way to separate trips by direction when
 * publishing time tables. Valid options are:
 *   0 - Travel in one direction (e.g. outbound travel).
 *   1 - Travel in the opposite direction (e.g. inbound travel).
 **/
typedef GPB_ENUM(Trip_Direction) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Trip_Direction_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Trip_Direction_DirectionOneDirection = 0,
  Trip_Direction_DirectionOpposite = 1,
};

GPBEnumDescriptor *Trip_Direction_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Trip_Direction_IsValidValue(int32_t value);

#pragma mark - Enum Trip_WheelchairAccessibility

/**
 * Indicates wheelchair accessibility. Valid options are:
 *   0 or empty - No accessibility information for the trip.
 *   1 - Vehicle being used on this particular trip can accommodate at least
 *   one rider in a wheelchair.
 *   2 - No riders in wheelchairs can be accommodated on this trip.
 **/
typedef GPB_ENUM(Trip_WheelchairAccessibility) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Trip_WheelchairAccessibility_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Trip_WheelchairAccessibility_WheelchairAccessibilityNoInfo = 0,
  Trip_WheelchairAccessibility_WheelchairAccessibilityAccessible = 1,
  Trip_WheelchairAccessibility_WheelchairAccessibilityNotAccessible = 2,
};

GPBEnumDescriptor *Trip_WheelchairAccessibility_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Trip_WheelchairAccessibility_IsValidValue(int32_t value);

#pragma mark - Enum Trip_BikeAllowance

/**
 * Indicates whether bikes are allowed. Valid options are:
 *   0 or empty - No bike information for the trip.
 *   1 - Vehicle being used on this particular trip can accommodate at least
 *   one bicycle.
 *   2 - No bicycles are allowed on this trip.
 **/
typedef GPB_ENUM(Trip_BikeAllowance) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Trip_BikeAllowance_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  Trip_BikeAllowance_BikeAllowanceNoInfo = 0,
  Trip_BikeAllowance_BikeAllowanceAllowed = 1,
  Trip_BikeAllowance_BikeAllowanceNotAllowed = 2,
};

GPBEnumDescriptor *Trip_BikeAllowance_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Trip_BikeAllowance_IsValidValue(int32_t value);

#pragma mark - Enum StopTime_PickupType

/**
 * Indicates pickup method. Valid options are:
 *   0 or empty - Regularly scheduled pickup.
 *   1 - No pickup available.
 *   2 - Must phone agency to arrange pickup.
 *   3 - Must coordinate with driver to arrange pickup.
 **/
typedef GPB_ENUM(StopTime_PickupType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  StopTime_PickupType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  StopTime_PickupType_PickupTypeRegularlyScheduled = 0,
  StopTime_PickupType_PickupTypeNoneAvailable = 1,
  StopTime_PickupType_PickupTypeMustPhoneAgency = 2,
  StopTime_PickupType_PickupTypeMustCoordinateWithDriver = 3,
};

GPBEnumDescriptor *StopTime_PickupType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL StopTime_PickupType_IsValidValue(int32_t value);

#pragma mark - Enum StopTime_DropOffType

/**
 * Indicates drop off method. Valid options are:
 *   0 or empty - Regularly scheduled drop off.
 *   1 - No drop off available.
 *   2 - Must phone agency to arrange drop off.
 *   3 - Must coordinate with driver to arrange drop off.
 **/
typedef GPB_ENUM(StopTime_DropOffType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  StopTime_DropOffType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  StopTime_DropOffType_DropOffTypeRegularlyScheduled = 0,
  StopTime_DropOffType_DropOffTypeNoneAvailable = 1,
  StopTime_DropOffType_DropOffTypeMustPhoneAgency = 2,
  StopTime_DropOffType_DropOffTypeMustCoordinateWithDriver = 3,
};

GPBEnumDescriptor *StopTime_DropOffType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL StopTime_DropOffType_IsValidValue(int32_t value);

#pragma mark - Enum StopTime_TimePoint

/**
 * Indicates if arrival and departure times for a stop are strictly adhered to
 * by the vehicle or if they are instead approximate and/or interpolated
 * times. This field allows a GTFS producer to provide interpolated
 * stop-times, while indicating that the times are approximate.
 * Valid options are:
 *   0 - Times are considered approximate.
 *   1 or empty - Times are considered exact.
 **/
typedef GPB_ENUM(StopTime_TimePoint) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  StopTime_TimePoint_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  StopTime_TimePoint_TimePointApproximate = 0,
  StopTime_TimePoint_TimePointExact = 1,
};

GPBEnumDescriptor *StopTime_TimePoint_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL StopTime_TimePoint_IsValidValue(int32_t value);

#pragma mark - GtfsScheduleRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
GPB_FINAL @interface GtfsScheduleRoot : GPBRootObject
@end

#pragma mark - Agency

typedef GPB_ENUM(Agency_FieldNumber) {
  Agency_FieldNumber_AgencyId = 1,
  Agency_FieldNumber_AgencyName = 2,
  Agency_FieldNumber_AgencyURL = 3,
  Agency_FieldNumber_AgencyTimezone = 4,
  Agency_FieldNumber_AgencyLang = 5,
  Agency_FieldNumber_AgencyPhone = 6,
  Agency_FieldNumber_AgencyFareURL = 7,
  Agency_FieldNumber_AgencyEmail = 8,
};

/**
 * Transit agencies with service represented in this dataset.
 **/
GPB_FINAL @interface Agency : GPBMessage

/**
 * Identifies a transit brand which is often synonymous with a transit agency.
 * Note that in some cases, such as when a single agency operates multiple
 * separate services, agencies and brands are distinct. This document uses the
 * term "agency" in place of "brand". A dataset may contain data from multiple
 * agencies.
 * Conditionally Required:
 * - Required when the dataset contains data for multiple transit agencies.
 * - Recommended otherwise.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyId;

/**
 * Full name of the transit agency.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyName;

/**
 * URL of the transit agency.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyURL;

/**
 * Timezone where the transit agency is located. If multiple agencies are
 * specified in the dataset, each must have the same agency_timezone.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyTimezone;

/**
 * Primary language used by this transit agency. Should be provided to help
 * GTFS consumers choose capitalization rules and other language-specific
 * settings for the dataset.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyLang;

/**
 * A voice telephone number for the specified agency. This field is a string
 * value that presents the telephone number as typical for the agency's
 * service area. It may contain punctuation marks to group the digits of the
 * number. Dialable text (for example, TriMet's "503-238-RIDE") is permitted,
 * but the field must not contain any other descriptive text.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyPhone;

/**
 * URL of a web page that allows a rider to purchase tickets or other fare
 * instruments for that agency online.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyFareURL;

/**
 * Email address actively monitored by the agency’s customer service
 * department. This email address should be a direct contact point where
 * transit riders can reach a customer service representative at the agency.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyEmail;

@end

#pragma mark - Stop

typedef GPB_ENUM(Stop_FieldNumber) {
  Stop_FieldNumber_StopId = 1,
  Stop_FieldNumber_StopCode = 2,
  Stop_FieldNumber_StopName = 3,
  Stop_FieldNumber_TtsStopName = 4,
  Stop_FieldNumber_StopDesc = 5,
  Stop_FieldNumber_StopLat = 6,
  Stop_FieldNumber_StopLon = 7,
  Stop_FieldNumber_ZoneId = 8,
  Stop_FieldNumber_StopURL = 9,
  Stop_FieldNumber_LocationType = 10,
  Stop_FieldNumber_ParentStation = 11,
  Stop_FieldNumber_StopTimezone = 12,
  Stop_FieldNumber_WheelchairBoarding = 13,
  Stop_FieldNumber_LevelId = 14,
  Stop_FieldNumber_PlatformCode = 15,
};

/**
 * Stops where vehicles pick up or drop off riders. Also defines stations and
 * station entrances.
 **/
GPB_FINAL @interface Stop : GPBMessage

/**
 * Identifies a location: stop/platform, station, entrance/exit, generic node
 * or boarding area (see location_type).
 * Multiple routes may use the same stop_id.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopId;

/**
 * Short text or a number that identifies the location for riders. These codes
 * are often used in phone-based transit information systems or printed on
 * signage to make it easier for riders to get information for a particular
 * location. The stop_code may be the same as stop_id if it is public facing.
 * This field should be left empty for locations without a code presented to
 * riders.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopCode;

/**
 * Name of the location. The stop_name should match the agency's rider-facing
 * name for the location as printed on a timetable, published online, or
 * represented on signage. For translations into other languages, use
 * translations.txt.
 * When the location is a boarding area (location_type=4), the stop_name
 * should contains the name of the boarding area as displayed by the agency.
 * It could be just one letter (like on some European intercity railway
 * stations), or text like “Wheelchair boarding area” (NYC’s Subway) or “Head
 * of short trains” (Paris’ RER).
 * Conditionally Required:
 * - Required for locations which are stops (location_type=0), stations
 * (location_type=1) or entrances/exits (location_type=2).
 * - Optional for locations which are generic nodes (location_type=3) or
 * boarding areas (location_type=4).
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopName;

/**
 * Readable version of the stop_name. See "Text-to-speech field" in the Term
 * Definitions for more https://gtfs.org/schedule/reference/#term-definitions.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *ttsStopName;

/**
 * Description of the location that provides useful, quality information.
 * Should not be a duplicate of stop_name.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopDesc;

/**
 * Latitude of the location.
 * For stops/platforms (location_type=0) and boarding area (location_type=4),
 * the coordinates must be the ones of the bus pole — if exists — and
 * otherwise of where the travelers are boarding the vehicle (on the sidewalk
 * or the platform, and not on the roadway or the track where the vehicle
 * stops).
 * Conditionally Required:
 * - Required for locations which are stops (location_type=0), stations
 * (location_type=1) or entrances/exits (location_type=2).
 * - Optional for locations which are generic nodes (location_type=3) or
 * boarding areas (location_type=4).
 **/
@property(nonatomic, readwrite) double stopLat;

/**
 * Longitude of the location.
 * For stops/platforms (location_type=0) and boarding area (location_type=4),
 * the coordinates must be the ones of the bus pole — if exists — and
 * otherwise of where the travelers are boarding the vehicle (on the sidewalk
 * or the platform, and not on the roadway or the track where the vehicle
 * stops).
 * Conditionally Required:
 * - Required for locations which are stops (location_type=0), stations
 * (location_type=1) or entrances/exits (location_type=2).
 * - Optional for locations which are generic nodes (location_type=3) or
 * boarding areas (location_type=4).
 **/
@property(nonatomic, readwrite) double stopLon;

/**
 * Identifies the fare zone for a stop. If this record represents a station or
 * station entrance, the zone_id is ignored.
 * Conditionally Required:
 * - Required if providing fare information using fare_rules.txt
 * - Optional otherwise.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *zoneId;

/**
 * URL of a web page about the location. This should be different from the
 * agency.agency_url and the routes.route_url field values.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopURL;

/** Location type. */
@property(nonatomic, readwrite) Stop_LocationType locationType;

/**
 * Defines hierarchy between the different locations defined in stops.txt. It
 * contains the ID of the parent location, as followed:
 * - Stop/platform (location_type=0): the parent_station field contains the ID
 * of a station.
 * - Station (location_type=1): this field must be empty.
 * - Entrance/exit (location_type=2) or generic node (location_type=3): the
 * parent_station field contains the ID of a station (location_type=1)
 * - Boarding Area (location_type=4): the parent_station field contains ID of
 * a platform.
 * Conditionally Required:
 * - Required for locations which are entrances (location_type=2), generic
 * nodes (location_type=3) or boarding areas (location_type=4).
 * - Optional for stops/platforms (location_type=0).
 * - Forbidden for stations (location_type=1).
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *parentStation;

/**
 * Timezone of the location. If the location has a parent station, it inherits
 * the parent station’s timezone instead of applying its own. Stations and
 * parentless stops with empty stop_timezone inherit the timezone specified by
 * agency.agency_timezone. If stop_timezone values are provided, the times in
 * stop_times.txt should be entered as the time since midnight in the timezone
 * specified by agency.agency_timezone. This ensures that the time values in a
 * trip always increase over the course of a trip, regardless of which
 * timezones the trip crosses.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopTimezone;

/** Indicates whether wheelchair boardings are possible from the location. */
@property(nonatomic, readwrite) Stop_WheelchairBoarding wheelchairBoarding;

/**
 * Level of the location. The same level may be used by multiple unlinked
 * stations.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *levelId;

/**
 * Platform identifier for a platform stop (a stop belonging to a station).
 * This should be just the platform identifier (eg. "G" or "3"). Words like
 * “platform” or "track" (or the feed’s language-specific equivalent) should
 * not be included. This allows feed consumers to more easily internationalize
 * and localize the platform identifier into other languages.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *platformCode;

@end

/**
 * Fetches the raw value of a @c Stop's @c locationType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Stop_LocationType_RawValue(Stop *message);
/**
 * Sets the raw value of an @c Stop's @c locationType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetStop_LocationType_RawValue(Stop *message, int32_t value);

/**
 * Fetches the raw value of a @c Stop's @c wheelchairBoarding property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Stop_WheelchairBoarding_RawValue(Stop *message);
/**
 * Sets the raw value of an @c Stop's @c wheelchairBoarding property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetStop_WheelchairBoarding_RawValue(Stop *message, int32_t value);

#pragma mark - Route

typedef GPB_ENUM(Route_FieldNumber) {
  Route_FieldNumber_RouteId = 1,
  Route_FieldNumber_AgencyId = 2,
  Route_FieldNumber_RouteShortName = 3,
  Route_FieldNumber_RouteLongName = 4,
  Route_FieldNumber_RouteDesc = 5,
  Route_FieldNumber_RouteType = 6,
  Route_FieldNumber_RouteURL = 7,
  Route_FieldNumber_RouteColor = 8,
  Route_FieldNumber_RouteTextColor = 9,
  Route_FieldNumber_RouteSortOrder = 10,
  Route_FieldNumber_ContinuousPickup = 11,
  Route_FieldNumber_ContinuousDropOff = 12,
  Route_FieldNumber_NetworkId = 13,
};

/**
 * Transit routes. A route is a group of trips that are displayed to riders as a
 * single service.
 **/
GPB_FINAL @interface Route : GPBMessage

/**
 * Identifies a route.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeId;

/**
 * Agency for the specified route.
 * Conditionally Required:
 * - Required if multiple agencies are defined in agency.txt.
 * - Recommended otherwise.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *agencyId;

/**
 * Short name of a route. Often a short, abstract identifier (e.g., "32",
 * "100X", "Green") that riders use to identify a route. Both route_short_name
 * and route_long_name may be defined.
 * Conditionally Required:
 * - Required if routes.route_long_name is empty.
 * - Recommended if there is a brief service designation. This should be the
 * commonly-known passenger name of the service, and should be no longer than
 * 12 characters.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeShortName;

/**
 * Full name of a route. This name is generally more descriptive than the
 * route_short_name and often includes the route's destination or stop. Both
 * route_short_name and route_long_name may be defined.
 * Conditionally Required:
 * - Required if routes.route_short_name is empty.
 * - Optional otherwise.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeLongName;

/**
 * Description of a route that provides useful, quality information. Should
 * not be a duplicate of route_short_name or route_long_name.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeDesc;

/**
 * Indicates the type of transportation used on a route.
 * Required
 **/
@property(nonatomic, readwrite) Route_RouteType routeType;

/**
 * URL of a web page about the particular route. Should be different from the
 * agency.agency_url value.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeURL;

/**
 * Route color designation that matches public facing material. Defaults to
 * white (FFFFFF) when omitted or left empty. The color difference between
 * route_color and route_text_color should provide sufficient contrast when
 * viewed on a black and white screen.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeColor;

/**
 * Legible color to use for text drawn against a background of route_color.
 * Defaults to black (000000) when omitted or left empty. The color difference
 * between route_color and route_text_color should provide sufficient contrast
 * when viewed on a black and white screen.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeTextColor;

/**
 * Orders the routes in a way which is ideal for presentation to customers.
 * Routes with smaller route_sort_order values should be displayed first.
 **/
@property(nonatomic, readwrite) uint32_t routeSortOrder;

/**
 * Indicates that the rider can board the transit vehicle at any point along
 * the vehicle’s travel path as described by shapes.txt, on every trip of the
 * route.
 **/
@property(nonatomic, readwrite) ContinuousPickup continuousPickup;

/**
 * Indicates that the rider can alight from the transit vehicle at any point
 * along the vehicle’s travel path as described by shapes.txt, on every trip
 * of the route.
 **/
@property(nonatomic, readwrite) ContinuousDropOff continuousDropOff;

/**
 * Identifies a group of routes. Multiple rows in routes.txt may have the same
 * network_id.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *networkId;

@end

/**
 * Fetches the raw value of a @c Route's @c routeType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Route_RouteType_RawValue(Route *message);
/**
 * Sets the raw value of an @c Route's @c routeType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetRoute_RouteType_RawValue(Route *message, int32_t value);

/**
 * Fetches the raw value of a @c Route's @c continuousPickup property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Route_ContinuousPickup_RawValue(Route *message);
/**
 * Sets the raw value of an @c Route's @c continuousPickup property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetRoute_ContinuousPickup_RawValue(Route *message, int32_t value);

/**
 * Fetches the raw value of a @c Route's @c continuousDropOff property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Route_ContinuousDropOff_RawValue(Route *message);
/**
 * Sets the raw value of an @c Route's @c continuousDropOff property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetRoute_ContinuousDropOff_RawValue(Route *message, int32_t value);

#pragma mark - Trip

typedef GPB_ENUM(Trip_FieldNumber) {
  Trip_FieldNumber_RouteId = 1,
  Trip_FieldNumber_ServiceId = 2,
  Trip_FieldNumber_TripId = 3,
  Trip_FieldNumber_TripHeadsign = 4,
  Trip_FieldNumber_TripShortName = 5,
  Trip_FieldNumber_DirectionId = 6,
  Trip_FieldNumber_BlockId = 7,
  Trip_FieldNumber_ShapeId = 8,
  Trip_FieldNumber_WheelchairAccessible = 9,
  Trip_FieldNumber_BikesAllowed = 10,
};

/**
 * Trips for each route. A trip is a sequence of two or more stops that occur
 * during a specific time period.
 **/
GPB_FINAL @interface Trip : GPBMessage

/**
 * Identifies a route.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *routeId;

/**
 * Identifies a set of dates when service is available for one or more routes.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *serviceId;

/**
 * Identifies a trip.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *tripId;

/**
 * Text that appears on signage identifying the trip's destination to riders.
 * Should be used to distinguish between different patterns of service on the
 * same route.
 * If the headsign changes during a trip, values for trip_headsign may be
 * overridden by defining values in stop_times.stop_headsign for specific
 * stop_times along the trip.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *tripHeadsign;

/**
 * Public facing text used to identify the trip to riders, for instance, to
 * identify train numbers for commuter rail trips. If riders do not commonly
 * rely on trip names, trip_short_name should be empty. A trip_short_name
 * value, if provided, should uniquely identify a trip within a service day;
 * it should not be used for destination names or limited/express
 * designations.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *tripShortName;

/**
 * Indicates the direction of travel for a trip.
 * This field should not be used in routing; it provides a way to separate
 * trips by direction when publishing time tables.
 **/
@property(nonatomic, readwrite) Trip_Direction directionId;

/**
 * Identifies the block to which the trip belongs. A block consists of a
 * single trip or many sequential trips made using the same vehicle, defined
 * by shared service days and block_id. A block_id may have trips with
 * different service days, making distinct blocks. See the example below. To
 * provide in-seat transfers information, transfers of transfer_type 4 should
 * be provided instead.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *blockId;

/**
 * Identifies a geospatial shape describing the vehicle travel path for a
 * trip.
 * Conditionally Required:
 * - Required if the trip has a continuous pickup or drop-off behavior defined
 * either in routes.txt or in stop_times.txt.
 * - Optional otherwise.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *shapeId;

/** Indicates wheelchair accessibility. */
@property(nonatomic, readwrite) Trip_WheelchairAccessibility wheelchairAccessible;

/** Indicates whether bikes are allowed. */
@property(nonatomic, readwrite) Trip_BikeAllowance bikesAllowed;

@end

/**
 * Fetches the raw value of a @c Trip's @c directionId property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Trip_DirectionId_RawValue(Trip *message);
/**
 * Sets the raw value of an @c Trip's @c directionId property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetTrip_DirectionId_RawValue(Trip *message, int32_t value);

/**
 * Fetches the raw value of a @c Trip's @c wheelchairAccessible property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Trip_WheelchairAccessible_RawValue(Trip *message);
/**
 * Sets the raw value of an @c Trip's @c wheelchairAccessible property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetTrip_WheelchairAccessible_RawValue(Trip *message, int32_t value);

/**
 * Fetches the raw value of a @c Trip's @c bikesAllowed property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Trip_BikesAllowed_RawValue(Trip *message);
/**
 * Sets the raw value of an @c Trip's @c bikesAllowed property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetTrip_BikesAllowed_RawValue(Trip *message, int32_t value);

#pragma mark - StopTime

typedef GPB_ENUM(StopTime_FieldNumber) {
  StopTime_FieldNumber_TripId = 1,
  StopTime_FieldNumber_ArrivalTime = 2,
  StopTime_FieldNumber_DepartureTime = 3,
  StopTime_FieldNumber_StopId = 4,
  StopTime_FieldNumber_StopSequence = 5,
  StopTime_FieldNumber_StopHeadsign = 6,
  StopTime_FieldNumber_PickupType = 7,
  StopTime_FieldNumber_DropOffType = 8,
  StopTime_FieldNumber_ContinuousPickup = 9,
  StopTime_FieldNumber_ContinuousDropOff = 10,
  StopTime_FieldNumber_ShapeDistTraveled = 11,
  StopTime_FieldNumber_Timepoint = 12,
};

/**
 * Times that a vehicle arrives at and departs from stops for each trip.
 **/
GPB_FINAL @interface StopTime : GPBMessage

/**
 * Identifies a trip.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *tripId;

/**
 * Arrival time at the stop (defined by stop_times.stop_id) for a specific
 * trip (defined by stop_times.trip_id) in the time zone specified by
 * agency.agency_timezone, not stops.stop_timezone.
 * If there are not separate times for arrival and departure at a stop,
 * arrival_time and departure_time should be the same.
 * For times occurring after midnight on the service day, enter the time as a
 * value greater than 24:00:00 in HH:MM:SS.
 * If exact arrival and departure times (timepoint=1 or empty) are not
 * available, estimated or interpolated arrival and departure times
 * (timepoint=0) should be provided.
 * Conditionally Required:
 * - Required for the first and last stop in a trip (defined by
 * stop_times.stop_sequence).
 * - Required for timepoint=1.
 * - Optional otherwise.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *arrivalTime;

/**
 * Departure time from the stop (defined by stop_times.stop_id) for a specific
 * trip (defined by stop_times.trip_id) in the time zone specified by
 * agency.agency_timezone, not stops.stop_timezone.
 * If there are not separate times for arrival and departure at a stop,
 * arrival_time and departure_time should be the same.
 * For times occurring after midnight on the service day, enter the time as a
 * value greater than 24:00:00 in HH:MM:SS.
 * If exact arrival and departure times (timepoint=1 or empty) are not
 * available, estimated or interpolated arrival and departure times
 * (timepoint=0) should be provided.
 * Conditionally Required:
 * - Required for timepoint=1.
 * - Optional otherwise.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *departureTime;

/**
 * Identifies the serviced stop. All stops serviced during a trip must have a
 * record in stop_times.txt. Referenced locations must be stops/platforms,
 * i.e. their stops.location_type value must be 0 or empty. A stop may be
 * serviced multiple times in the same trip, and multiple trips and routes may
 * service the same stop.
 * Required
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopId;

/**
 * Order of stops for a particular trip. The values must increase along the
 * trip but do not need to be consecutive.
 * Required
 **/
@property(nonatomic, readwrite) uint32_t stopSequence;

/**
 * Text that appears on signage identifying the trip's destination to riders.
 * This field overrides the default trips.trip_headsign when the headsign
 * changes between stops. If the headsign is displayed for an entire trip,
 * trips.trip_headsign should be used instead.
 * A stop_headsign value specified for one stop_time does not apply to
 * subsequent stop_times in the same trip. If you want to override the
 * trip_headsign for multiple stop_times in the same trip, the stop_headsign
 * value must be repeated in each stop_time row.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *stopHeadsign;

/** Indicates pickup method. */
@property(nonatomic, readwrite) StopTime_PickupType pickupType;

/** Indicates drop off method. */
@property(nonatomic, readwrite) StopTime_DropOffType dropOffType;

/**
 * Indicates that the rider can board the transit vehicle at any point along
 * the vehicle’s travel path as described by shapes.txt, from this stop_time
 * to the next stop_time in the trip’s stop_sequence.
 * If this field is populated, it overrides any continuous pickup behavior
 * defined in routes.txt. If this field is empty, the stop_time inherits any
 * continuous pickup behavior defined in routes.txt.
 **/
@property(nonatomic, readwrite) ContinuousPickup continuousPickup;

/**
 * Indicates that the rider can alight from the transit vehicle at any point
 * along the vehicle’s travel path as described by shapes.txt, from this
 * stop_time to the next stop_time in the trip’s stop_sequence.
 * If this field is populated, it overrides any continuous drop-off behavior
 * defined in routes.txt. If this field is empty, the stop_time inherits any
 * continuous drop-off behavior defined in routes.txt.
 **/
@property(nonatomic, readwrite) ContinuousDropOff continuousDropOff;

/**
 * Actual distance traveled along the associated shape, from the first stop to
 * the stop specified in this record. This field specifies how much of the
 * shape to draw between any two stops during a trip. Must be in the same
 * units used in shapes.txt. Values used for shape_dist_traveled must increase
 * along with stop_sequence; they must not be used to show reverse travel
 * along a route.
 * Recommended for routes that have looping or inlining (the vehicle crosses
 * or travels over the same portion of alignment in one trip). See
 * shapes.shape_dist_traveled.
 **/
@property(nonatomic, readwrite) float shapeDistTraveled;

/**
 * Indicates if arrival and departure times for a stop are strictly adhered to
 * by the vehicle or if they are instead approximate and/or interpolated
 * times. This field allows a GTFS producer to provide interpolated
 * stop-times, while indicating that the times are approximate.
 **/
@property(nonatomic, readwrite) uint32_t timepoint;

@end

/**
 * Fetches the raw value of a @c StopTime's @c pickupType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t StopTime_PickupType_RawValue(StopTime *message);
/**
 * Sets the raw value of an @c StopTime's @c pickupType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetStopTime_PickupType_RawValue(StopTime *message, int32_t value);

/**
 * Fetches the raw value of a @c StopTime's @c dropOffType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t StopTime_DropOffType_RawValue(StopTime *message);
/**
 * Sets the raw value of an @c StopTime's @c dropOffType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetStopTime_DropOffType_RawValue(StopTime *message, int32_t value);

/**
 * Fetches the raw value of a @c StopTime's @c continuousPickup property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t StopTime_ContinuousPickup_RawValue(StopTime *message);
/**
 * Sets the raw value of an @c StopTime's @c continuousPickup property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetStopTime_ContinuousPickup_RawValue(StopTime *message, int32_t value);

/**
 * Fetches the raw value of a @c StopTime's @c continuousDropOff property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t StopTime_ContinuousDropOff_RawValue(StopTime *message);
/**
 * Sets the raw value of an @c StopTime's @c continuousDropOff property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetStopTime_ContinuousDropOff_RawValue(StopTime *message, int32_t value);

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
