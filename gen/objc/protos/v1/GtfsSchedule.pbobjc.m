// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/v1/gtfs-schedule.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "protos/v1/GtfsSchedule.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GtfsScheduleRoot

@implementation GtfsScheduleRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - GtfsScheduleRoot_FileDescriptor

static GPBFileDescriptor *GtfsScheduleRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"transit_scheduled"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ContinuousPickup

GPBEnumDescriptor *ContinuousPickup_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContinuousPickupStopping\000ContinuousPicku"
        "pNoContinuousStopping\000ContinuousPickupMu"
        "stPhoneAgency\000ContinuousPickupMustCoordi"
        "nateWithDriver\000";
    static const int32_t values[] = {
        ContinuousPickup_ContinuousPickupStopping,
        ContinuousPickup_ContinuousPickupNoContinuousStopping,
        ContinuousPickup_ContinuousPickupMustPhoneAgency,
        ContinuousPickup_ContinuousPickupMustCoordinateWithDriver,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ContinuousPickup)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ContinuousPickup_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ContinuousPickup_IsValidValue(int32_t value__) {
  switch (value__) {
    case ContinuousPickup_ContinuousPickupStopping:
    case ContinuousPickup_ContinuousPickupNoContinuousStopping:
    case ContinuousPickup_ContinuousPickupMustPhoneAgency:
    case ContinuousPickup_ContinuousPickupMustCoordinateWithDriver:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ContinuousDropOff

GPBEnumDescriptor *ContinuousDropOff_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContinuousDropOffContinuousStopping\000Cont"
        "inuousDropOffNoContinuousStopping\000Contin"
        "uousDropOffMustPhoneAgency\000ContinuousDro"
        "pOffMustCoordinateWithDriver\000";
    static const int32_t values[] = {
        ContinuousDropOff_ContinuousDropOffContinuousStopping,
        ContinuousDropOff_ContinuousDropOffNoContinuousStopping,
        ContinuousDropOff_ContinuousDropOffMustPhoneAgency,
        ContinuousDropOff_ContinuousDropOffMustCoordinateWithDriver,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ContinuousDropOff)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ContinuousDropOff_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ContinuousDropOff_IsValidValue(int32_t value__) {
  switch (value__) {
    case ContinuousDropOff_ContinuousDropOffContinuousStopping:
    case ContinuousDropOff_ContinuousDropOffNoContinuousStopping:
    case ContinuousDropOff_ContinuousDropOffMustPhoneAgency:
    case ContinuousDropOff_ContinuousDropOffMustCoordinateWithDriver:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Agency

@implementation Agency

@dynamic agencyId;
@dynamic agencyName;
@dynamic agencyURL;
@dynamic agencyTimezone;
@dynamic agencyLang;
@dynamic agencyPhone;
@dynamic agencyFareURL;
@dynamic agencyEmail;

typedef struct Agency__storage_ {
  uint32_t _has_storage_[1];
  NSString *agencyId;
  NSString *agencyName;
  NSString *agencyURL;
  NSString *agencyTimezone;
  NSString *agencyLang;
  NSString *agencyPhone;
  NSString *agencyFareURL;
  NSString *agencyEmail;
} Agency__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "agencyId",
        .dataTypeSpecific.clazz = Nil,
        .number = Agency_FieldNumber_AgencyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Agency__storage_, agencyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agencyName",
        .dataTypeSpecific.clazz = Nil,
        .number = Agency_FieldNumber_AgencyName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Agency__storage_, agencyName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agencyURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Agency_FieldNumber_AgencyURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Agency__storage_, agencyURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agencyTimezone",
        .dataTypeSpecific.clazz = Nil,
        .number = Agency_FieldNumber_AgencyTimezone,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Agency__storage_, agencyTimezone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agencyLang",
        .dataTypeSpecific.clazz = Nil,
        .number = Agency_FieldNumber_AgencyLang,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Agency__storage_, agencyLang),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agencyPhone",
        .dataTypeSpecific.clazz = Nil,
        .number = Agency_FieldNumber_AgencyPhone,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Agency__storage_, agencyPhone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agencyFareURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Agency_FieldNumber_AgencyFareURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Agency__storage_, agencyFareURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agencyEmail",
        .dataTypeSpecific.clazz = Nil,
        .number = Agency_FieldNumber_AgencyEmail,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Agency__storage_, agencyEmail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Agency class]
                                     rootClass:[GtfsScheduleRoot class]
                                          file:GtfsScheduleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Agency__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\006\241!!\000\007\006\244\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Stop

@implementation Stop

@dynamic stopId;
@dynamic stopCode;
@dynamic stopName;
@dynamic ttsStopName;
@dynamic stopDesc;
@dynamic stopLat;
@dynamic stopLon;
@dynamic zoneId;
@dynamic stopURL;
@dynamic locationType;
@dynamic parentStation;
@dynamic stopTimezone;
@dynamic wheelchairBoarding;
@dynamic levelId;
@dynamic platformCode;

typedef struct Stop__storage_ {
  uint32_t _has_storage_[1];
  Stop_LocationType locationType;
  Stop_WheelchairBoarding wheelchairBoarding;
  NSString *stopId;
  NSString *stopCode;
  NSString *stopName;
  NSString *ttsStopName;
  NSString *stopDesc;
  NSString *zoneId;
  NSString *stopURL;
  NSString *parentStation;
  NSString *stopTimezone;
  NSString *levelId;
  NSString *platformCode;
  double stopLat;
  double stopLon;
} Stop__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stopId",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_StopId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Stop__storage_, stopId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stopCode",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_StopCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Stop__storage_, stopCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stopName",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_StopName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Stop__storage_, stopName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ttsStopName",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_TtsStopName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Stop__storage_, ttsStopName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stopDesc",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_StopDesc,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Stop__storage_, stopDesc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stopLat",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_StopLat,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Stop__storage_, stopLat),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "stopLon",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_StopLon,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Stop__storage_, stopLon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "zoneId",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_ZoneId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Stop__storage_, zoneId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stopURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_StopURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Stop__storage_, stopURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locationType",
        .dataTypeSpecific.enumDescFunc = Stop_LocationType_EnumDescriptor,
        .number = Stop_FieldNumber_LocationType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Stop__storage_, locationType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "parentStation",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_ParentStation,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Stop__storage_, parentStation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stopTimezone",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_StopTimezone,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Stop__storage_, stopTimezone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wheelchairBoarding",
        .dataTypeSpecific.enumDescFunc = Stop_WheelchairBoarding_EnumDescriptor,
        .number = Stop_FieldNumber_WheelchairBoarding,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Stop__storage_, wheelchairBoarding),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "levelId",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_LevelId,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Stop__storage_, levelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platformCode",
        .dataTypeSpecific.clazz = Nil,
        .number = Stop_FieldNumber_PlatformCode,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Stop__storage_, platformCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Stop class]
                                     rootClass:[GtfsScheduleRoot class]
                                          file:GtfsScheduleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Stop__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Stop_LocationType_RawValue(Stop *message) {
  GPBDescriptor *descriptor = [Stop descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Stop_FieldNumber_LocationType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetStop_LocationType_RawValue(Stop *message, int32_t value) {
  GPBDescriptor *descriptor = [Stop descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Stop_FieldNumber_LocationType];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Stop_WheelchairBoarding_RawValue(Stop *message) {
  GPBDescriptor *descriptor = [Stop descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Stop_FieldNumber_WheelchairBoarding];
  return GPBGetMessageRawEnumField(message, field);
}

void SetStop_WheelchairBoarding_RawValue(Stop *message, int32_t value) {
  GPBDescriptor *descriptor = [Stop descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Stop_FieldNumber_WheelchairBoarding];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Stop_LocationType

GPBEnumDescriptor *Stop_LocationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LocationTypeStop\000LocationTypeStation\000Loc"
        "ationTypeEntranceExit\000LocationTypeGeneri"
        "cNode\000LocationTypeBoardingArea\000";
    static const int32_t values[] = {
        Stop_LocationType_LocationTypeStop,
        Stop_LocationType_LocationTypeStation,
        Stop_LocationType_LocationTypeEntranceExit,
        Stop_LocationType_LocationTypeGenericNode,
        Stop_LocationType_LocationTypeBoardingArea,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Stop_LocationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Stop_LocationType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Stop_LocationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Stop_LocationType_LocationTypeStop:
    case Stop_LocationType_LocationTypeStation:
    case Stop_LocationType_LocationTypeEntranceExit:
    case Stop_LocationType_LocationTypeGenericNode:
    case Stop_LocationType_LocationTypeBoardingArea:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Stop_WheelchairBoarding

GPBEnumDescriptor *Stop_WheelchairBoarding_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WheelchairBoardingNoInfo\000WheelchairBoard"
        "ingPossible\000WheelchairBoardingNotPossibl"
        "e\000";
    static const int32_t values[] = {
        Stop_WheelchairBoarding_WheelchairBoardingNoInfo,
        Stop_WheelchairBoarding_WheelchairBoardingPossible,
        Stop_WheelchairBoarding_WheelchairBoardingNotPossible,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Stop_WheelchairBoarding)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Stop_WheelchairBoarding_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Stop_WheelchairBoarding_IsValidValue(int32_t value__) {
  switch (value__) {
    case Stop_WheelchairBoarding_WheelchairBoardingNoInfo:
    case Stop_WheelchairBoarding_WheelchairBoardingPossible:
    case Stop_WheelchairBoarding_WheelchairBoardingNotPossible:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Route

@implementation Route

@dynamic routeId;
@dynamic agencyId;
@dynamic routeShortName;
@dynamic routeLongName;
@dynamic routeDesc;
@dynamic routeType;
@dynamic routeURL;
@dynamic routeColor;
@dynamic routeTextColor;
@dynamic routeSortOrder;
@dynamic continuousPickup;
@dynamic continuousDropOff;
@dynamic networkId;

typedef struct Route__storage_ {
  uint32_t _has_storage_[1];
  Route_RouteType routeType;
  uint32_t routeSortOrder;
  ContinuousPickup continuousPickup;
  ContinuousDropOff continuousDropOff;
  NSString *routeId;
  NSString *agencyId;
  NSString *routeShortName;
  NSString *routeLongName;
  NSString *routeDesc;
  NSString *routeURL;
  NSString *routeColor;
  NSString *routeTextColor;
  NSString *networkId;
} Route__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "routeId",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_RouteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Route__storage_, routeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agencyId",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_AgencyId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Route__storage_, agencyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routeShortName",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_RouteShortName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Route__storage_, routeShortName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routeLongName",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_RouteLongName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Route__storage_, routeLongName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routeDesc",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_RouteDesc,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Route__storage_, routeDesc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routeType",
        .dataTypeSpecific.enumDescFunc = Route_RouteType_EnumDescriptor,
        .number = Route_FieldNumber_RouteType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Route__storage_, routeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "routeURL",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_RouteURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Route__storage_, routeURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routeColor",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_RouteColor,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Route__storage_, routeColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routeTextColor",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_RouteTextColor,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Route__storage_, routeTextColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routeSortOrder",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_RouteSortOrder,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Route__storage_, routeSortOrder),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "continuousPickup",
        .dataTypeSpecific.enumDescFunc = ContinuousPickup_EnumDescriptor,
        .number = Route_FieldNumber_ContinuousPickup,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Route__storage_, continuousPickup),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "continuousDropOff",
        .dataTypeSpecific.enumDescFunc = ContinuousDropOff_EnumDescriptor,
        .number = Route_FieldNumber_ContinuousDropOff,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Route__storage_, continuousDropOff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "networkId",
        .dataTypeSpecific.clazz = Nil,
        .number = Route_FieldNumber_NetworkId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Route__storage_, networkId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Route class]
                                     rootClass:[GtfsScheduleRoot class]
                                          file:GtfsScheduleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Route__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Route_RouteType_RawValue(Route *message) {
  GPBDescriptor *descriptor = [Route descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Route_FieldNumber_RouteType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRoute_RouteType_RawValue(Route *message, int32_t value) {
  GPBDescriptor *descriptor = [Route descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Route_FieldNumber_RouteType];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Route_ContinuousPickup_RawValue(Route *message) {
  GPBDescriptor *descriptor = [Route descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Route_FieldNumber_ContinuousPickup];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRoute_ContinuousPickup_RawValue(Route *message, int32_t value) {
  GPBDescriptor *descriptor = [Route descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Route_FieldNumber_ContinuousPickup];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Route_ContinuousDropOff_RawValue(Route *message) {
  GPBDescriptor *descriptor = [Route descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Route_FieldNumber_ContinuousDropOff];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRoute_ContinuousDropOff_RawValue(Route *message, int32_t value) {
  GPBDescriptor *descriptor = [Route descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Route_FieldNumber_ContinuousDropOff];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Route_RouteType

GPBEnumDescriptor *Route_RouteType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RouteTypeTramStreetcarLightrail\000RouteTyp"
        "eSubwayMetro\000RouteTypeRail\000RouteTypeBus\000"
        "RouteTypeFerry\000RouteTypeCableTram\000RouteT"
        "ypeAerialLiftSuspendedCableCar\000RouteType"
        "Funicular\000RouteTypeTrolleybus\000RouteTypeM"
        "onorail\000";
    static const int32_t values[] = {
        Route_RouteType_RouteTypeTramStreetcarLightrail,
        Route_RouteType_RouteTypeSubwayMetro,
        Route_RouteType_RouteTypeRail,
        Route_RouteType_RouteTypeBus,
        Route_RouteType_RouteTypeFerry,
        Route_RouteType_RouteTypeCableTram,
        Route_RouteType_RouteTypeAerialLiftSuspendedCableCar,
        Route_RouteType_RouteTypeFunicular,
        Route_RouteType_RouteTypeTrolleybus,
        Route_RouteType_RouteTypeMonorail,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Route_RouteType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Route_RouteType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Route_RouteType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Route_RouteType_RouteTypeTramStreetcarLightrail:
    case Route_RouteType_RouteTypeSubwayMetro:
    case Route_RouteType_RouteTypeRail:
    case Route_RouteType_RouteTypeBus:
    case Route_RouteType_RouteTypeFerry:
    case Route_RouteType_RouteTypeCableTram:
    case Route_RouteType_RouteTypeAerialLiftSuspendedCableCar:
    case Route_RouteType_RouteTypeFunicular:
    case Route_RouteType_RouteTypeTrolleybus:
    case Route_RouteType_RouteTypeMonorail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Trip

@implementation Trip

@dynamic routeId;
@dynamic serviceId;
@dynamic tripId;
@dynamic tripHeadsign;
@dynamic tripShortName;
@dynamic directionId;
@dynamic blockId;
@dynamic shapeId;
@dynamic wheelchairAccessible;
@dynamic bikesAllowed;

typedef struct Trip__storage_ {
  uint32_t _has_storage_[1];
  Trip_Direction directionId;
  Trip_WheelchairAccessibility wheelchairAccessible;
  Trip_BikeAllowance bikesAllowed;
  NSString *routeId;
  NSString *serviceId;
  NSString *tripId;
  NSString *tripHeadsign;
  NSString *tripShortName;
  NSString *blockId;
  NSString *shapeId;
} Trip__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "routeId",
        .dataTypeSpecific.clazz = Nil,
        .number = Trip_FieldNumber_RouteId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Trip__storage_, routeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = Trip_FieldNumber_ServiceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Trip__storage_, serviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tripId",
        .dataTypeSpecific.clazz = Nil,
        .number = Trip_FieldNumber_TripId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Trip__storage_, tripId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tripHeadsign",
        .dataTypeSpecific.clazz = Nil,
        .number = Trip_FieldNumber_TripHeadsign,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Trip__storage_, tripHeadsign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tripShortName",
        .dataTypeSpecific.clazz = Nil,
        .number = Trip_FieldNumber_TripShortName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Trip__storage_, tripShortName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "directionId",
        .dataTypeSpecific.enumDescFunc = Trip_Direction_EnumDescriptor,
        .number = Trip_FieldNumber_DirectionId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Trip__storage_, directionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "blockId",
        .dataTypeSpecific.clazz = Nil,
        .number = Trip_FieldNumber_BlockId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Trip__storage_, blockId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shapeId",
        .dataTypeSpecific.clazz = Nil,
        .number = Trip_FieldNumber_ShapeId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Trip__storage_, shapeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wheelchairAccessible",
        .dataTypeSpecific.enumDescFunc = Trip_WheelchairAccessibility_EnumDescriptor,
        .number = Trip_FieldNumber_WheelchairAccessible,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Trip__storage_, wheelchairAccessible),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bikesAllowed",
        .dataTypeSpecific.enumDescFunc = Trip_BikeAllowance_EnumDescriptor,
        .number = Trip_FieldNumber_BikesAllowed,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Trip__storage_, bikesAllowed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Trip class]
                                     rootClass:[GtfsScheduleRoot class]
                                          file:GtfsScheduleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Trip__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Trip_DirectionId_RawValue(Trip *message) {
  GPBDescriptor *descriptor = [Trip descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Trip_FieldNumber_DirectionId];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTrip_DirectionId_RawValue(Trip *message, int32_t value) {
  GPBDescriptor *descriptor = [Trip descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Trip_FieldNumber_DirectionId];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Trip_WheelchairAccessible_RawValue(Trip *message) {
  GPBDescriptor *descriptor = [Trip descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Trip_FieldNumber_WheelchairAccessible];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTrip_WheelchairAccessible_RawValue(Trip *message, int32_t value) {
  GPBDescriptor *descriptor = [Trip descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Trip_FieldNumber_WheelchairAccessible];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Trip_BikesAllowed_RawValue(Trip *message) {
  GPBDescriptor *descriptor = [Trip descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Trip_FieldNumber_BikesAllowed];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTrip_BikesAllowed_RawValue(Trip *message, int32_t value) {
  GPBDescriptor *descriptor = [Trip descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Trip_FieldNumber_BikesAllowed];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Trip_Direction

GPBEnumDescriptor *Trip_Direction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DirectionOneDirection\000DirectionOpposite\000";
    static const int32_t values[] = {
        Trip_Direction_DirectionOneDirection,
        Trip_Direction_DirectionOpposite,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Trip_Direction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Trip_Direction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Trip_Direction_IsValidValue(int32_t value__) {
  switch (value__) {
    case Trip_Direction_DirectionOneDirection:
    case Trip_Direction_DirectionOpposite:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Trip_WheelchairAccessibility

GPBEnumDescriptor *Trip_WheelchairAccessibility_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WheelchairAccessibilityNoInfo\000Wheelchair"
        "AccessibilityAccessible\000WheelchairAccess"
        "ibilityNotAccessible\000";
    static const int32_t values[] = {
        Trip_WheelchairAccessibility_WheelchairAccessibilityNoInfo,
        Trip_WheelchairAccessibility_WheelchairAccessibilityAccessible,
        Trip_WheelchairAccessibility_WheelchairAccessibilityNotAccessible,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Trip_WheelchairAccessibility)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Trip_WheelchairAccessibility_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Trip_WheelchairAccessibility_IsValidValue(int32_t value__) {
  switch (value__) {
    case Trip_WheelchairAccessibility_WheelchairAccessibilityNoInfo:
    case Trip_WheelchairAccessibility_WheelchairAccessibilityAccessible:
    case Trip_WheelchairAccessibility_WheelchairAccessibilityNotAccessible:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Trip_BikeAllowance

GPBEnumDescriptor *Trip_BikeAllowance_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BikeAllowanceNoInfo\000BikeAllowanceAllowed"
        "\000BikeAllowanceNotAllowed\000";
    static const int32_t values[] = {
        Trip_BikeAllowance_BikeAllowanceNoInfo,
        Trip_BikeAllowance_BikeAllowanceAllowed,
        Trip_BikeAllowance_BikeAllowanceNotAllowed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Trip_BikeAllowance)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Trip_BikeAllowance_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Trip_BikeAllowance_IsValidValue(int32_t value__) {
  switch (value__) {
    case Trip_BikeAllowance_BikeAllowanceNoInfo:
    case Trip_BikeAllowance_BikeAllowanceAllowed:
    case Trip_BikeAllowance_BikeAllowanceNotAllowed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - StopTime

@implementation StopTime

@dynamic tripId;
@dynamic arrivalTime;
@dynamic departureTime;
@dynamic stopId;
@dynamic stopSequence;
@dynamic stopHeadsign;
@dynamic pickupType;
@dynamic dropOffType;
@dynamic continuousPickup;
@dynamic continuousDropOff;
@dynamic shapeDistTraveled;
@dynamic timepoint;

typedef struct StopTime__storage_ {
  uint32_t _has_storage_[1];
  uint32_t stopSequence;
  StopTime_PickupType pickupType;
  StopTime_DropOffType dropOffType;
  ContinuousPickup continuousPickup;
  ContinuousDropOff continuousDropOff;
  float shapeDistTraveled;
  uint32_t timepoint;
  NSString *tripId;
  NSString *arrivalTime;
  NSString *departureTime;
  NSString *stopId;
  NSString *stopHeadsign;
} StopTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tripId",
        .dataTypeSpecific.clazz = Nil,
        .number = StopTime_FieldNumber_TripId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StopTime__storage_, tripId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "arrivalTime",
        .dataTypeSpecific.clazz = Nil,
        .number = StopTime_FieldNumber_ArrivalTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StopTime__storage_, arrivalTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "departureTime",
        .dataTypeSpecific.clazz = Nil,
        .number = StopTime_FieldNumber_DepartureTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StopTime__storage_, departureTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stopId",
        .dataTypeSpecific.clazz = Nil,
        .number = StopTime_FieldNumber_StopId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StopTime__storage_, stopId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stopSequence",
        .dataTypeSpecific.clazz = Nil,
        .number = StopTime_FieldNumber_StopSequence,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(StopTime__storage_, stopSequence),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "stopHeadsign",
        .dataTypeSpecific.clazz = Nil,
        .number = StopTime_FieldNumber_StopHeadsign,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(StopTime__storage_, stopHeadsign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pickupType",
        .dataTypeSpecific.enumDescFunc = StopTime_PickupType_EnumDescriptor,
        .number = StopTime_FieldNumber_PickupType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(StopTime__storage_, pickupType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dropOffType",
        .dataTypeSpecific.enumDescFunc = StopTime_DropOffType_EnumDescriptor,
        .number = StopTime_FieldNumber_DropOffType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(StopTime__storage_, dropOffType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "continuousPickup",
        .dataTypeSpecific.enumDescFunc = ContinuousPickup_EnumDescriptor,
        .number = StopTime_FieldNumber_ContinuousPickup,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(StopTime__storage_, continuousPickup),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "continuousDropOff",
        .dataTypeSpecific.enumDescFunc = ContinuousDropOff_EnumDescriptor,
        .number = StopTime_FieldNumber_ContinuousDropOff,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(StopTime__storage_, continuousDropOff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "shapeDistTraveled",
        .dataTypeSpecific.clazz = Nil,
        .number = StopTime_FieldNumber_ShapeDistTraveled,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(StopTime__storage_, shapeDistTraveled),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "timepoint",
        .dataTypeSpecific.clazz = Nil,
        .number = StopTime_FieldNumber_Timepoint,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(StopTime__storage_, timepoint),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StopTime class]
                                     rootClass:[GtfsScheduleRoot class]
                                          file:GtfsScheduleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StopTime__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t StopTime_PickupType_RawValue(StopTime *message) {
  GPBDescriptor *descriptor = [StopTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopTime_FieldNumber_PickupType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetStopTime_PickupType_RawValue(StopTime *message, int32_t value) {
  GPBDescriptor *descriptor = [StopTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopTime_FieldNumber_PickupType];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t StopTime_DropOffType_RawValue(StopTime *message) {
  GPBDescriptor *descriptor = [StopTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopTime_FieldNumber_DropOffType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetStopTime_DropOffType_RawValue(StopTime *message, int32_t value) {
  GPBDescriptor *descriptor = [StopTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopTime_FieldNumber_DropOffType];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t StopTime_ContinuousPickup_RawValue(StopTime *message) {
  GPBDescriptor *descriptor = [StopTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopTime_FieldNumber_ContinuousPickup];
  return GPBGetMessageRawEnumField(message, field);
}

void SetStopTime_ContinuousPickup_RawValue(StopTime *message, int32_t value) {
  GPBDescriptor *descriptor = [StopTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopTime_FieldNumber_ContinuousPickup];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t StopTime_ContinuousDropOff_RawValue(StopTime *message) {
  GPBDescriptor *descriptor = [StopTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopTime_FieldNumber_ContinuousDropOff];
  return GPBGetMessageRawEnumField(message, field);
}

void SetStopTime_ContinuousDropOff_RawValue(StopTime *message, int32_t value) {
  GPBDescriptor *descriptor = [StopTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopTime_FieldNumber_ContinuousDropOff];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum StopTime_PickupType

GPBEnumDescriptor *StopTime_PickupType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PickupTypeRegularlyScheduled\000PickupTypeN"
        "oneAvailable\000PickupTypeMustPhoneAgency\000P"
        "ickupTypeMustCoordinateWithDriver\000";
    static const int32_t values[] = {
        StopTime_PickupType_PickupTypeRegularlyScheduled,
        StopTime_PickupType_PickupTypeNoneAvailable,
        StopTime_PickupType_PickupTypeMustPhoneAgency,
        StopTime_PickupType_PickupTypeMustCoordinateWithDriver,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(StopTime_PickupType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:StopTime_PickupType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL StopTime_PickupType_IsValidValue(int32_t value__) {
  switch (value__) {
    case StopTime_PickupType_PickupTypeRegularlyScheduled:
    case StopTime_PickupType_PickupTypeNoneAvailable:
    case StopTime_PickupType_PickupTypeMustPhoneAgency:
    case StopTime_PickupType_PickupTypeMustCoordinateWithDriver:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum StopTime_DropOffType

GPBEnumDescriptor *StopTime_DropOffType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DropOffTypeRegularlyScheduled\000DropOffTyp"
        "eNoneAvailable\000DropOffTypeMustPhoneAgenc"
        "y\000DropOffTypeMustCoordinateWithDriver\000";
    static const int32_t values[] = {
        StopTime_DropOffType_DropOffTypeRegularlyScheduled,
        StopTime_DropOffType_DropOffTypeNoneAvailable,
        StopTime_DropOffType_DropOffTypeMustPhoneAgency,
        StopTime_DropOffType_DropOffTypeMustCoordinateWithDriver,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(StopTime_DropOffType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:StopTime_DropOffType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL StopTime_DropOffType_IsValidValue(int32_t value__) {
  switch (value__) {
    case StopTime_DropOffType_DropOffTypeRegularlyScheduled:
    case StopTime_DropOffType_DropOffTypeNoneAvailable:
    case StopTime_DropOffType_DropOffTypeMustPhoneAgency:
    case StopTime_DropOffType_DropOffTypeMustCoordinateWithDriver:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum StopTime_TimePoint

GPBEnumDescriptor *StopTime_TimePoint_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TimePointApproximate\000TimePointExact\000";
    static const int32_t values[] = {
        StopTime_TimePoint_TimePointApproximate,
        StopTime_TimePoint_TimePointExact,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(StopTime_TimePoint)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:StopTime_TimePoint_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL StopTime_TimePoint_IsValidValue(int32_t value__) {
  switch (value__) {
    case StopTime_TimePoint_TimePointApproximate:
    case StopTime_TimePoint_TimePointExact:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
