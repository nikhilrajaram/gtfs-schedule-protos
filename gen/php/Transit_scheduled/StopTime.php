<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: protos/v1/gtfs-schedule.proto

namespace Transit_scheduled;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Times that a vehicle arrives at and departs from stops for each trip.
 *
 * Generated from protobuf message <code>transit_scheduled.StopTime</code>
 */
class StopTime extends \Google\Protobuf\Internal\Message
{
    /**
     * Identifies a trip.
     * Required
     *
     * Generated from protobuf field <code>string trip_id = 1;</code>
     */
    protected $trip_id = '';
    /**
     * Arrival time at the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for the first and last stop in a trip (defined by
     * stop_times.stop_sequence).
     * - Required for timepoint=1.
     * - Optional otherwise.
     *
     * Generated from protobuf field <code>string arrival_time = 2;</code>
     */
    protected $arrival_time = '';
    /**
     * Departure time from the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for timepoint=1.
     * - Optional otherwise.
     *
     * Generated from protobuf field <code>string departure_time = 3;</code>
     */
    protected $departure_time = '';
    /**
     * Identifies the serviced stop. All stops serviced during a trip must have a
     * record in stop_times.txt. Referenced locations must be stops/platforms,
     * i.e. their stops.location_type value must be 0 or empty. A stop may be
     * serviced multiple times in the same trip, and multiple trips and routes may
     * service the same stop.
     * Required
     *
     * Generated from protobuf field <code>string stop_id = 4;</code>
     */
    protected $stop_id = '';
    /**
     * Order of stops for a particular trip. The values must increase along the
     * trip but do not need to be consecutive.
     * Required
     *
     * Generated from protobuf field <code>uint32 stop_sequence = 5;</code>
     */
    protected $stop_sequence = 0;
    /**
     * Text that appears on signage identifying the trip's destination to riders.
     * This field overrides the default trips.trip_headsign when the headsign
     * changes between stops. If the headsign is displayed for an entire trip,
     * trips.trip_headsign should be used instead.
     * A stop_headsign value specified for one stop_time does not apply to
     * subsequent stop_times in the same trip. If you want to override the
     * trip_headsign for multiple stop_times in the same trip, the stop_headsign
     * value must be repeated in each stop_time row.
     *
     * Generated from protobuf field <code>string stop_headsign = 6;</code>
     */
    protected $stop_headsign = '';
    /**
     * Indicates pickup method.
     *
     * Generated from protobuf field <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
     */
    protected $pickup_type = 0;
    /**
     * Indicates drop off method.
     *
     * Generated from protobuf field <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
     */
    protected $drop_off_type = 0;
    /**
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, from this stop_time
     * to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous pickup behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous pickup behavior defined in routes.txt.
     *
     * Generated from protobuf field <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
     */
    protected $continuous_pickup = 0;
    /**
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, from this
     * stop_time to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous drop-off behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous drop-off behavior defined in routes.txt.
     *
     * Generated from protobuf field <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
     */
    protected $continuous_drop_off = 0;
    /**
     * Actual distance traveled along the associated shape, from the first stop to
     * the stop specified in this record. This field specifies how much of the
     * shape to draw between any two stops during a trip. Must be in the same
     * units used in shapes.txt. Values used for shape_dist_traveled must increase
     * along with stop_sequence; they must not be used to show reverse travel
     * along a route.
     * Recommended for routes that have looping or inlining (the vehicle crosses
     * or travels over the same portion of alignment in one trip). See
     * shapes.shape_dist_traveled.
     *
     * Generated from protobuf field <code>float shape_dist_traveled = 11;</code>
     */
    protected $shape_dist_traveled = 0.0;
    /**
     * Indicates if arrival and departure times for a stop are strictly adhered to
     * by the vehicle or if they are instead approximate and/or interpolated
     * times. This field allows a GTFS producer to provide interpolated
     * stop-times, while indicating that the times are approximate.
     *
     * Generated from protobuf field <code>uint32 timepoint = 12;</code>
     */
    protected $timepoint = 0;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $trip_id
     *           Identifies a trip.
     *           Required
     *     @type string $arrival_time
     *           Arrival time at the stop (defined by stop_times.stop_id) for a specific
     *           trip (defined by stop_times.trip_id) in the time zone specified by
     *           agency.agency_timezone, not stops.stop_timezone.
     *           If there are not separate times for arrival and departure at a stop,
     *           arrival_time and departure_time should be the same.
     *           For times occurring after midnight on the service day, enter the time as a
     *           value greater than 24:00:00 in HH:MM:SS.
     *           If exact arrival and departure times (timepoint=1 or empty) are not
     *           available, estimated or interpolated arrival and departure times
     *           (timepoint=0) should be provided.
     *           Conditionally Required:
     *           - Required for the first and last stop in a trip (defined by
     *           stop_times.stop_sequence).
     *           - Required for timepoint=1.
     *           - Optional otherwise.
     *     @type string $departure_time
     *           Departure time from the stop (defined by stop_times.stop_id) for a specific
     *           trip (defined by stop_times.trip_id) in the time zone specified by
     *           agency.agency_timezone, not stops.stop_timezone.
     *           If there are not separate times for arrival and departure at a stop,
     *           arrival_time and departure_time should be the same.
     *           For times occurring after midnight on the service day, enter the time as a
     *           value greater than 24:00:00 in HH:MM:SS.
     *           If exact arrival and departure times (timepoint=1 or empty) are not
     *           available, estimated or interpolated arrival and departure times
     *           (timepoint=0) should be provided.
     *           Conditionally Required:
     *           - Required for timepoint=1.
     *           - Optional otherwise.
     *     @type string $stop_id
     *           Identifies the serviced stop. All stops serviced during a trip must have a
     *           record in stop_times.txt. Referenced locations must be stops/platforms,
     *           i.e. their stops.location_type value must be 0 or empty. A stop may be
     *           serviced multiple times in the same trip, and multiple trips and routes may
     *           service the same stop.
     *           Required
     *     @type int $stop_sequence
     *           Order of stops for a particular trip. The values must increase along the
     *           trip but do not need to be consecutive.
     *           Required
     *     @type string $stop_headsign
     *           Text that appears on signage identifying the trip's destination to riders.
     *           This field overrides the default trips.trip_headsign when the headsign
     *           changes between stops. If the headsign is displayed for an entire trip,
     *           trips.trip_headsign should be used instead.
     *           A stop_headsign value specified for one stop_time does not apply to
     *           subsequent stop_times in the same trip. If you want to override the
     *           trip_headsign for multiple stop_times in the same trip, the stop_headsign
     *           value must be repeated in each stop_time row.
     *     @type int $pickup_type
     *           Indicates pickup method.
     *     @type int $drop_off_type
     *           Indicates drop off method.
     *     @type int $continuous_pickup
     *           Indicates that the rider can board the transit vehicle at any point along
     *           the vehicle’s travel path as described by shapes.txt, from this stop_time
     *           to the next stop_time in the trip’s stop_sequence.
     *           If this field is populated, it overrides any continuous pickup behavior
     *           defined in routes.txt. If this field is empty, the stop_time inherits any
     *           continuous pickup behavior defined in routes.txt.
     *     @type int $continuous_drop_off
     *           Indicates that the rider can alight from the transit vehicle at any point
     *           along the vehicle’s travel path as described by shapes.txt, from this
     *           stop_time to the next stop_time in the trip’s stop_sequence.
     *           If this field is populated, it overrides any continuous drop-off behavior
     *           defined in routes.txt. If this field is empty, the stop_time inherits any
     *           continuous drop-off behavior defined in routes.txt.
     *     @type float $shape_dist_traveled
     *           Actual distance traveled along the associated shape, from the first stop to
     *           the stop specified in this record. This field specifies how much of the
     *           shape to draw between any two stops during a trip. Must be in the same
     *           units used in shapes.txt. Values used for shape_dist_traveled must increase
     *           along with stop_sequence; they must not be used to show reverse travel
     *           along a route.
     *           Recommended for routes that have looping or inlining (the vehicle crosses
     *           or travels over the same portion of alignment in one trip). See
     *           shapes.shape_dist_traveled.
     *     @type int $timepoint
     *           Indicates if arrival and departure times for a stop are strictly adhered to
     *           by the vehicle or if they are instead approximate and/or interpolated
     *           times. This field allows a GTFS producer to provide interpolated
     *           stop-times, while indicating that the times are approximate.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Protos\V1\GtfsSchedule::initOnce();
        parent::__construct($data);
    }

    /**
     * Identifies a trip.
     * Required
     *
     * Generated from protobuf field <code>string trip_id = 1;</code>
     * @return string
     */
    public function getTripId()
    {
        return $this->trip_id;
    }

    /**
     * Identifies a trip.
     * Required
     *
     * Generated from protobuf field <code>string trip_id = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setTripId($var)
    {
        GPBUtil::checkString($var, True);
        $this->trip_id = $var;

        return $this;
    }

    /**
     * Arrival time at the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for the first and last stop in a trip (defined by
     * stop_times.stop_sequence).
     * - Required for timepoint=1.
     * - Optional otherwise.
     *
     * Generated from protobuf field <code>string arrival_time = 2;</code>
     * @return string
     */
    public function getArrivalTime()
    {
        return $this->arrival_time;
    }

    /**
     * Arrival time at the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for the first and last stop in a trip (defined by
     * stop_times.stop_sequence).
     * - Required for timepoint=1.
     * - Optional otherwise.
     *
     * Generated from protobuf field <code>string arrival_time = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setArrivalTime($var)
    {
        GPBUtil::checkString($var, True);
        $this->arrival_time = $var;

        return $this;
    }

    /**
     * Departure time from the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for timepoint=1.
     * - Optional otherwise.
     *
     * Generated from protobuf field <code>string departure_time = 3;</code>
     * @return string
     */
    public function getDepartureTime()
    {
        return $this->departure_time;
    }

    /**
     * Departure time from the stop (defined by stop_times.stop_id) for a specific
     * trip (defined by stop_times.trip_id) in the time zone specified by
     * agency.agency_timezone, not stops.stop_timezone.
     * If there are not separate times for arrival and departure at a stop,
     * arrival_time and departure_time should be the same.
     * For times occurring after midnight on the service day, enter the time as a
     * value greater than 24:00:00 in HH:MM:SS.
     * If exact arrival and departure times (timepoint=1 or empty) are not
     * available, estimated or interpolated arrival and departure times
     * (timepoint=0) should be provided.
     * Conditionally Required:
     * - Required for timepoint=1.
     * - Optional otherwise.
     *
     * Generated from protobuf field <code>string departure_time = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setDepartureTime($var)
    {
        GPBUtil::checkString($var, True);
        $this->departure_time = $var;

        return $this;
    }

    /**
     * Identifies the serviced stop. All stops serviced during a trip must have a
     * record in stop_times.txt. Referenced locations must be stops/platforms,
     * i.e. their stops.location_type value must be 0 or empty. A stop may be
     * serviced multiple times in the same trip, and multiple trips and routes may
     * service the same stop.
     * Required
     *
     * Generated from protobuf field <code>string stop_id = 4;</code>
     * @return string
     */
    public function getStopId()
    {
        return $this->stop_id;
    }

    /**
     * Identifies the serviced stop. All stops serviced during a trip must have a
     * record in stop_times.txt. Referenced locations must be stops/platforms,
     * i.e. their stops.location_type value must be 0 or empty. A stop may be
     * serviced multiple times in the same trip, and multiple trips and routes may
     * service the same stop.
     * Required
     *
     * Generated from protobuf field <code>string stop_id = 4;</code>
     * @param string $var
     * @return $this
     */
    public function setStopId($var)
    {
        GPBUtil::checkString($var, True);
        $this->stop_id = $var;

        return $this;
    }

    /**
     * Order of stops for a particular trip. The values must increase along the
     * trip but do not need to be consecutive.
     * Required
     *
     * Generated from protobuf field <code>uint32 stop_sequence = 5;</code>
     * @return int
     */
    public function getStopSequence()
    {
        return $this->stop_sequence;
    }

    /**
     * Order of stops for a particular trip. The values must increase along the
     * trip but do not need to be consecutive.
     * Required
     *
     * Generated from protobuf field <code>uint32 stop_sequence = 5;</code>
     * @param int $var
     * @return $this
     */
    public function setStopSequence($var)
    {
        GPBUtil::checkUint32($var);
        $this->stop_sequence = $var;

        return $this;
    }

    /**
     * Text that appears on signage identifying the trip's destination to riders.
     * This field overrides the default trips.trip_headsign when the headsign
     * changes between stops. If the headsign is displayed for an entire trip,
     * trips.trip_headsign should be used instead.
     * A stop_headsign value specified for one stop_time does not apply to
     * subsequent stop_times in the same trip. If you want to override the
     * trip_headsign for multiple stop_times in the same trip, the stop_headsign
     * value must be repeated in each stop_time row.
     *
     * Generated from protobuf field <code>string stop_headsign = 6;</code>
     * @return string
     */
    public function getStopHeadsign()
    {
        return $this->stop_headsign;
    }

    /**
     * Text that appears on signage identifying the trip's destination to riders.
     * This field overrides the default trips.trip_headsign when the headsign
     * changes between stops. If the headsign is displayed for an entire trip,
     * trips.trip_headsign should be used instead.
     * A stop_headsign value specified for one stop_time does not apply to
     * subsequent stop_times in the same trip. If you want to override the
     * trip_headsign for multiple stop_times in the same trip, the stop_headsign
     * value must be repeated in each stop_time row.
     *
     * Generated from protobuf field <code>string stop_headsign = 6;</code>
     * @param string $var
     * @return $this
     */
    public function setStopHeadsign($var)
    {
        GPBUtil::checkString($var, True);
        $this->stop_headsign = $var;

        return $this;
    }

    /**
     * Indicates pickup method.
     *
     * Generated from protobuf field <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
     * @return int
     */
    public function getPickupType()
    {
        return $this->pickup_type;
    }

    /**
     * Indicates pickup method.
     *
     * Generated from protobuf field <code>.transit_scheduled.StopTime.PickupType pickup_type = 7;</code>
     * @param int $var
     * @return $this
     */
    public function setPickupType($var)
    {
        GPBUtil::checkEnum($var, \Transit_scheduled\StopTime\PickupType::class);
        $this->pickup_type = $var;

        return $this;
    }

    /**
     * Indicates drop off method.
     *
     * Generated from protobuf field <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
     * @return int
     */
    public function getDropOffType()
    {
        return $this->drop_off_type;
    }

    /**
     * Indicates drop off method.
     *
     * Generated from protobuf field <code>.transit_scheduled.StopTime.DropOffType drop_off_type = 8;</code>
     * @param int $var
     * @return $this
     */
    public function setDropOffType($var)
    {
        GPBUtil::checkEnum($var, \Transit_scheduled\StopTime\DropOffType::class);
        $this->drop_off_type = $var;

        return $this;
    }

    /**
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, from this stop_time
     * to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous pickup behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous pickup behavior defined in routes.txt.
     *
     * Generated from protobuf field <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
     * @return int
     */
    public function getContinuousPickup()
    {
        return $this->continuous_pickup;
    }

    /**
     * Indicates that the rider can board the transit vehicle at any point along
     * the vehicle’s travel path as described by shapes.txt, from this stop_time
     * to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous pickup behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous pickup behavior defined in routes.txt.
     *
     * Generated from protobuf field <code>.transit_scheduled.ContinuousPickup continuous_pickup = 9;</code>
     * @param int $var
     * @return $this
     */
    public function setContinuousPickup($var)
    {
        GPBUtil::checkEnum($var, \Transit_scheduled\ContinuousPickup::class);
        $this->continuous_pickup = $var;

        return $this;
    }

    /**
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, from this
     * stop_time to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous drop-off behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous drop-off behavior defined in routes.txt.
     *
     * Generated from protobuf field <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
     * @return int
     */
    public function getContinuousDropOff()
    {
        return $this->continuous_drop_off;
    }

    /**
     * Indicates that the rider can alight from the transit vehicle at any point
     * along the vehicle’s travel path as described by shapes.txt, from this
     * stop_time to the next stop_time in the trip’s stop_sequence.
     * If this field is populated, it overrides any continuous drop-off behavior
     * defined in routes.txt. If this field is empty, the stop_time inherits any
     * continuous drop-off behavior defined in routes.txt.
     *
     * Generated from protobuf field <code>.transit_scheduled.ContinuousDropOff continuous_drop_off = 10;</code>
     * @param int $var
     * @return $this
     */
    public function setContinuousDropOff($var)
    {
        GPBUtil::checkEnum($var, \Transit_scheduled\ContinuousDropOff::class);
        $this->continuous_drop_off = $var;

        return $this;
    }

    /**
     * Actual distance traveled along the associated shape, from the first stop to
     * the stop specified in this record. This field specifies how much of the
     * shape to draw between any two stops during a trip. Must be in the same
     * units used in shapes.txt. Values used for shape_dist_traveled must increase
     * along with stop_sequence; they must not be used to show reverse travel
     * along a route.
     * Recommended for routes that have looping or inlining (the vehicle crosses
     * or travels over the same portion of alignment in one trip). See
     * shapes.shape_dist_traveled.
     *
     * Generated from protobuf field <code>float shape_dist_traveled = 11;</code>
     * @return float
     */
    public function getShapeDistTraveled()
    {
        return $this->shape_dist_traveled;
    }

    /**
     * Actual distance traveled along the associated shape, from the first stop to
     * the stop specified in this record. This field specifies how much of the
     * shape to draw between any two stops during a trip. Must be in the same
     * units used in shapes.txt. Values used for shape_dist_traveled must increase
     * along with stop_sequence; they must not be used to show reverse travel
     * along a route.
     * Recommended for routes that have looping or inlining (the vehicle crosses
     * or travels over the same portion of alignment in one trip). See
     * shapes.shape_dist_traveled.
     *
     * Generated from protobuf field <code>float shape_dist_traveled = 11;</code>
     * @param float $var
     * @return $this
     */
    public function setShapeDistTraveled($var)
    {
        GPBUtil::checkFloat($var);
        $this->shape_dist_traveled = $var;

        return $this;
    }

    /**
     * Indicates if arrival and departure times for a stop are strictly adhered to
     * by the vehicle or if they are instead approximate and/or interpolated
     * times. This field allows a GTFS producer to provide interpolated
     * stop-times, while indicating that the times are approximate.
     *
     * Generated from protobuf field <code>uint32 timepoint = 12;</code>
     * @return int
     */
    public function getTimepoint()
    {
        return $this->timepoint;
    }

    /**
     * Indicates if arrival and departure times for a stop are strictly adhered to
     * by the vehicle or if they are instead approximate and/or interpolated
     * times. This field allows a GTFS producer to provide interpolated
     * stop-times, while indicating that the times are approximate.
     *
     * Generated from protobuf field <code>uint32 timepoint = 12;</code>
     * @param int $var
     * @return $this
     */
    public function setTimepoint($var)
    {
        GPBUtil::checkUint32($var);
        $this->timepoint = $var;

        return $this;
    }

}

